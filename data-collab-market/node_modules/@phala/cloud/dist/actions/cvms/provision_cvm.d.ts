import { z } from "zod";
import { type Client } from "../../client";
/**
 * Provision a CVM
 *
 * Performs a pre-deployment eligibility check, validating whether the requested resources
 * are available and the user has sufficient permissions to deploy. Returns provision data
 * including `app_id`, encryption public key (`app_env_encrypt_pubkey`), and `compose_hash`
 * required for the subsequent `commitCvmProvision` call.
 *
 * ## Automatic Resource Selection
 *
 * The new matching engine automatically selects optimal resources based on your requirements:
 * - **Node Selection**: Specify `node_id` or `region`, or omit both for automatic best-match selection
 * - **OS Image**: Specify exact image name or let system choose the latest stable version
 * - **KMS**: Choose KMS type via `kms` parameter (defaults to PHALA) or specify `kms_id` directly
 *
 * @example
 * ```typescript
 * import { createClient, provisionCvm, commitCvmProvision } from '@phala/cloud'
 *
 * const client = createClient();
 *
 * // Example 1: Minimal configuration with auto-selection
 * const provision = await provisionCvm(client, {
 *   name: 'my-app',              // Unique in workspace level
 *   instance_type: 'tdx.small',
 *   compose_file: {
 *     docker_compose_file: `
 * services:
 *   demo:
 *     image: leechael/phala-cloud-bun-starter:latest
 *     ports:
 *       - "80:3000"
 *     volumes:
 *       - /var/run/dstack.sock:/var/run/dstack.sock
 * `,
 *   },
 * });
 *
 * // Example 2: With region preference
 * const provision = await provisionCvm(client, {
 *   name: 'my-app',
 *   instance_type: 'tdx.medium',
 *   region: 'us-east',            // Filter by region
 *   compose_file: { /* ... *\/ },
 * });
 *
 * // Example 3: With specific node and KMS type
 * const provision = await provisionCvm(client, {
 *   name: 'my-app',
 *   node_id: 123,                 // Specific node
 *   kms: 'PHALA',                 // KMS type (PHALA, BASE, ETHERUEM)
 *   disk_size: 40,
 *   image: 'dstack-0.5.5',
 *   compose_file: { /* ... *\/ },
 * });
 *
 * // Example 4: Manual nonce specification (Advanced - PHALA KMS only)
 * import { nextAppIds } from '@phala/cloud';
 *
 * // Step 1: Predict next available app_id and nonce
 * const prediction = await nextAppIds(client, { counts: 1 });
 * const { app_id, nonce } = prediction.app_ids[0];
 *
 * console.log(`Predicted app_id: ${app_id}, nonce: ${nonce}`);
 *
 * // Step 2: Provision with the predicted nonce and app_id
 * const provision = await provisionCvm(client, {
 *   name: 'my-app-with-manual-nonce',
 *   instance_type: 'tdx.small',
 *   kms: 'PHALA',                 // Required: only works with PHALA KMS
 *   nonce: nonce,                 // Use predicted nonce
 *   app_id: app_id,               // Use predicted app_id
 *   compose_file: { /* ... *\/ },
 * });
 *
 * console.log(provision.app_id);
 * console.log(provision.compose_hash); // Required for commitCvmProvision
 * ```
 *
 * ## Required Parameters
 *
 * - **name**: CVM instance name
 * - **compose_file**: Docker Compose configuration with `docker_compose_file` field
 *
 * ## Optional Parameters
 *
 * ### Instance Type
 * - **instance_type**: Instance type identifier (default: "tdx.small")
 *   - Use `listAllInstanceTypeFamilies()` or `listFamilyInstanceTypes()` to discover available types
 *   - Examples: "tdx.small", "tdx.medium", "tdx.large"
 *   - Omit to use the default small instance type
 *
 * ### Manual Nonce Specification (Advanced - PHALA KMS only)
 * - **nonce**: User-specified nonce for deterministic app_id generation
 * - **app_id**: Expected app_id (must match the nonce)
 * - Workflow:
 *   1. Call `nextAppIds()` to predict available app_ids and nonces
 *   2. Use the predicted `nonce` and `app_id` in provision request
 *   3. System validates that the app_id matches the nonce
 * - When `nonce` is provided:
 *   - `app_id` MUST also be provided
 *   - Only works with PHALA KMS type
 *   - Use case: Predicting app_id before deployment for smart contract integration
 * - If both omitted, system automatically generates the next available nonce
 *
 * ### Node Selection (all optional - system auto-selects if omitted)
 * - **node_id**: Specific node ID to deploy on
 * - **region**: Region preference (e.g., "us-east", "eu-west")
 * - If both omitted, system automatically selects the best available node
 *
 * ### OS Image Selection
 * - **image**: OS image name (optional)
 *   - Omit to let the system automatically select the latest stable image
 *   - Specify a specific image name if needed (e.g., "dstack-0.5.5")
 *
 * ### KMS Configuration
 * - **kms**: KMS type - "PHALA" (default), "ETHEREUM", or "BASE"
 * - **kms_contract**: (Advanced) Specific KMS contract address
 *   - Omit to let the system automatically select an appropriate KMS contract
 *   - Specify only when: migrating KMS contracts, or selecting a specific contract on networks with multiple deployments
 *
 * ### Other Options
 * - **disk_size**: Disk size in GB (optional)
 *   - Each instance type has a default disk size
 *   - Specify only if you need a different size than the default
 * - **env_keys**: List of allowed environment variable keys
 * - **listed**: Whether the CVM is publicly listed (default: true)
 *
 * ## Returns
 *
 * Provision data object containing:
 * - **app_id**: Application identifier (required for commit step)
 * - **app_env_encrypt_pubkey**: Public key for encrypting environment variables
 * - **compose_hash**: Hash identifying this provision (required for commit step)
 * - **device_id**: Device identifier for attestation
 * - **fmspc**: Firmware Security Patch Configuration value
 * - **os_image_hash**: Hash of the selected OS image
 * - **instance_type**: The matched instance type identifier
 *
 * ## Safe Version
 *
 * Use `safeProvisionCvm` for error handling without exceptions:
 *
 * ```typescript
 * const result = await safeProvisionCvm(client, app_compose);
 * if (result.success) {
 *   console.log(result.data.app_id);
 *   console.log(result.data.compose_hash);
 * } else {
 *   console.error('Failed to provision CVM:', result.error.message);
 * }
 * ```
 */
export declare const ProvisionCvmSchema: z.ZodEffects<z.ZodObject<{
    app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    compose_hash: z.ZodString;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    compose_hash: z.ZodString;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    compose_hash: z.ZodString;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.ZodTypeAny, "passthrough">>, z.objectOutputType<{
    app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    compose_hash: z.ZodString;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    compose_hash: z.ZodString;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, z.ZodTypeAny, "passthrough">>;
export type ProvisionCvm = z.infer<typeof ProvisionCvmSchema>;
export declare const ProvisionCvmRequestSchema: z.ZodObject<{
    node_id: z.ZodOptional<z.ZodNumber>;
    teepod_id: z.ZodOptional<z.ZodNumber>;
    region: z.ZodOptional<z.ZodString>;
    name: z.ZodString;
    instance_type: z.ZodDefault<z.ZodString>;
    image: z.ZodOptional<z.ZodString>;
    vcpu: z.ZodOptional<z.ZodNumber>;
    memory: z.ZodOptional<z.ZodNumber>;
    disk_size: z.ZodOptional<z.ZodNumber>;
    compose_file: z.ZodObject<{
        allowed_envs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        pre_launch_script: z.ZodOptional<z.ZodString>;
        docker_compose_file: z.ZodOptional<z.ZodString>;
        name: z.ZodDefault<z.ZodOptional<z.ZodString>>;
        kms_enabled: z.ZodOptional<z.ZodBoolean>;
        public_logs: z.ZodOptional<z.ZodBoolean>;
        public_sysinfo: z.ZodOptional<z.ZodBoolean>;
        gateway_enabled: z.ZodOptional<z.ZodBoolean>;
        tproxy_enabled: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }, {
        name?: string | undefined;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }>;
    listed: z.ZodOptional<z.ZodBoolean>;
    kms_id: z.ZodOptional<z.ZodString>;
    kms: z.ZodOptional<z.ZodEnum<["PHALA", "ETHEREUM", "BASE"]>>;
    kms_contract: z.ZodOptional<z.ZodString>;
    env_keys: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    nonce: z.ZodOptional<z.ZodNumber>;
    app_id: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    node_id: z.ZodOptional<z.ZodNumber>;
    teepod_id: z.ZodOptional<z.ZodNumber>;
    region: z.ZodOptional<z.ZodString>;
    name: z.ZodString;
    instance_type: z.ZodDefault<z.ZodString>;
    image: z.ZodOptional<z.ZodString>;
    vcpu: z.ZodOptional<z.ZodNumber>;
    memory: z.ZodOptional<z.ZodNumber>;
    disk_size: z.ZodOptional<z.ZodNumber>;
    compose_file: z.ZodObject<{
        allowed_envs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        pre_launch_script: z.ZodOptional<z.ZodString>;
        docker_compose_file: z.ZodOptional<z.ZodString>;
        name: z.ZodDefault<z.ZodOptional<z.ZodString>>;
        kms_enabled: z.ZodOptional<z.ZodBoolean>;
        public_logs: z.ZodOptional<z.ZodBoolean>;
        public_sysinfo: z.ZodOptional<z.ZodBoolean>;
        gateway_enabled: z.ZodOptional<z.ZodBoolean>;
        tproxy_enabled: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }, {
        name?: string | undefined;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }>;
    listed: z.ZodOptional<z.ZodBoolean>;
    kms_id: z.ZodOptional<z.ZodString>;
    kms: z.ZodOptional<z.ZodEnum<["PHALA", "ETHEREUM", "BASE"]>>;
    kms_contract: z.ZodOptional<z.ZodString>;
    env_keys: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    nonce: z.ZodOptional<z.ZodNumber>;
    app_id: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    node_id: z.ZodOptional<z.ZodNumber>;
    teepod_id: z.ZodOptional<z.ZodNumber>;
    region: z.ZodOptional<z.ZodString>;
    name: z.ZodString;
    instance_type: z.ZodDefault<z.ZodString>;
    image: z.ZodOptional<z.ZodString>;
    vcpu: z.ZodOptional<z.ZodNumber>;
    memory: z.ZodOptional<z.ZodNumber>;
    disk_size: z.ZodOptional<z.ZodNumber>;
    compose_file: z.ZodObject<{
        allowed_envs: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        pre_launch_script: z.ZodOptional<z.ZodString>;
        docker_compose_file: z.ZodOptional<z.ZodString>;
        name: z.ZodDefault<z.ZodOptional<z.ZodString>>;
        kms_enabled: z.ZodOptional<z.ZodBoolean>;
        public_logs: z.ZodOptional<z.ZodBoolean>;
        public_sysinfo: z.ZodOptional<z.ZodBoolean>;
        gateway_enabled: z.ZodOptional<z.ZodBoolean>;
        tproxy_enabled: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        name: string;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }, {
        name?: string | undefined;
        public_sysinfo?: boolean | undefined;
        public_logs?: boolean | undefined;
        docker_compose_file?: string | undefined;
        allowed_envs?: string[] | undefined;
        pre_launch_script?: string | undefined;
        kms_enabled?: boolean | undefined;
        gateway_enabled?: boolean | undefined;
        tproxy_enabled?: boolean | undefined;
    }>;
    listed: z.ZodOptional<z.ZodBoolean>;
    kms_id: z.ZodOptional<z.ZodString>;
    kms: z.ZodOptional<z.ZodEnum<["PHALA", "ETHEREUM", "BASE"]>>;
    kms_contract: z.ZodOptional<z.ZodString>;
    env_keys: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    nonce: z.ZodOptional<z.ZodNumber>;
    app_id: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>;
export type ProvisionCvmRequest = z.input<typeof ProvisionCvmRequestSchema> & {
    node_id?: number;
    teepod_id?: number;
    compose_file?: {
        gateway_enabled?: boolean;
        tproxy_enabled?: boolean;
        [key: string]: unknown;
    };
    nonce?: number;
    app_id?: string;
};
declare const provisionCvm: {
    (client: Client, params: ProvisionCvmRequest): Promise<z.objectOutputType<{
        app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        compose_hash: z.ZodString;
        fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.ZodTypeAny, "passthrough">>;
    <T extends z.ZodTypeAny>(client: Client, params: ProvisionCvmRequest, parameters: {
        schema: T;
    }): Promise<z.TypeOf<T>>;
    (client: Client, params: ProvisionCvmRequest, parameters: {
        schema: false;
    }): Promise<unknown>;
}, safeProvisionCvm: {
    (client: Client, params: ProvisionCvmRequest): Promise<import("../..").SafeResult<z.objectOutputType<{
        app_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        app_env_encrypt_pubkey: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        compose_hash: z.ZodString;
        fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        instance_type: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        teepod_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        node_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
        kms_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    }, z.ZodTypeAny, "passthrough">>>;
    <T extends z.ZodTypeAny>(client: Client, params: ProvisionCvmRequest, parameters: {
        schema: T;
    }): Promise<import("../..").SafeResult<z.TypeOf<T>>>;
    (client: Client, params: ProvisionCvmRequest, parameters: {
        schema: false;
    }): Promise<import("../..").SafeResult<unknown>>;
};
export { provisionCvm, safeProvisionCvm };
