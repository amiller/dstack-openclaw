"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AddComposeHashSchema: () => AddComposeHashSchema,
  AllFamiliesResponseSchema: () => AllFamiliesResponseSchema,
  ApiErrorSchema: () => ApiErrorSchema,
  AuthError: () => AuthError,
  AvailableNodesSchema: () => AvailableNodesSchema,
  BusinessError: () => BusinessError,
  CommitCvmComposeFileUpdateRequestSchema: () => CommitCvmComposeFileUpdateRequestSchema,
  CommitCvmComposeFileUpdateSchema: () => CommitCvmComposeFileUpdateSchema,
  CommitCvmProvisionRequestSchema: () => CommitCvmProvisionRequestSchema,
  CommitCvmProvisionSchema: () => CommitCvmProvisionSchema,
  CurrentUserSchema: () => CurrentUserSchema,
  CvmAttestationSchema: () => CvmAttestationSchema,
  CvmContainersStatsSchema: () => CvmContainersStatsSchema,
  CvmIdBaseSchema: () => CvmIdBaseSchema,
  CvmIdObjectSchema: () => CvmIdObjectSchema,
  CvmIdSchema: () => CvmIdSchema,
  CvmInfoSchema: () => CvmInfoSchema,
  CvmLegacyDetailSchema: () => CvmLegacyDetailSchema,
  CvmNetworkSchema: () => CvmNetworkSchema,
  CvmNetworkUrlsSchema: () => CvmNetworkUrlsSchema,
  CvmNodeSchema: () => CvmNodeSchema,
  CvmStateSchema: () => CvmStateSchema,
  CvmSystemInfoSchema: () => CvmSystemInfoSchema,
  DeleteCvmRequestSchema: () => DeleteCvmRequestSchema,
  DeployAppAuthRequestSchema: () => DeployAppAuthRequestSchema,
  DeployAppAuthSchema: () => DeployAppAuthSchema,
  FamilyGroupSchema: () => FamilyGroupSchema,
  FamilyInstanceTypesResponseSchema: () => FamilyInstanceTypesResponseSchema,
  GetAppEnvEncryptPubKeyRequestSchema: () => GetAppEnvEncryptPubKeyRequestSchema,
  GetAppEnvEncryptPubKeySchema: () => GetAppEnvEncryptPubKeySchema,
  GetAvailableOSImagesRequestSchema: () => GetAvailableOSImagesRequestSchema,
  GetAvailableOSImagesResponseSchema: () => GetAvailableOSImagesResponseSchema,
  GetCvmAttestationRequestSchema: () => GetCvmAttestationRequestSchema,
  GetCvmComposeFileRequestSchema: () => GetCvmComposeFileRequestSchema,
  GetCvmContainersStatsRequestSchema: () => GetCvmContainersStatsRequestSchema,
  GetCvmDockerComposeRequestSchema: () => GetCvmDockerComposeRequestSchema,
  GetCvmInfoRequestSchema: () => GetCvmInfoRequestSchema,
  GetCvmListRequestSchema: () => GetCvmListRequestSchema,
  GetCvmListSchema: () => GetCvmListSchema,
  GetCvmNetworkRequestSchema: () => GetCvmNetworkRequestSchema,
  GetCvmStateRequestSchema: () => GetCvmStateRequestSchema,
  GetCvmStatsRequestSchema: () => GetCvmStatsRequestSchema,
  GetKmsInfoRequestSchema: () => GetKmsInfoRequestSchema,
  GetKmsListRequestSchema: () => GetKmsListRequestSchema,
  GetKmsListSchema: () => GetKmsListSchema,
  InstanceTypeSchema: () => InstanceTypeSchema,
  KmsInfoSchema: () => KmsInfoSchema,
  ListFamilyInstanceTypesRequestSchema: () => ListFamilyInstanceTypesRequestSchema,
  ListWorkspacesSchema: () => ListWorkspacesSchema,
  ManagedUserSchema: () => ManagedUserSchema,
  MaxRetriesExceededError: () => MaxRetriesExceededError,
  NetworkError: () => NetworkError,
  NextAppIdsRequestSchema: () => NextAppIdsRequestSchema,
  NextAppIdsSchema: () => NextAppIdsSchema,
  OSImageVariantSchema: () => OSImageVariantSchema,
  PaginationMetadataSchema: () => PaginationMetadataSchema,
  PhalaCloudError: () => PhalaCloudError,
  ProvisionCvmComposeFileUpdateRequestSchema: () => ProvisionCvmComposeFileUpdateRequestSchema,
  ProvisionCvmComposeFileUpdateResultSchema: () => ProvisionCvmComposeFileUpdateResultSchema,
  ProvisionCvmRequestSchema: () => ProvisionCvmRequestSchema,
  ProvisionCvmSchema: () => ProvisionCvmSchema,
  RequestError: () => RequestError,
  ResourceError: () => ResourceError,
  RestartCvmRequestSchema: () => RestartCvmRequestSchema,
  SUPPORTED_API_VERSIONS: () => SUPPORTED_API_VERSIONS,
  SUPPORTED_CHAINS: () => SUPPORTED_CHAINS,
  ServerError: () => ServerError,
  ShutdownCvmRequestSchema: () => ShutdownCvmRequestSchema,
  StartCvmRequestSchema: () => StartCvmRequestSchema,
  StopCvmRequestSchema: () => StopCvmRequestSchema,
  TransactionError: () => TransactionError,
  UnknownError: () => UnknownError,
  UpdateCvmEnvsRequestSchema: () => UpdateCvmEnvsRequestSchema,
  UpdateCvmEnvsResultSchema: () => UpdateCvmEnvsResultSchema,
  UpdateCvmResourcesRequestSchema: () => UpdateCvmResourcesRequestSchema,
  UpdateCvmVisibilityRequestSchema: () => UpdateCvmVisibilityRequestSchema,
  UpdateOsImageRequestSchema: () => UpdateOsImageRequestSchema,
  VMSchema: () => VMSchema,
  ValidationError: () => ValidationError,
  VmInfoSchema: () => VmInfoSchema,
  WalletError: () => WalletError,
  WatchAbortedError: () => WatchAbortedError,
  WatchCvmStateRequestSchema: () => WatchCvmStateRequestSchema,
  WorkspaceResponseSchema: () => WorkspaceResponseSchema,
  addComposeHash: () => addComposeHash,
  addNetwork: () => addNetwork,
  asHex: () => asHex,
  autoCreateClients: () => autoCreateClients,
  checkBalance: () => checkBalance,
  checkNetworkStatus: () => checkNetworkStatus,
  commitCvmComposeFileUpdate: () => commitCvmComposeFileUpdate,
  commitCvmProvision: () => commitCvmProvision,
  createBaseClient: () => createClient,
  createClient: () => createClient2,
  createClientsFromBrowser: () => createClientsFromBrowser,
  createClientsFromPrivateKey: () => createClientsFromPrivateKey,
  createNetworkClients: () => createNetworkClients,
  createTransactionTracker: () => createTransactionTracker,
  defineAction: () => defineAction,
  defineSimpleAction: () => defineSimpleAction,
  deleteCvm: () => deleteCvm,
  deployAppAuth: () => deployAppAuth,
  dumpAppCompose: () => dumpAppCompose,
  encryptEnvVars: () => import_encrypt_env_vars2.encryptEnvVars,
  estimateTransactionGas: () => estimateTransactionGas,
  executeBatchTransactions: () => executeBatchTransactions,
  executeTransaction: () => executeTransaction,
  executeTransactionWithRetry: () => executeTransactionWithRetry,
  extractNetworkClients: () => extractNetworkClients,
  formatErrorMessage: () => formatErrorMessage,
  formatStructuredError: () => formatStructuredError,
  formatValidationErrors: () => formatValidationErrors,
  getAppEnvEncryptPubKey: () => getAppEnvEncryptPubKey,
  getAvailableNodes: () => getAvailableNodes,
  getAvailableOsImages: () => getAvailableOsImages,
  getComposeHash: () => import_get_compose_hash3.getComposeHash,
  getCurrentUser: () => getCurrentUser,
  getCvmAttestation: () => getCvmAttestation,
  getCvmComposeFile: () => getCvmComposeFile,
  getCvmContainersStats: () => getCvmContainersStats,
  getCvmDockerCompose: () => getCvmDockerCompose,
  getCvmInfo: () => getCvmInfo,
  getCvmList: () => getCvmList,
  getCvmNetwork: () => getCvmNetwork,
  getCvmState: () => getCvmState,
  getCvmStats: () => getCvmStats,
  getErrorMessage: () => getErrorMessage,
  getKmsInfo: () => getKmsInfo,
  getKmsList: () => getKmsList,
  getValidationFields: () => getValidationFields,
  getWorkspace: () => getWorkspace,
  listAllInstanceTypeFamilies: () => listAllInstanceTypeFamilies,
  listFamilyInstanceTypes: () => listFamilyInstanceTypes,
  listWorkspaces: () => listWorkspaces,
  nextAppIds: () => nextAppIds,
  parseApiError: () => parseApiError,
  parseEnv: () => parseEnv,
  parseEnvVars: () => parseEnvVars,
  preprocessAppCompose: () => preprocessAppCompose,
  provisionCvm: () => provisionCvm,
  provisionCvmComposeFileUpdate: () => provisionCvmComposeFileUpdate,
  refineCvmId: () => refineCvmId,
  restartCvm: () => restartCvm,
  safeAddComposeHash: () => safeAddComposeHash,
  safeCommitCvmComposeFileUpdate: () => safeCommitCvmComposeFileUpdate,
  safeCommitCvmProvision: () => safeCommitCvmProvision,
  safeDeleteCvm: () => safeDeleteCvm,
  safeDeployAppAuth: () => safeDeployAppAuth,
  safeGetAppEnvEncryptPubKey: () => safeGetAppEnvEncryptPubKey,
  safeGetAvailableNodes: () => safeGetAvailableNodes,
  safeGetAvailableOsImages: () => safeGetAvailableOsImages,
  safeGetCurrentUser: () => safeGetCurrentUser,
  safeGetCvmAttestation: () => safeGetCvmAttestation,
  safeGetCvmComposeFile: () => safeGetCvmComposeFile,
  safeGetCvmContainersStats: () => safeGetCvmContainersStats,
  safeGetCvmDockerCompose: () => safeGetCvmDockerCompose,
  safeGetCvmInfo: () => safeGetCvmInfo,
  safeGetCvmList: () => safeGetCvmList,
  safeGetCvmNetwork: () => safeGetCvmNetwork,
  safeGetCvmState: () => safeGetCvmState,
  safeGetCvmStats: () => safeGetCvmStats,
  safeGetKmsInfo: () => safeGetKmsInfo,
  safeGetKmsList: () => safeGetKmsList,
  safeGetWorkspace: () => safeGetWorkspace,
  safeListAllInstanceTypeFamilies: () => safeListAllInstanceTypeFamilies,
  safeListFamilyInstanceTypes: () => safeListFamilyInstanceTypes,
  safeListWorkspaces: () => safeListWorkspaces,
  safeNextAppIds: () => safeNextAppIds,
  safeProvisionCvm: () => safeProvisionCvm,
  safeProvisionCvmComposeFileUpdate: () => safeProvisionCvmComposeFileUpdate,
  safeRestartCvm: () => safeRestartCvm,
  safeShutdownCvm: () => safeShutdownCvm,
  safeStartCvm: () => safeStartCvm,
  safeStopCvm: () => safeStopCvm,
  safeUpdateCvmEnvs: () => safeUpdateCvmEnvs,
  safeUpdateCvmResources: () => safeUpdateCvmResources,
  safeUpdateCvmVisibility: () => safeUpdateCvmVisibility,
  safeUpdateOsImage: () => safeUpdateOsImage,
  safeValidateActionParameters: () => safeValidateActionParameters,
  shutdownCvm: () => shutdownCvm,
  sortObject: () => sortObject,
  startCvm: () => startCvm,
  stopCvm: () => stopCvm,
  switchToNetwork: () => switchToNetwork,
  updateCvmEnvs: () => updateCvmEnvs,
  updateCvmResources: () => updateCvmResources,
  updateCvmVisibility: () => updateCvmVisibility,
  updateOsImage: () => updateOsImage,
  validateActionParameters: () => validateActionParameters,
  validateNetworkPrerequisites: () => validateNetworkPrerequisites,
  verifyEnvEncryptPublicKey: () => import_verify_env_encrypt_public_key.verifyEnvEncryptPublicKey,
  waitForTransactionReceipt: () => waitForTransactionReceipt,
  watchCvmState: () => watchCvmState,
  withComposeMethods: () => withComposeMethods
});
module.exports = __toCommonJS(index_exports);

// src/client.ts
var import_ofetch = require("ofetch");
var import_debug = __toESM(require("debug"));
var import_mitt = __toESM(require("mitt"));

// src/utils/errors.ts
var import_zod = require("zod");
var ApiErrorSchema = import_zod.z.object({
  detail: import_zod.z.union([
    import_zod.z.string(),
    import_zod.z.array(
      import_zod.z.object({
        msg: import_zod.z.string(),
        type: import_zod.z.string().optional(),
        ctx: import_zod.z.record(import_zod.z.unknown()).optional(),
        loc: import_zod.z.array(import_zod.z.union([import_zod.z.string(), import_zod.z.number()])).optional(),
        input: import_zod.z.unknown().optional()
      }).passthrough()
      // Allow additional fields
    ),
    import_zod.z.record(import_zod.z.unknown())
  ]).optional(),
  type: import_zod.z.string().optional(),
  code: import_zod.z.string().optional()
});
var PhalaCloudError = class extends Error {
  constructor(message, data) {
    super(message);
    this.name = this.constructor.name;
    this.status = data.status;
    this.statusText = data.statusText;
    this.detail = data.detail;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var RequestError = class _RequestError extends PhalaCloudError {
  constructor(message, options) {
    super(message, {
      status: options?.status ?? 0,
      statusText: options?.statusText ?? "Unknown Error",
      detail: options?.detail || message
    });
    this.name = "RequestError";
    this.isRequestError = true;
    this.data = options?.data;
    this.request = options?.request;
    this.response = options?.response;
    this.code = options?.code;
    this.type = options?.type;
  }
  /**
   * Create RequestError from FetchError
   */
  static fromFetchError(error) {
    const parseResult = ApiErrorSchema.safeParse(error.data);
    if (parseResult.success) {
      return new _RequestError(error.message, {
        status: error.status ?? void 0,
        statusText: error.statusText ?? void 0,
        data: error.data,
        request: error.request ?? void 0,
        response: error.response ?? void 0,
        detail: parseResult.data.detail,
        code: parseResult.data.code ?? void 0,
        type: parseResult.data.type ?? void 0
      });
    }
    return new _RequestError(error.message, {
      status: error.status ?? void 0,
      statusText: error.statusText ?? void 0,
      data: error.data,
      request: error.request ?? void 0,
      response: error.response ?? void 0,
      detail: error.data?.detail || "Unknown API error",
      code: error.status?.toString() ?? void 0
    });
  }
  /**
   * Create RequestError from generic Error
   */
  static fromError(error, request) {
    return new _RequestError(error.message, {
      request: request ?? void 0,
      detail: error.message
    });
  }
};
var ValidationError = class extends PhalaCloudError {
  constructor(message, data) {
    super(message, data);
    this.isValidationError = true;
    this.validationErrors = data.validationErrors;
  }
};
var AuthError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isAuthError = true;
  }
};
var BusinessError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isBusinessError = true;
  }
};
var ServerError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isServerError = true;
  }
};
var UnknownError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isUnknownError = true;
  }
};
function extractFieldPath(loc) {
  if (!loc || !Array.isArray(loc)) {
    return "unknown";
  }
  const filtered = loc.filter((part) => {
    if (typeof part === "string") {
      return !["body", "query", "path", "header"].includes(part);
    }
    return true;
  });
  return filtered.length > 0 ? filtered.join(".") : "unknown";
}
function parseValidationErrors(detail) {
  if (!Array.isArray(detail)) {
    return {
      errors: [],
      message: typeof detail === "string" ? detail : "Validation error"
    };
  }
  const errors = detail.map(
    (item, index) => {
      const field = extractFieldPath(item.loc);
      let displayField = field;
      if (field === "unknown" && item.type) {
        displayField = item.type === "missing" ? "required field" : item.type;
      }
      return {
        field: displayField,
        message: item.msg,
        type: item.type,
        context: item.ctx
      };
    }
  );
  const count = errors.length;
  const message = count === 1 ? `Validation failed: ${errors[0].message}` : `Validation failed (${count} issue${count > 1 ? "s" : ""})`;
  return { errors, message };
}
function categorizeErrorType(status) {
  if (status === 422) {
    return "validation";
  }
  if (status === 401) {
    return "auth";
  }
  if (status === 403) {
    return "auth";
  }
  if (status >= 400 && status < 500) {
    return "business";
  }
  if (status >= 500) {
    return "server";
  }
  return "unknown";
}
function extractPrimaryMessage(status, detail, defaultMessage) {
  if (status === 422 && Array.isArray(detail)) {
    const { message } = parseValidationErrors(detail);
    return message;
  }
  if (typeof detail === "string") {
    return detail;
  }
  if (detail && typeof detail === "object" && "message" in detail) {
    const msg = detail.message;
    if (typeof msg === "string") {
      return msg;
    }
  }
  return defaultMessage;
}
function parseApiError(requestError) {
  const status = requestError.status ?? 0;
  const statusText = requestError.statusText ?? "Unknown Error";
  const detail = requestError.detail;
  const structured = parseStructuredError(detail);
  if (structured) {
    return new ResourceError(structured.message, {
      status,
      statusText,
      detail,
      errorCode: structured.error_code,
      structuredDetails: structured.details,
      suggestions: structured.suggestions,
      links: structured.links
    });
  }
  const errorType = categorizeErrorType(status);
  const message = extractPrimaryMessage(status, detail, requestError.message);
  const commonData = { status, statusText, detail };
  if (errorType === "validation" && Array.isArray(detail)) {
    const { errors } = parseValidationErrors(detail);
    return new ValidationError(message, {
      ...commonData,
      validationErrors: errors
    });
  }
  if (errorType === "auth") {
    return new AuthError(message, commonData);
  }
  if (errorType === "business") {
    return new BusinessError(message, commonData);
  }
  if (errorType === "server") {
    return new ServerError(message, commonData);
  }
  return new UnknownError(message, commonData);
}
function getValidationFields(error) {
  if (error instanceof ValidationError) {
    return error.validationErrors.map((e) => e.field);
  }
  return [];
}
function formatValidationErrors(errors, options) {
  const { numbered = true, indent = 2, showFields = true } = options ?? {};
  const indentStr = " ".repeat(indent);
  return errors.map((error, index) => {
    const prefix = numbered ? `${index + 1}. ` : "\u2022 ";
    const field = showFields ? `${error.field}: ` : "";
    return `${indentStr}${prefix}${field}${error.message}`;
  }).join("\n");
}
function formatErrorMessage(error, options) {
  const { showFields = true, showType = false } = options ?? {};
  const parts = [];
  if (showType) {
    parts.push(`[${error.constructor.name.toUpperCase()}]`);
  }
  parts.push(error.message);
  if (error instanceof ValidationError && error.validationErrors.length > 0) {
    parts.push("");
    parts.push(formatValidationErrors(error.validationErrors, { showFields }));
  }
  return parts.join("\n");
}
function getErrorMessage(error) {
  if (typeof error.detail === "string") {
    return error.detail;
  }
  if (Array.isArray(error.detail)) {
    if (error.detail.length > 0) {
      return error.detail[0]?.msg || "Validation error";
    }
    return "Validation error";
  }
  if (typeof error.detail === "object" && error.detail !== null) {
    return JSON.stringify(error.detail);
  }
  return "Unknown error occurred";
}
var ResourceError = class extends BusinessError {
  constructor(message, data) {
    super(message, data);
    this.isResourceError = true;
    this.errorCode = data.errorCode;
    this.structuredDetails = data.structuredDetails;
    this.suggestions = data.suggestions;
    this.links = data.links;
  }
};
function parseStructuredError(detail) {
  if (!detail || typeof detail !== "object") {
    return null;
  }
  const obj = detail;
  if (obj.error_code && typeof obj.error_code === "string" && obj.message && typeof obj.message === "string") {
    return {
      error_code: obj.error_code,
      message: obj.message,
      details: obj.details,
      suggestions: obj.suggestions,
      links: obj.links
    };
  }
  return null;
}
function formatStructuredError(error, options) {
  const { showErrorCode = true, showSuggestions = true, showLinks = true } = options ?? {};
  const parts = [];
  if (showErrorCode && error.errorCode) {
    parts.push(`Error [${error.errorCode}]: ${error.message}`);
  } else {
    parts.push(error.message);
  }
  if (error.structuredDetails && error.structuredDetails.length > 0) {
    parts.push("");
    parts.push("Details:");
    error.structuredDetails.forEach((d) => {
      if (d.message) {
        parts.push(`  - ${d.message}`);
      } else if (d.field && d.value !== void 0) {
        parts.push(`  - ${d.field}: ${d.value}`);
      }
    });
  }
  if (showSuggestions && error.suggestions && error.suggestions.length > 0) {
    parts.push("");
    parts.push("Suggestions:");
    error.suggestions.forEach((s) => {
      parts.push(`  - ${s}`);
    });
  }
  if (showLinks && error.links && error.links.length > 0) {
    parts.push("");
    parts.push("Learn more:");
    error.links.forEach((link) => {
      parts.push(`  - ${link.label}: ${link.url}`);
    });
  }
  return parts.join("\n");
}

// src/client.ts
var SUPPORTED_API_VERSIONS = ["2025-05-31", "2025-10-28"];
var logger = (0, import_debug.default)("phala::api-client");
function formatHeaders(headers) {
  return Object.entries(headers).map(([key, value]) => `    -H "${key}: ${value}"`).join("\n");
}
function formatBody(body) {
  if (!body) return "";
  const bodyStr = typeof body === "string" ? body : JSON.stringify(body, null, 2);
  return `    -d '${bodyStr.replace(/'/g, "\\'")}'`;
}
function formatResponse(status, statusText, headers, body) {
  const headerEntries = [];
  headers.forEach((value, key) => {
    headerEntries.push(`${key}: ${value}`);
  });
  const headerStr = headerEntries.join("\n");
  const bodyStr = typeof body === "string" ? body : JSON.stringify(body, null, 2);
  return [
    `< HTTP/1.1 ${status} ${statusText}`,
    headerStr ? `< ${headerStr.replace(/\n/g, "\n< ")}` : "",
    "",
    bodyStr
  ].filter(Boolean).join("\n");
}
var Client = class {
  constructor(config = {}) {
    this.emitter = (0, import_mitt.default)();
    const resolvedConfig = {
      ...config,
      apiKey: config.apiKey || process?.env?.PHALA_CLOUD_API_KEY,
      baseURL: config.baseURL || process?.env?.PHALA_CLOUD_API_PREFIX || "https://cloud-api.phala.network/api/v1"
    };
    const version = resolvedConfig.version && SUPPORTED_API_VERSIONS.includes(resolvedConfig.version) ? resolvedConfig.version : SUPPORTED_API_VERSIONS[SUPPORTED_API_VERSIONS.length - 1];
    this.config = resolvedConfig;
    const { apiKey, baseURL, timeout, headers, useCookieAuth, onResponseError, ...fetchOptions } = resolvedConfig;
    const requestHeaders = {
      "X-Phala-Version": version,
      "Content-Type": "application/json"
    };
    if (headers && typeof headers === "object") {
      Object.entries(headers).forEach(([key, value]) => {
        if (typeof value === "string") {
          requestHeaders[key] = value;
        }
      });
    }
    if (!useCookieAuth && apiKey) {
      requestHeaders["X-API-Key"] = apiKey;
    }
    this.fetchInstance = import_ofetch.ofetch.create({
      baseURL,
      timeout: timeout || 3e4,
      headers: requestHeaders,
      ...useCookieAuth ? { credentials: "include" } : {},
      ...fetchOptions,
      // Log request in cURL format
      onRequest({ request, options }) {
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          const fullUrl = url.startsWith("http") ? url : `${baseURL}${url}`;
          const headerObj = {};
          if (options.headers && typeof options.headers === "object") {
            Object.entries(options.headers).forEach(([key, value]) => {
              if (typeof value === "string") {
                headerObj[key] = value;
              }
            });
          }
          const curlCommand = [
            `> curl -X ${method} "${fullUrl}"`,
            formatHeaders(headerObj),
            options.body ? formatBody(options.body) : ""
          ].filter(Boolean).join("\n");
          logger("\n=== REQUEST ===\n%s\n", curlCommand);
        }
      },
      // Log response in cURL format
      onResponse({ request, response, options }) {
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          logger(
            "\n=== RESPONSE [%s %s] (%dms) ===\n%s\n",
            method,
            url,
            response.headers.get("x-response-time") || "?",
            formatResponse(response.status, response.statusText, response.headers, response._data)
          );
        }
      },
      // Generic handlers for response error (similar to request.ts)
      onResponseError: ({ request, response, options }) => {
        console.warn(`HTTP ${response.status}: ${response.url}`);
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          logger(
            "\n=== ERROR RESPONSE [%s %s] ===\n%s\n",
            method,
            url,
            formatResponse(response.status, response.statusText, response.headers, response._data)
          );
        }
        if (onResponseError) {
          onResponseError({ request, response, options });
        }
      }
    });
  }
  /**
   * Get the underlying ofetch instance for advanced usage
   */
  get raw() {
    return this.fetchInstance;
  }
  on(type, handler) {
    this.emitter.on(type, handler);
  }
  off(type, handler) {
    this.emitter.off(type, handler);
  }
  once(type, handler) {
    const wrappedHandler = (event) => {
      handler(event);
      this.emitter.off(type, wrappedHandler);
    };
    this.emitter.on(type, wrappedHandler);
  }
  // ===== Direct methods (throw on error) =====
  /**
   * Perform GET request (throws PhalaCloudError on error)
   */
  async get(request, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "GET"
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform POST request (throws PhalaCloudError on error)
   */
  async post(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "POST",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform PUT request (throws PhalaCloudError on error)
   */
  async put(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "PUT",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform PATCH request (throws PhalaCloudError on error)
   */
  async patch(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "PATCH",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform DELETE request (throws PhalaCloudError on error)
   */
  async delete(request, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "DELETE"
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  // ===== Safe methods (return SafeResult) =====
  /**
   * Convert any error to RequestError
   */
  convertToRequestError(error) {
    if (error && typeof error === "object" && "data" in error) {
      return RequestError.fromFetchError(error);
    }
    if (error instanceof Error) {
      return RequestError.fromError(error);
    }
    return new RequestError("Unknown error occurred", {
      detail: "Unknown error occurred"
    });
  }
  /**
   * Broadcast error to event listeners (fire-and-forget)
   * @param requestError - The request error to handle
   * @returns PhalaCloudError instance to throw immediately
   */
  emitError(requestError) {
    const phalaCloudError = parseApiError(requestError);
    this.emitter.emit("error", phalaCloudError);
    return phalaCloudError;
  }
  /**
   * Safe wrapper for any request method (zod-style result)
   * Returns PhalaCloudError (all errors extend this base class)
   */
  async safeRequest(fn) {
    try {
      const data = await fn();
      return { success: true, data };
    } catch (error) {
      if (error instanceof PhalaCloudError) {
        return { success: false, error };
      }
      const requestError = this.convertToRequestError(error);
      this.emitError(requestError);
      return { success: false, error: requestError };
    }
  }
  /**
   * Safe GET request (returns SafeResult)
   */
  async safeGet(request, options) {
    return this.safeRequest(() => this.get(request, options));
  }
  /**
   * Safe POST request (returns SafeResult)
   */
  async safePost(request, body, options) {
    return this.safeRequest(() => this.post(request, body, options));
  }
  /**
   * Safe PUT request (returns SafeResult)
   */
  async safePut(request, body, options) {
    return this.safeRequest(() => this.put(request, body, options));
  }
  /**
   * Safe PATCH request (returns SafeResult)
   */
  async safePatch(request, body, options) {
    return this.safeRequest(() => this.patch(request, body, options));
  }
  /**
   * Safe DELETE request (returns SafeResult)
   */
  async safeDelete(request, options) {
    return this.safeRequest(() => this.delete(request, options));
  }
  /**
   * Extend client with additional actions
   *
   * @example
   * ```typescript
   * const client = createClient({ apiKey: 'xxx' })
   *   .extend(publicActions)
   *   .extend(cvmActions)
   *
   * await client.getCurrentUser() // Method call instead of function call
   * ```
   */
  extend(actions) {
    const actionsObj = typeof actions === "function" ? actions(this) : actions;
    const extended = Object.create(this);
    for (const [key, action] of Object.entries(actionsObj)) {
      if (typeof action === "function") {
        extended[key] = (...args) => action(this, ...args);
      }
    }
    return extended;
  }
};
function createClient(config = {}) {
  return new Client(config);
}

// src/actions/get_current_user.ts
var import_zod2 = require("zod");

// src/utils/validate-parameters.ts
function validateActionParameters(parameters) {
  if (parameters?.schema !== void 0 && parameters?.schema !== false) {
    if (typeof parameters.schema !== "object" || parameters.schema === null || !("parse" in parameters.schema) || typeof parameters.schema.parse !== "function") {
      throw new Error("Invalid schema: must be a Zod schema object, false, or undefined");
    }
  }
}
function safeValidateActionParameters(parameters) {
  if (parameters?.schema !== void 0 && parameters?.schema !== false) {
    if (typeof parameters.schema !== "object" || parameters.schema === null || !("parse" in parameters.schema) || typeof parameters.schema.parse !== "function") {
      return {
        success: false,
        error: {
          name: "ZodError",
          message: "Invalid schema: must be a Zod schema object, false, or undefined",
          issues: [
            {
              code: "invalid_type",
              expected: "object",
              received: typeof parameters.schema,
              path: ["schema"],
              message: "Invalid schema: must be a Zod schema object, false, or undefined"
            }
          ]
        }
      };
    }
  }
  return void 0;
}

// src/utils/define-action.ts
function defineSimpleAction(schema, fn) {
  function action(client, parameters) {
    return _actionImpl(client, parameters);
  }
  async function _actionImpl(client, parameters) {
    validateActionParameters(parameters);
    const response = await fn(client);
    if (parameters?.schema === false) {
      return response;
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.parse(response);
  }
  function safeAction(client, parameters) {
    return _safeActionImpl(client, parameters);
  }
  async function _safeActionImpl(client, parameters) {
    const parameterValidationError = safeValidateActionParameters(parameters);
    if (parameterValidationError) {
      return parameterValidationError;
    }
    const httpResult = await (async () => {
      try {
        const data = await fn(client);
        return { success: true, data };
      } catch (error) {
        if (error && typeof error === "object" && "status" in error) {
          return { success: false, error };
        }
        if (error && typeof error === "object" && "issues" in error) {
          return { success: false, error };
        }
        return {
          success: false,
          error: {
            name: "Error",
            message: error instanceof Error ? error.message : String(error)
          }
        };
      }
    })();
    if (!httpResult.success) {
      return httpResult;
    }
    if (parameters?.schema === false) {
      return { success: true, data: httpResult.data };
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.safeParse(httpResult.data);
  }
  return {
    action,
    safeAction
  };
}
function defineAction(schema, fn) {
  function action(client, ...args) {
    const [params, parameters] = args;
    return _actionImpl(client, params, parameters);
  }
  async function _actionImpl(client, params, parameters) {
    validateActionParameters(parameters);
    const response = await fn(client, params);
    if (parameters?.schema === false) {
      return response;
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.parse(response);
  }
  function safeAction(client, ...args) {
    const [params, parameters] = args;
    return _safeActionImpl(client, params, parameters);
  }
  async function _safeActionImpl(client, params, parameters) {
    const parameterValidationError = safeValidateActionParameters(parameters);
    if (parameterValidationError) {
      return parameterValidationError;
    }
    const httpResult = await (async () => {
      try {
        const data = await fn(client, params);
        return { success: true, data };
      } catch (error) {
        if (error && typeof error === "object" && "status" in error) {
          return { success: false, error };
        }
        if (error && typeof error === "object" && "issues" in error) {
          return { success: false, error };
        }
        return {
          success: false,
          error: {
            name: "Error",
            message: error instanceof Error ? error.message : String(error)
          }
        };
      }
    })();
    if (!httpResult.success) {
      return httpResult;
    }
    if (parameters?.schema === false) {
      return { success: true, data: httpResult.data };
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.safeParse(httpResult.data);
  }
  return {
    action,
    safeAction
  };
}

// src/actions/get_current_user.ts
var CurrentUserSchema = import_zod2.z.object({
  username: import_zod2.z.string(),
  email: import_zod2.z.string(),
  credits: import_zod2.z.number(),
  granted_credits: import_zod2.z.number(),
  avatar: import_zod2.z.string(),
  team_name: import_zod2.z.string(),
  team_tier: import_zod2.z.string()
}).passthrough();
var { action: getCurrentUser, safeAction: safeGetCurrentUser } = defineSimpleAction(
  CurrentUserSchema,
  async (client) => {
    return await client.get("/auth/me");
  }
);

// src/actions/get_available_nodes.ts
var import_zod4 = require("zod");

// src/types/kms_info.ts
var import_zod3 = require("zod");

// src/types/supported_chains.ts
var import_chains = require("viem/chains");
var SUPPORTED_CHAINS = {
  [import_chains.mainnet.id]: import_chains.mainnet,
  [import_chains.base.id]: import_chains.base,
  [import_chains.anvil.id]: import_chains.anvil
};

// src/types/kms_info.ts
var KmsInfoBaseSchema = import_zod3.z.object({
  id: import_zod3.z.string(),
  slug: import_zod3.z.string().nullable(),
  url: import_zod3.z.string(),
  version: import_zod3.z.string(),
  chain_id: import_zod3.z.number().nullable(),
  kms_contract_address: import_zod3.z.string().nullable().transform((val) => val),
  gateway_app_id: import_zod3.z.string().nullable().transform((val) => val)
}).passthrough();
var KmsInfoSchema = KmsInfoBaseSchema.transform((data) => {
  if (data.chain_id != null) {
    const chain = SUPPORTED_CHAINS[data.chain_id];
    if (chain) {
      return { ...data, chain };
    }
  }
  return data;
});

// src/actions/get_available_nodes.ts
var AvailableOSImageSchema = import_zod4.z.object({
  name: import_zod4.z.string(),
  is_dev: import_zod4.z.boolean(),
  version: import_zod4.z.union([
    import_zod4.z.tuple([import_zod4.z.number(), import_zod4.z.number(), import_zod4.z.number()]),
    import_zod4.z.tuple([import_zod4.z.number(), import_zod4.z.number(), import_zod4.z.number(), import_zod4.z.number()])
  ]),
  os_image_hash: import_zod4.z.string().nullable().optional()
}).passthrough();
var TeepodCapacitySchema = import_zod4.z.object({
  teepod_id: import_zod4.z.number(),
  name: import_zod4.z.string(),
  listed: import_zod4.z.boolean(),
  resource_score: import_zod4.z.number(),
  remaining_vcpu: import_zod4.z.number(),
  remaining_memory: import_zod4.z.number(),
  remaining_cvm_slots: import_zod4.z.number(),
  images: import_zod4.z.array(AvailableOSImageSchema),
  support_onchain_kms: import_zod4.z.boolean().optional(),
  fmspc: import_zod4.z.string().nullable().optional(),
  device_id: import_zod4.z.string().nullable().optional(),
  region_identifier: import_zod4.z.string().nullable().optional(),
  default_kms: import_zod4.z.string().nullable().optional(),
  kms_list: import_zod4.z.array(import_zod4.z.string()).default([])
}).passthrough();
var ResourceThresholdSchema = import_zod4.z.object({
  max_instances: import_zod4.z.number().nullable().optional(),
  max_vcpu: import_zod4.z.number().nullable().optional(),
  max_memory: import_zod4.z.number().nullable().optional(),
  max_disk: import_zod4.z.number().nullable().optional()
}).passthrough();
var AvailableNodesSchema = import_zod4.z.object({
  tier: import_zod4.z.string(),
  // TeamTier is string enum
  capacity: ResourceThresholdSchema,
  nodes: import_zod4.z.array(TeepodCapacitySchema),
  kms_list: import_zod4.z.array(KmsInfoSchema)
}).passthrough();
var { action: getAvailableNodes, safeAction: safeGetAvailableNodes } = defineSimpleAction(
  AvailableNodesSchema,
  async (client) => {
    return await client.get("/teepods/available");
  }
);

// src/actions/list-instance-types.ts
var import_zod5 = require("zod");
var InstanceTypeSchema = import_zod5.z.object({
  id: import_zod5.z.string(),
  name: import_zod5.z.string(),
  description: import_zod5.z.string(),
  vcpu: import_zod5.z.number(),
  memory_mb: import_zod5.z.number(),
  hourly_rate: import_zod5.z.string(),
  requires_gpu: import_zod5.z.boolean(),
  default_disk_size_gb: import_zod5.z.number().default(20),
  family: import_zod5.z.string().nullable()
}).passthrough();
var FamilyGroupSchema = import_zod5.z.object({
  name: import_zod5.z.string(),
  items: import_zod5.z.array(InstanceTypeSchema),
  total: import_zod5.z.number()
}).strict();
var AllFamiliesResponseSchema = import_zod5.z.object({
  result: import_zod5.z.array(FamilyGroupSchema)
}).strict();
var FamilyInstanceTypesResponseSchema = import_zod5.z.object({
  items: import_zod5.z.array(InstanceTypeSchema),
  total: import_zod5.z.number(),
  family: import_zod5.z.string()
}).strict();
var ListFamilyInstanceTypesRequestSchema = import_zod5.z.object({
  family: import_zod5.z.string()
}).strict();
var { action: listAllInstanceTypeFamilies, safeAction: safeListAllInstanceTypeFamilies } = defineAction(
  AllFamiliesResponseSchema,
  async (client) => {
    return await client.get("/instance-types");
  }
);
var { action: listFamilyInstanceTypes, safeAction: safeListFamilyInstanceTypes } = defineAction(FamilyInstanceTypesResponseSchema, async (client, request) => {
  const validated = ListFamilyInstanceTypesRequestSchema.parse(request);
  return await client.get(`/instance-types/${validated.family}`);
});

// src/actions/workspaces/list_workspaces.ts
var import_zod6 = require("zod");
var WorkspaceResponseSchema = import_zod6.z.object({
  id: import_zod6.z.string(),
  name: import_zod6.z.string(),
  slug: import_zod6.z.string().nullable(),
  tier: import_zod6.z.string(),
  role: import_zod6.z.string(),
  created_at: import_zod6.z.string()
}).passthrough();
var PaginationMetadataSchema = import_zod6.z.object({
  has_more: import_zod6.z.boolean(),
  next_cursor: import_zod6.z.string().nullable(),
  total: import_zod6.z.number().nullable()
}).passthrough();
var ListWorkspacesSchema = import_zod6.z.object({
  data: import_zod6.z.array(WorkspaceResponseSchema),
  pagination: PaginationMetadataSchema
}).passthrough();
var { action: listWorkspaces, safeAction: safeListWorkspaces } = defineAction(ListWorkspacesSchema, async (client, request) => {
  const queryParams = new URLSearchParams();
  if (request?.cursor) queryParams.append("cursor", request.cursor);
  if (request?.limit) queryParams.append("limit", request.limit.toString());
  const url = queryParams.toString() ? `/workspaces?${queryParams.toString()}` : "/workspaces";
  return await client.get(url);
});

// src/actions/workspaces/get_workspace.ts
var { action: getWorkspace, safeAction: safeGetWorkspace } = defineAction(WorkspaceResponseSchema, async (client, teamSlug) => {
  return await client.get(`/workspaces/${teamSlug}`);
});

// src/types/cvm_info.ts
var import_zod7 = require("zod");
var VmInfoSchema = import_zod7.z.object({
  id: import_zod7.z.string(),
  name: import_zod7.z.string(),
  status: import_zod7.z.string(),
  uptime: import_zod7.z.string(),
  app_url: import_zod7.z.string().nullable(),
  app_id: import_zod7.z.string(),
  instance_id: import_zod7.z.string().nullable(),
  configuration: import_zod7.z.any().optional(),
  // TODO: add VmConfiguration schema if needed
  exited_at: import_zod7.z.string().nullable(),
  boot_progress: import_zod7.z.string().nullable(),
  boot_error: import_zod7.z.string().nullable(),
  shutdown_progress: import_zod7.z.string().nullable(),
  image_version: import_zod7.z.string().nullable()
});
var ManagedUserSchema = import_zod7.z.object({
  id: import_zod7.z.number(),
  username: import_zod7.z.string()
});
var CvmNodeSchema = import_zod7.z.object({
  id: import_zod7.z.number(),
  name: import_zod7.z.string(),
  region_identifier: import_zod7.z.string().nullable().optional()
});
var CvmNetworkUrlsSchema = import_zod7.z.object({
  app: import_zod7.z.string(),
  instance: import_zod7.z.string()
});
var CvmInfoSchema = import_zod7.z.object({
  hosted: VmInfoSchema,
  name: import_zod7.z.string(),
  managed_user: ManagedUserSchema.nullable(),
  node: CvmNodeSchema.nullable(),
  listed: import_zod7.z.boolean().default(false),
  status: import_zod7.z.string(),
  in_progress: import_zod7.z.boolean().default(false),
  dapp_dashboard_url: import_zod7.z.string().nullable(),
  syslog_endpoint: import_zod7.z.string().nullable(),
  allow_upgrade: import_zod7.z.boolean().default(false),
  project_id: import_zod7.z.string().nullable(),
  // HashedId is represented as string in JS
  project_type: import_zod7.z.string().nullable(),
  billing_period: import_zod7.z.string().nullable(),
  kms_info: KmsInfoSchema.nullable(),
  vcpu: import_zod7.z.number().nullable(),
  memory: import_zod7.z.number().nullable(),
  disk_size: import_zod7.z.number().nullable(),
  gateway_domain: import_zod7.z.string().nullable(),
  public_urls: import_zod7.z.array(CvmNetworkUrlsSchema)
});
var CvmLegacyDetailSchema = import_zod7.z.object({
  id: import_zod7.z.number(),
  name: import_zod7.z.string(),
  status: import_zod7.z.string(),
  in_progress: import_zod7.z.boolean().optional().default(false),
  teepod_id: import_zod7.z.number().nullable(),
  teepod: CvmNodeSchema.optional().nullable(),
  app_id: import_zod7.z.string(),
  vm_uuid: import_zod7.z.string().nullable(),
  instance_id: import_zod7.z.string().nullable(),
  vcpu: import_zod7.z.number(),
  memory: import_zod7.z.number(),
  disk_size: import_zod7.z.number(),
  base_image: import_zod7.z.string().nullable(),
  encrypted_env_pubkey: import_zod7.z.string().nullable(),
  listed: import_zod7.z.boolean().optional().default(false),
  project_id: import_zod7.z.string().optional().nullable(),
  project_type: import_zod7.z.string().optional().nullable(),
  public_sysinfo: import_zod7.z.boolean().optional().default(false),
  public_logs: import_zod7.z.boolean().optional().default(false),
  dapp_dashboard_url: import_zod7.z.string().optional().nullable(),
  syslog_endpoint: import_zod7.z.string().optional().nullable(),
  kms_info: KmsInfoSchema.optional().nullable(),
  contract_address: import_zod7.z.string().optional().nullable(),
  deployer_address: import_zod7.z.string().optional().nullable(),
  scheduled_delete_at: import_zod7.z.string().optional().nullable(),
  public_urls: import_zod7.z.array(CvmNetworkUrlsSchema).optional().default([]),
  gateway_domain: import_zod7.z.string().optional().nullable()
});
var VMSchema = import_zod7.z.object({
  id: import_zod7.z.number(),
  name: import_zod7.z.string(),
  status: import_zod7.z.string(),
  teepod_id: import_zod7.z.number(),
  teepod: CvmNodeSchema.optional().nullable(),
  user_id: import_zod7.z.number().optional().nullable(),
  app_id: import_zod7.z.string(),
  vm_uuid: import_zod7.z.string().nullable(),
  instance_id: import_zod7.z.string().nullable(),
  app_url: import_zod7.z.string().optional().nullable(),
  base_image: import_zod7.z.string().nullable(),
  vcpu: import_zod7.z.number(),
  memory: import_zod7.z.number(),
  disk_size: import_zod7.z.number(),
  manifest_version: import_zod7.z.number().optional().nullable(),
  version: import_zod7.z.string().optional().nullable(),
  runner: import_zod7.z.string().optional().nullable(),
  docker_compose_file: import_zod7.z.string().optional().nullable(),
  features: import_zod7.z.array(import_zod7.z.string()).optional().nullable(),
  created_at: import_zod7.z.string(),
  // datetime serialized as ISO string
  encrypted_env_pubkey: import_zod7.z.string().nullable()
});

// src/types/cvm_id.ts
var import_zod8 = require("zod");
var CvmIdObjectSchema = import_zod8.z.object({
  /** Direct CVM ID (any format) */
  id: import_zod8.z.string().optional(),
  /** UUID format (with or without dashes) */
  uuid: import_zod8.z.string().regex(
    /^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i,
    "Invalid UUID format"
  ).optional(),
  /** App ID (40 characters, optionally prefixed with 'app_id_') */
  app_id: import_zod8.z.string().optional(),
  /** Instance ID (40 characters, optionally prefixed with 'instance_') */
  instance_id: import_zod8.z.string().optional()
});
var refineCvmId = (schema) => schema.refine(
  (data) => {
    const obj = data;
    return !!(obj.id || obj.uuid || obj.app_id || obj.instance_id);
  },
  {
    message: "One of id, uuid, app_id, or instance_id must be provided"
  }
);
var CvmIdBaseSchema = refineCvmId(CvmIdObjectSchema);
var CvmIdSchema = CvmIdBaseSchema.transform((data) => {
  let rawValue;
  if (data.id) {
    rawValue = data.id;
  } else if (data.uuid) {
    rawValue = data.uuid;
  } else if (data.app_id) {
    rawValue = data.app_id;
  } else if (data.instance_id) {
    rawValue = data.instance_id;
  } else {
    throw new Error("No valid identifier provided");
  }
  const uuidRegex = /^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i;
  const appIdRegex = /^[0-9a-f]{40}$/i;
  let cvmId;
  if (uuidRegex.test(rawValue)) {
    cvmId = rawValue.replace(/-/g, "");
  } else if (appIdRegex.test(rawValue)) {
    cvmId = `app_${rawValue}`;
  } else {
    cvmId = rawValue;
  }
  return { cvmId };
});

// src/actions/cvms/get_cvm_info.ts
var GetCvmInfoRequestSchema = CvmIdSchema;
var { action: getCvmInfo, safeAction: safeGetCvmInfo } = defineAction(CvmLegacyDetailSchema, async (client, request) => {
  const { cvmId } = GetCvmInfoRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}`);
});

// src/actions/cvms/get_cvm_list.ts
var import_zod9 = require("zod");
var GetCvmListRequestSchema = import_zod9.z.object({
  page: import_zod9.z.number().int().min(1).optional(),
  page_size: import_zod9.z.number().int().min(1).optional(),
  node_id: import_zod9.z.number().int().min(1).optional(),
  teepod_id: import_zod9.z.number().int().min(1).optional(),
  user_id: import_zod9.z.string().optional()
}).strict();
var GetCvmListSchema = import_zod9.z.object({
  items: import_zod9.z.array(CvmInfoSchema),
  total: import_zod9.z.number(),
  page: import_zod9.z.number(),
  page_size: import_zod9.z.number(),
  pages: import_zod9.z.number()
}).strict();
var { action: getCvmList, safeAction: safeGetCvmList } = defineAction(GetCvmListSchema, async (client, request) => {
  const validatedRequest = GetCvmListRequestSchema.parse(request ?? {});
  return await client.get("/cvms/paginated", { params: validatedRequest });
});

// src/actions/cvms/provision_cvm.ts
var import_zod10 = require("zod");
var ProvisionCvmSchema = import_zod10.z.object({
  app_id: import_zod10.z.string().nullable().optional(),
  app_env_encrypt_pubkey: import_zod10.z.string().nullable().optional(),
  compose_hash: import_zod10.z.string(),
  fmspc: import_zod10.z.string().nullable().optional(),
  device_id: import_zod10.z.string().nullable().optional(),
  os_image_hash: import_zod10.z.string().nullable().optional(),
  instance_type: import_zod10.z.string().nullable().optional(),
  teepod_id: import_zod10.z.number().nullable().optional(),
  // Will be transformed to node_id
  node_id: import_zod10.z.number().nullable().optional(),
  kms_id: import_zod10.z.string().nullable().optional()
}).passthrough().transform((data) => {
  if ("teepod_id" in data && data.teepod_id !== void 0) {
    const { teepod_id, ...rest } = data;
    return { ...rest, node_id: teepod_id };
  }
  return data;
});
var ProvisionCvmRequestSchema = import_zod10.z.object({
  node_id: import_zod10.z.number().optional(),
  // recommended - optional, system auto-selects if not specified
  teepod_id: import_zod10.z.number().optional(),
  // deprecated, for compatibility
  region: import_zod10.z.string().optional(),
  // optional - region filter for auto-selection
  name: import_zod10.z.string(),
  instance_type: import_zod10.z.string().default("tdx.small"),
  // defaults to "tdx.small"
  image: import_zod10.z.string().optional(),
  vcpu: import_zod10.z.number().optional(),
  memory: import_zod10.z.number().optional(),
  disk_size: import_zod10.z.number().optional(),
  compose_file: import_zod10.z.object({
    allowed_envs: import_zod10.z.array(import_zod10.z.string()).optional(),
    pre_launch_script: import_zod10.z.string().optional(),
    docker_compose_file: import_zod10.z.string().optional(),
    name: import_zod10.z.string().optional().default(""),
    // optional with default empty string
    kms_enabled: import_zod10.z.boolean().optional(),
    public_logs: import_zod10.z.boolean().optional(),
    public_sysinfo: import_zod10.z.boolean().optional(),
    gateway_enabled: import_zod10.z.boolean().optional(),
    // recommended
    tproxy_enabled: import_zod10.z.boolean().optional()
    // deprecated, for compatibility
  }),
  listed: import_zod10.z.boolean().optional(),
  kms_id: import_zod10.z.string().optional(),
  kms: import_zod10.z.enum(["PHALA", "ETHEREUM", "BASE"]).optional(),
  // KMS type selection (defaults to PHALA)
  kms_contract: import_zod10.z.string().optional(),
  // KMS contract address for on-chain KMS
  env_keys: import_zod10.z.array(import_zod10.z.string()).optional(),
  // Manual nonce specification (Advanced - PHALA KMS only)
  nonce: import_zod10.z.number().optional(),
  // User-specified nonce for deterministic app_id generation
  app_id: import_zod10.z.string().optional()
  // Expected app_id (must match calculated app_id from nonce)
}).passthrough();
function handleGatewayCompatibility(appCompose) {
  if (!appCompose.compose_file) {
    return appCompose;
  }
  const composeFile = { ...appCompose.compose_file };
  if (typeof composeFile.gateway_enabled === "boolean" && typeof composeFile.tproxy_enabled === "boolean") {
    delete composeFile.tproxy_enabled;
  } else if (typeof composeFile.tproxy_enabled === "boolean" && typeof composeFile.gateway_enabled === "undefined") {
    composeFile.gateway_enabled = composeFile.tproxy_enabled;
    delete composeFile.tproxy_enabled;
    if (typeof window !== "undefined" ? window.console : globalThis.console) {
      console.warn(
        "[phala/cloud] tproxy_enabled is deprecated, please use gateway_enabled instead. See docs for migration."
      );
    }
  }
  return {
    ...appCompose,
    compose_file: composeFile
  };
}
var { action: provisionCvm, safeAction: safeProvisionCvm } = defineAction(ProvisionCvmSchema, async (client, appCompose) => {
  const validated = ProvisionCvmRequestSchema.parse(appCompose);
  const body = handleGatewayCompatibility(validated);
  let requestBody = { ...body };
  if (typeof body.node_id === "number") {
    requestBody = { ...body, teepod_id: body.node_id };
    delete requestBody.node_id;
  } else if (typeof body.teepod_id === "number") {
    console.warn("[phala/cloud] teepod_id is deprecated, please use node_id instead.");
  }
  return await client.post("/cvms/provision", requestBody);
});

// src/actions/cvms/commit_cvm_provision.ts
var import_zod11 = require("zod");
var CommitCvmProvisionSchema = import_zod11.z.object({
  id: import_zod11.z.number(),
  name: import_zod11.z.string(),
  status: import_zod11.z.string(),
  teepod_id: import_zod11.z.number(),
  teepod: import_zod11.z.object({
    id: import_zod11.z.number(),
    name: import_zod11.z.string()
  }).nullable(),
  user_id: import_zod11.z.number().nullable(),
  app_id: import_zod11.z.string().nullable(),
  vm_uuid: import_zod11.z.string().nullable(),
  instance_id: import_zod11.z.string().nullable(),
  app_url: import_zod11.z.string().nullable(),
  base_image: import_zod11.z.string().nullable(),
  vcpu: import_zod11.z.number(),
  memory: import_zod11.z.number(),
  disk_size: import_zod11.z.number(),
  manifest_version: import_zod11.z.number().nullable(),
  version: import_zod11.z.string().nullable(),
  runner: import_zod11.z.string().nullable(),
  docker_compose_file: import_zod11.z.string().nullable(),
  features: import_zod11.z.array(import_zod11.z.string()).nullable(),
  created_at: import_zod11.z.string(),
  encrypted_env_pubkey: import_zod11.z.string().nullable().optional(),
  app_auth_contract_address: import_zod11.z.string().nullable().optional(),
  deployer_address: import_zod11.z.string().nullable().optional()
}).passthrough();
var CommitCvmProvisionRequestSchema = import_zod11.z.object({
  encrypted_env: import_zod11.z.string().optional().nullable(),
  app_id: import_zod11.z.string(),
  compose_hash: import_zod11.z.string(),
  kms_id: import_zod11.z.string().optional(),
  contract_address: import_zod11.z.string().optional(),
  deployer_address: import_zod11.z.string().optional(),
  env_keys: import_zod11.z.array(import_zod11.z.string()).optional().nullable()
}).passthrough();
var { action: commitCvmProvision, safeAction: safeCommitCvmProvision } = defineAction(CommitCvmProvisionSchema, async (client, payload) => {
  return await client.post("/cvms", payload);
});

// src/types/app_compose.ts
var import_zod12 = require("zod");
var LooseAppComposeSchema = import_zod12.z.object({
  allowed_envs: import_zod12.z.array(import_zod12.z.string()).optional(),
  docker_compose_file: import_zod12.z.string(),
  features: import_zod12.z.array(import_zod12.z.string()).optional(),
  name: import_zod12.z.string().optional(),
  manifest_version: import_zod12.z.number().optional(),
  kms_enabled: import_zod12.z.boolean().optional(),
  public_logs: import_zod12.z.boolean().optional(),
  public_sysinfo: import_zod12.z.boolean().optional(),
  tproxy_enabled: import_zod12.z.boolean().optional(),
  pre_launch_script: import_zod12.z.string().optional(),
  env_pubkey: import_zod12.z.string().optional(),
  salt: import_zod12.z.string().optional().nullable()
}).passthrough();

// src/utils/get_compose_hash.ts
var import_crypto = __toESM(require("crypto"));
function sortObject(obj) {
  if (obj === void 0 || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(sortObject);
  } else if (obj && typeof obj === "object" && obj.constructor === Object) {
    return Object.keys(obj).sort().reduce((result, key) => {
      const value = obj[key];
      result[key] = sortObject(value);
      return result;
    }, {});
  }
  return obj;
}
function preprocessAppCompose(dic) {
  const obj = { ...dic };
  if (obj.runner === "bash" && "docker_compose_file" in obj) {
    delete obj.docker_compose_file;
  } else if (obj.runner === "docker-compose" && "bash_script" in obj) {
    delete obj.bash_script;
  }
  if ("pre_launch_script" in obj && !obj.pre_launch_script) {
    delete obj.pre_launch_script;
  }
  return obj;
}
function dumpAppCompose(dic) {
  const ordered = sortObject(dic);
  let json = JSON.stringify(ordered, null, 4);
  json = json.replace(/": /g, '":');
  return json;
}
function getComposeHash(app_compose) {
  const preprocessed = preprocessAppCompose(app_compose);
  const manifest_str = dumpAppCompose(preprocessed);
  return import_crypto.default.createHash("sha256").update(manifest_str, "utf8").digest("hex");
}
function withComposeMethods(compose) {
  const appCompose = compose;
  return {
    ...compose,
    getHash: () => getComposeHash(appCompose),
    toString: () => dumpAppCompose(preprocessAppCompose(appCompose))
  };
}

// src/actions/cvms/get_cvm_compose_file.ts
var GetCvmComposeFileResultSchema = LooseAppComposeSchema.transform(
  (data) => withComposeMethods(data)
);
var GetCvmComposeFileRequestSchema = CvmIdSchema;
var { action: getCvmComposeFile, safeAction: safeGetCvmComposeFile } = defineAction(GetCvmComposeFileResultSchema, async (client, request) => {
  const { cvmId } = GetCvmComposeFileRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/compose_file`);
});

// src/actions/cvms/provision_cvm_compose_file_update.ts
var import_zod13 = require("zod");
var ProvisionCvmComposeFileUpdateRequestSchema = import_zod13.z.object({
  id: import_zod13.z.string().optional(),
  uuid: import_zod13.z.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: import_zod13.z.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: import_zod13.z.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  app_compose: LooseAppComposeSchema,
  update_env_vars: import_zod13.z.boolean().optional().nullable()
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => {
  return {
    cvmId: data.id || data.uuid || data.app_id || data.instance_id,
    request: { ...data.app_compose, update_env_vars: data.update_env_vars },
    _raw: data
  };
});
var ProvisionCvmComposeFileUpdateResultSchema = import_zod13.z.object({
  app_id: import_zod13.z.string().nullable(),
  device_id: import_zod13.z.string().nullable(),
  compose_hash: import_zod13.z.string(),
  kms_info: KmsInfoSchema.nullable().optional()
}).passthrough();
var { action: provisionCvmComposeFileUpdate, safeAction: safeProvisionCvmComposeFileUpdate } = defineAction(ProvisionCvmComposeFileUpdateResultSchema, async (client, request) => {
  const validatedRequest = ProvisionCvmComposeFileUpdateRequestSchema.parse(request);
  return await client.post(
    `/cvms/${validatedRequest.cvmId}/compose_file/provision`,
    validatedRequest.request
  );
});

// src/actions/cvms/commit_cvm_compose_file_update.ts
var import_zod14 = require("zod");
var CommitCvmComposeFileUpdateRequestSchema = import_zod14.z.object({
  id: import_zod14.z.string().optional(),
  uuid: import_zod14.z.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: import_zod14.z.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: import_zod14.z.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  compose_hash: import_zod14.z.string().min(1, "Compose hash is required"),
  encrypted_env: import_zod14.z.string().optional(),
  env_keys: import_zod14.z.array(import_zod14.z.string()).optional(),
  update_env_vars: import_zod14.z.boolean().optional().nullable()
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => ({
  cvmId: data.id || data.uuid || data.app_id || data.instance_id,
  compose_hash: data.compose_hash,
  encrypted_env: data.encrypted_env,
  env_keys: data.env_keys,
  update_env_vars: !!data.update_env_vars,
  _raw: data
}));
var CommitCvmComposeFileUpdateSchema = import_zod14.z.any().transform(() => void 0);
var { action: commitCvmComposeFileUpdate, safeAction: safeCommitCvmComposeFileUpdate } = defineAction(
  CommitCvmComposeFileUpdateSchema,
  async (client, request) => {
    const validatedRequest = CommitCvmComposeFileUpdateRequestSchema.parse(request);
    return await client.patch(`/cvms/${validatedRequest.cvmId}/compose_file`, {
      compose_hash: validatedRequest.compose_hash,
      encrypted_env: validatedRequest.encrypted_env,
      env_keys: validatedRequest.env_keys
    });
  }
);

// src/actions/cvms/update_cvm_envs.ts
var import_zod15 = require("zod");
var UpdateCvmEnvsRequestSchema = import_zod15.z.object({
  id: import_zod15.z.string().optional(),
  uuid: import_zod15.z.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: import_zod15.z.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: import_zod15.z.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  encrypted_env: import_zod15.z.string().describe("Encrypted environment variables (hex string)"),
  env_keys: import_zod15.z.array(import_zod15.z.string()).optional().describe("List of allowed environment variable keys"),
  compose_hash: import_zod15.z.string().optional().describe("Compose hash for verification (Phase 2, required when env_keys changes)"),
  transaction_hash: import_zod15.z.string().optional().describe(
    "On-chain transaction hash for verification (Phase 2, required when env_keys changes)"
  )
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => {
  return {
    cvmId: data.id || data.uuid || data.app_id || data.instance_id,
    request: {
      encrypted_env: data.encrypted_env,
      env_keys: data.env_keys,
      compose_hash: data.compose_hash,
      transaction_hash: data.transaction_hash
    },
    _raw: data
  };
});
var UpdateCvmEnvsInProgressSchema = import_zod15.z.object({
  status: import_zod15.z.literal("in_progress"),
  message: import_zod15.z.string(),
  correlation_id: import_zod15.z.string(),
  allowed_envs_changed: import_zod15.z.boolean()
});
var UpdateCvmEnvsPreconditionRequiredSchema = import_zod15.z.object({
  status: import_zod15.z.literal("precondition_required"),
  message: import_zod15.z.string(),
  compose_hash: import_zod15.z.string(),
  app_id: import_zod15.z.string(),
  device_id: import_zod15.z.string(),
  kms_info: KmsInfoSchema
});
var UpdateCvmEnvsResultSchema = import_zod15.z.union([
  UpdateCvmEnvsInProgressSchema,
  UpdateCvmEnvsPreconditionRequiredSchema
]);
var { action: updateCvmEnvs, safeAction: safeUpdateCvmEnvs } = defineAction(UpdateCvmEnvsResultSchema, async (client, request) => {
  const validatedRequest = UpdateCvmEnvsRequestSchema.parse(request);
  try {
    const response = await client.patch(
      `/cvms/${validatedRequest.cvmId}/envs`,
      validatedRequest.request
    );
    return response;
  } catch (error) {
    if (error instanceof PhalaCloudError && error.status === 428) {
      const detail = error.detail;
      if (detail && typeof detail === "object") {
        const detailObj = detail;
        return {
          status: "precondition_required",
          message: detailObj.message || "Compose hash verification required",
          compose_hash: detailObj.compose_hash,
          app_id: detailObj.app_id,
          device_id: detailObj.device_id,
          kms_info: detailObj.kms_info
        };
      }
    }
    throw error;
  }
});

// src/actions/kms/get_kms_info.ts
var import_zod16 = require("zod");
var GetKmsInfoRequestSchema = import_zod16.z.object({
  kms_id: import_zod16.z.string().min(1, "KMS ID is required")
});
var { action: getKmsInfo, safeAction: safeGetKmsInfo } = defineAction(KmsInfoSchema, async (client, request) => {
  const validatedRequest = GetKmsInfoRequestSchema.parse(request);
  return await client.get(`/kms/${validatedRequest.kms_id}`);
});

// src/actions/kms/get_kms_list.ts
var import_zod17 = require("zod");
var GetKmsListRequestSchema = import_zod17.z.object({
  page: import_zod17.z.number().int().min(1).optional(),
  page_size: import_zod17.z.number().int().min(1).optional(),
  is_onchain: import_zod17.z.boolean().optional()
}).strict();
var GetKmsListSchema = import_zod17.z.object({
  items: import_zod17.z.array(KmsInfoSchema),
  total: import_zod17.z.number(),
  page: import_zod17.z.number(),
  page_size: import_zod17.z.number(),
  pages: import_zod17.z.number()
}).strict();
var { action: getKmsList, safeAction: safeGetKmsList } = defineAction(GetKmsListSchema, async (client, request) => {
  const validatedRequest = GetKmsListRequestSchema.parse(request ?? {});
  return await client.get("/kms", { params: validatedRequest });
});

// src/actions/kms/get_app_env_encrypt_pubkey.ts
var import_zod18 = require("zod");
var GetAppEnvEncryptPubKeyRequestSchema = import_zod18.z.object({
  kms: import_zod18.z.string().min(1, "KMS ID or slug is required"),
  app_id: import_zod18.z.string().refine(
    (val) => val.length === 40 || val.startsWith("0x") && val.length === 42,
    "App ID must be exactly 40 characters or 42 characters with 0x prefix"
  )
}).strict();
var GetAppEnvEncryptPubKeySchema = import_zod18.z.object({
  public_key: import_zod18.z.string(),
  signature: import_zod18.z.string()
}).strict();
var { action: getAppEnvEncryptPubKey, safeAction: safeGetAppEnvEncryptPubKey } = defineAction(GetAppEnvEncryptPubKeySchema, async (client, payload) => {
  const validatedRequest = GetAppEnvEncryptPubKeyRequestSchema.parse(payload);
  return await client.get(`/kms/${validatedRequest.kms}/pubkey/${validatedRequest.app_id}`);
});

// src/actions/kms/next_app_ids.ts
var import_zod19 = require("zod");
var NextAppIdsRequestSchema = import_zod19.z.object({
  counts: import_zod19.z.number().int().min(1).max(20).optional().default(1)
}).strict();
var NextAppIdsSchema = import_zod19.z.object({
  app_ids: import_zod19.z.array(
    import_zod19.z.object({
      app_id: import_zod19.z.string(),
      nonce: import_zod19.z.number().int().min(0)
    })
  )
}).strict();
var { action: nextAppIds, safeAction: safeNextAppIds } = defineAction(NextAppIdsSchema, async (client, payload) => {
  const validatedRequest = NextAppIdsRequestSchema.parse(payload ?? {});
  const params = new URLSearchParams();
  params.append("counts", validatedRequest.counts.toString());
  return await client.get(`/kms/phala/next_app_id?${params.toString()}`);
});

// src/actions/cvms/start_cvm.ts
var StartCvmRequestSchema = CvmIdSchema;
var { action: startCvm, safeAction: safeStartCvm } = defineAction(VMSchema, async (client, request) => {
  const { cvmId } = StartCvmRequestSchema.parse(request);
  return await client.post(`/cvms/${cvmId}/start`);
});

// src/actions/cvms/stop_cvm.ts
var StopCvmRequestSchema = CvmIdSchema;
var { action: stopCvm, safeAction: safeStopCvm } = defineAction(
  VMSchema,
  async (client, request) => {
    const { cvmId } = StopCvmRequestSchema.parse(request);
    return await client.post(`/cvms/${cvmId}/stop`);
  }
);

// src/actions/cvms/shutdown_cvm.ts
var ShutdownCvmRequestSchema = CvmIdSchema;
var { action: shutdownCvm, safeAction: safeShutdownCvm } = defineAction(VMSchema, async (client, request) => {
  const { cvmId } = ShutdownCvmRequestSchema.parse(request);
  return await client.post(`/cvms/${cvmId}/shutdown`);
});

// src/actions/cvms/restart_cvm.ts
var import_zod20 = require("zod");
var RestartCvmRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    force: import_zod20.z.boolean().optional()
  })
);
var { action: restartCvm, safeAction: safeRestartCvm } = defineAction(VMSchema, async (client, request) => {
  const parsed = RestartCvmRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { force = false } = parsed;
  return await client.post(`/cvms/${cvmId}/restart`, { force });
});

// src/actions/cvms/delete_cvm.ts
var import_zod21 = require("zod");
var DeleteCvmRequestSchema = CvmIdSchema;
var { action: deleteCvm, safeAction: safeDeleteCvm } = defineAction(
  import_zod21.z.void(),
  async (client, request) => {
    const { cvmId } = DeleteCvmRequestSchema.parse(request);
    await client.delete(`/cvms/${cvmId}`);
    return void 0;
  }
);

// src/actions/cvms/get_cvm_stats.ts
var import_zod22 = require("zod");
var DiskInfoSchema = import_zod22.z.object({
  name: import_zod22.z.string(),
  mount_point: import_zod22.z.string(),
  total_size: import_zod22.z.number(),
  free_size: import_zod22.z.number()
});
var SystemInfoSchema = import_zod22.z.object({
  os_name: import_zod22.z.string(),
  os_version: import_zod22.z.string(),
  kernel_version: import_zod22.z.string(),
  cpu_model: import_zod22.z.string(),
  num_cpus: import_zod22.z.number(),
  total_memory: import_zod22.z.number(),
  available_memory: import_zod22.z.number(),
  used_memory: import_zod22.z.number(),
  free_memory: import_zod22.z.number(),
  total_swap: import_zod22.z.number(),
  used_swap: import_zod22.z.number(),
  free_swap: import_zod22.z.number(),
  uptime: import_zod22.z.number(),
  loadavg_one: import_zod22.z.number(),
  loadavg_five: import_zod22.z.number(),
  loadavg_fifteen: import_zod22.z.number(),
  disks: import_zod22.z.array(DiskInfoSchema)
});
var CvmSystemInfoSchema = import_zod22.z.object({
  is_online: import_zod22.z.boolean(),
  is_public: import_zod22.z.boolean().default(false),
  error: import_zod22.z.string().nullable(),
  sysinfo: SystemInfoSchema.nullable(),
  status: import_zod22.z.string().nullable(),
  in_progress: import_zod22.z.boolean().default(false),
  boot_progress: import_zod22.z.string().nullable(),
  boot_error: import_zod22.z.string().nullable()
});
var GetCvmStatsRequestSchema = CvmIdSchema;
var { action: getCvmStats, safeAction: safeGetCvmStats } = defineAction(CvmSystemInfoSchema, async (client, request) => {
  const { cvmId } = GetCvmStatsRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/stats`);
});

// src/actions/cvms/get_cvm_network.ts
var import_zod23 = require("zod");
var CvmNetworkUrlsSchema2 = import_zod23.z.object({
  app: import_zod23.z.string(),
  instance: import_zod23.z.string()
});
var CvmNetworkSchema = import_zod23.z.object({
  is_online: import_zod23.z.boolean(),
  is_public: import_zod23.z.boolean().default(true),
  error: import_zod23.z.string().nullable(),
  internal_ip: import_zod23.z.string().nullable(),
  latest_handshake: import_zod23.z.string().nullable(),
  public_urls: import_zod23.z.array(CvmNetworkUrlsSchema2).nullable()
});
var GetCvmNetworkRequestSchema = CvmIdSchema;
var { action: getCvmNetwork, safeAction: safeGetCvmNetwork } = defineAction(CvmNetworkSchema, async (client, request) => {
  const { cvmId } = GetCvmNetworkRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/network`);
});

// src/actions/cvms/get_cvm_docker_compose.ts
var import_zod24 = require("zod");
var GetCvmDockerComposeRequestSchema = CvmIdSchema;
var { action: getCvmDockerCompose, safeAction: safeGetCvmDockerCompose } = defineAction(import_zod24.z.string(), async (client, request) => {
  const { cvmId } = GetCvmDockerComposeRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/docker-compose.yml`);
});

// src/actions/cvms/get_cvm_containers_stats.ts
var import_zod25 = require("zod");
var ContainerInfoSchema = import_zod25.z.object({
  id: import_zod25.z.string(),
  names: import_zod25.z.array(import_zod25.z.string()),
  image: import_zod25.z.string(),
  image_id: import_zod25.z.string(),
  command: import_zod25.z.string().nullable().optional(),
  created: import_zod25.z.number(),
  state: import_zod25.z.string(),
  status: import_zod25.z.string(),
  log_endpoint: import_zod25.z.string().nullable()
});
var CvmContainersStatsSchema = import_zod25.z.object({
  is_online: import_zod25.z.boolean(),
  is_public: import_zod25.z.boolean().default(true),
  error: import_zod25.z.string().nullable(),
  docker_compose_file: import_zod25.z.string().nullable(),
  manifest_version: import_zod25.z.number().nullable(),
  version: import_zod25.z.string().nullable(),
  runner: import_zod25.z.string().nullable(),
  features: import_zod25.z.array(import_zod25.z.string()).nullable(),
  containers: import_zod25.z.array(ContainerInfoSchema).nullable()
});
var GetCvmContainersStatsRequestSchema = CvmIdSchema;
var { action: getCvmContainersStats, safeAction: safeGetCvmContainersStats } = defineAction(CvmContainersStatsSchema, async (client, request) => {
  const { cvmId } = GetCvmContainersStatsRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/composition`);
});

// src/actions/cvms/get_cvm_attestation.ts
var import_zod26 = require("zod");
var CertificateSubjectSchema = import_zod26.z.object({
  common_name: import_zod26.z.string().nullable(),
  organization: import_zod26.z.string().nullable(),
  country: import_zod26.z.string().nullable(),
  state: import_zod26.z.string().nullable(),
  locality: import_zod26.z.string().nullable()
});
var CertificateIssuerSchema = import_zod26.z.object({
  common_name: import_zod26.z.string().nullable(),
  organization: import_zod26.z.string().nullable(),
  country: import_zod26.z.string().nullable()
});
var CertificateSchema = import_zod26.z.object({
  subject: CertificateSubjectSchema,
  issuer: CertificateIssuerSchema,
  serial_number: import_zod26.z.string(),
  not_before: import_zod26.z.string(),
  // datetime serialized as ISO string
  not_after: import_zod26.z.string(),
  // datetime serialized as ISO string
  version: import_zod26.z.string(),
  fingerprint: import_zod26.z.string(),
  signature_algorithm: import_zod26.z.string(),
  sans: import_zod26.z.array(import_zod26.z.string()).nullable(),
  is_ca: import_zod26.z.boolean(),
  position_in_chain: import_zod26.z.number().nullable(),
  quote: import_zod26.z.string().nullable(),
  app_id: import_zod26.z.string().nullable().optional(),
  cert_usage: import_zod26.z.string().nullable().optional()
});
var EventLogSchema = import_zod26.z.object({
  imr: import_zod26.z.number(),
  event_type: import_zod26.z.number(),
  digest: import_zod26.z.string(),
  event: import_zod26.z.string(),
  event_payload: import_zod26.z.string()
});
var TcbInfoSchema = import_zod26.z.object({
  mrtd: import_zod26.z.string(),
  rootfs_hash: import_zod26.z.string().nullable().optional(),
  rtmr0: import_zod26.z.string(),
  rtmr1: import_zod26.z.string(),
  rtmr2: import_zod26.z.string(),
  rtmr3: import_zod26.z.string(),
  event_log: import_zod26.z.array(EventLogSchema),
  app_compose: import_zod26.z.string()
});
var CvmAttestationSchema = import_zod26.z.object({
  name: import_zod26.z.string().nullable(),
  is_online: import_zod26.z.boolean(),
  is_public: import_zod26.z.boolean().default(true),
  error: import_zod26.z.string().nullable(),
  app_certificates: import_zod26.z.array(CertificateSchema).nullable(),
  tcb_info: TcbInfoSchema.nullable(),
  compose_file: import_zod26.z.string().nullable()
});
var GetCvmAttestationRequestSchema = CvmIdSchema;
var { action: getCvmAttestation, safeAction: safeGetCvmAttestation } = defineAction(CvmAttestationSchema, async (client, request) => {
  const { cvmId } = GetCvmAttestationRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/attestation`);
});

// src/actions/cvms/update_cvm_resources.ts
var import_zod27 = require("zod");
var UpdateCvmResourcesRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    vcpu: import_zod27.z.number().optional(),
    memory: import_zod27.z.number().optional(),
    disk_size: import_zod27.z.number().optional(),
    instance_type: import_zod27.z.string().optional(),
    allow_restart: import_zod27.z.boolean().optional()
  })
);
var { action: updateCvmResources, safeAction: safeUpdateCvmResources } = defineAction(import_zod27.z.void(), async (client, request) => {
  const parsed = UpdateCvmResourcesRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { ...body } = parsed;
  await client.patch(`/cvms/${cvmId}/resources`, body);
  return void 0;
});

// src/actions/cvms/update_cvm_visibility.ts
var import_zod28 = require("zod");
var UpdateCvmVisibilityRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    public_sysinfo: import_zod28.z.boolean(),
    public_logs: import_zod28.z.boolean()
  })
);
var { action: updateCvmVisibility, safeAction: safeUpdateCvmVisibility } = defineAction(CvmLegacyDetailSchema, async (client, request) => {
  const parsed = UpdateCvmVisibilityRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { public_sysinfo, public_logs } = parsed;
  return await client.patch(`/cvms/${cvmId}/visibility`, { public_sysinfo, public_logs });
});

// src/actions/cvms/get_available_os_images.ts
var import_zod29 = require("zod");
var OSImageVariantSchema = import_zod29.z.object({
  name: import_zod29.z.string(),
  os_image_hash: import_zod29.z.string().nullable(),
  is_current: import_zod29.z.boolean()
});
var AvailableOSImageSchema2 = import_zod29.z.object({
  version: import_zod29.z.union([
    import_zod29.z.tuple([import_zod29.z.number(), import_zod29.z.number(), import_zod29.z.number(), import_zod29.z.number()]),
    import_zod29.z.tuple([import_zod29.z.number(), import_zod29.z.number(), import_zod29.z.number()])
  ]),
  prod: OSImageVariantSchema.nullable(),
  dev: OSImageVariantSchema.nullable()
});
var GetAvailableOSImagesResponseSchema = import_zod29.z.array(AvailableOSImageSchema2);
var GetAvailableOSImagesRequestSchema = CvmIdSchema;
var { action: getAvailableOsImages, safeAction: safeGetAvailableOsImages } = defineAction(GetAvailableOSImagesResponseSchema, async (client, request) => {
  const { cvmId } = GetAvailableOSImagesRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/available-os-images`);
});

// src/actions/cvms/update_os_image.ts
var import_zod30 = require("zod");
var UpdateOsImageRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    os_image_name: import_zod30.z.string().min(1, "OS image name is required")
  })
);
var { action: updateOsImage, safeAction: safeUpdateOsImage } = defineAction(import_zod30.z.void(), async (client, request) => {
  const parsed = UpdateOsImageRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { os_image_name } = parsed;
  await client.patch(`/cvms/${cvmId}/os-image`, { os_image_name });
  return void 0;
});

// src/actions/cvms/get_cvm_state.ts
var import_zod31 = require("zod");
var CvmStateSchema = import_zod31.z.object({
  id: import_zod31.z.string().optional(),
  instance_id: import_zod31.z.string().optional(),
  name: import_zod31.z.string(),
  status: import_zod31.z.string(),
  uptime: import_zod31.z.string().optional(),
  exited_at: import_zod31.z.string().optional(),
  boot_progress: import_zod31.z.string().optional(),
  boot_error: import_zod31.z.string().optional(),
  shutdown_progress: import_zod31.z.string().optional()
});
var GetCvmStateRequestSchema = CvmIdSchema;
var { action: getCvmState, safeAction: safeGetCvmState } = defineAction(CvmStateSchema, async (client, request) => {
  const { cvmId } = GetCvmStateRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/state`);
});

// src/create-client.ts
function createClient2(config = {}) {
  const client = createClient(config);
  const allActions = {
    getCurrentUser,
    safeGetCurrentUser,
    getAvailableNodes,
    safeGetAvailableNodes,
    listAllInstanceTypeFamilies,
    safeListAllInstanceTypeFamilies,
    listFamilyInstanceTypes,
    safeListFamilyInstanceTypes,
    listWorkspaces,
    safeListWorkspaces,
    getWorkspace,
    safeGetWorkspace,
    getCvmInfo,
    safeGetCvmInfo,
    getCvmList,
    safeGetCvmList,
    provisionCvm,
    safeProvisionCvm,
    commitCvmProvision,
    safeCommitCvmProvision,
    getCvmComposeFile,
    safeGetCvmComposeFile,
    provisionCvmComposeFileUpdate,
    safeProvisionCvmComposeFileUpdate,
    commitCvmComposeFileUpdate,
    safeCommitCvmComposeFileUpdate,
    updateCvmEnvs,
    safeUpdateCvmEnvs,
    startCvm,
    safeStartCvm,
    stopCvm,
    safeStopCvm,
    shutdownCvm,
    safeShutdownCvm,
    restartCvm,
    safeRestartCvm,
    deleteCvm,
    safeDeleteCvm,
    getCvmStats,
    safeGetCvmStats,
    getCvmNetwork,
    safeGetCvmNetwork,
    getCvmDockerCompose,
    safeGetCvmDockerCompose,
    getCvmContainersStats,
    safeGetCvmContainersStats,
    getCvmAttestation,
    safeGetCvmAttestation,
    updateCvmResources,
    safeUpdateCvmResources,
    updateCvmVisibility,
    safeUpdateCvmVisibility,
    getAvailableOsImages,
    safeGetAvailableOsImages,
    updateOsImage,
    safeUpdateOsImage,
    getKmsInfo,
    safeGetKmsInfo,
    getKmsList,
    safeGetKmsList,
    getAppEnvEncryptPubKey,
    safeGetAppEnvEncryptPubKey,
    nextAppIds,
    safeNextAppIds,
    getCvmState,
    safeGetCvmState
  };
  return client.extend(allActions);
}

// src/actions/blockchains/deploy_app_auth.ts
var import_zod32 = require("zod");
var import_viem3 = require("viem");
var import_accounts2 = require("viem/accounts");

// src/utils/index.ts
var import_encrypt_env_vars = require("@phala/dstack-sdk/encrypt-env-vars");

// src/utils/as-hex.ts
var import_viem = require("viem");
function asHex(value) {
  if (typeof value === "string") {
    if (value.startsWith("0x") && (0, import_viem.isHex)(value)) {
      return value;
    } else if ((0, import_viem.isHex)(`0x${value}`)) {
      return `0x${value}`;
    }
  }
  throw new Error(`Invalid hex value: ${value}`);
}

// src/utils/network.ts
var NetworkError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "NetworkError";
  }
};
var WalletError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "WalletError";
  }
};
var TransactionError = class extends Error {
  constructor(message, hash, details) {
    super(message);
    this.hash = hash;
    this.details = details;
    this.name = "TransactionError";
  }
};
function createNetworkClients(publicClient, walletClient, address, chainId) {
  return {
    publicClient,
    walletClient,
    address,
    chainId
  };
}
async function checkNetworkStatus(clients, targetChainId) {
  try {
    const currentChainId = await clients.walletClient.getChainId();
    return {
      isCorrectNetwork: currentChainId === targetChainId,
      currentChainId
    };
  } catch (error) {
    throw new NetworkError(
      `Failed to check network status: ${error instanceof Error ? error.message : "Unknown error"}`,
      "NETWORK_CHECK_FAILED",
      error
    );
  }
}
async function checkBalance(publicClient, address, minBalance) {
  try {
    const balance = await publicClient.getBalance({ address });
    return {
      address,
      balance,
      sufficient: minBalance ? balance >= minBalance : true,
      required: minBalance
    };
  } catch (error) {
    throw new NetworkError(
      `Failed to check balance: ${error instanceof Error ? error.message : "Unknown error"}`,
      "BALANCE_CHECK_FAILED",
      error
    );
  }
}
async function waitForTransactionReceipt(publicClient, hash, options = {}) {
  const {
    timeout = 6e4,
    // 60 seconds default
    pollingInterval = 2e3,
    // 2 seconds default
    confirmations = 1
  } = options;
  const startTime = Date.now();
  return new Promise((resolve, reject) => {
    const poll = async () => {
      try {
        const receipt = await publicClient.getTransactionReceipt({ hash });
        if (receipt) {
          if (confirmations > 1) {
            const currentBlock = await publicClient.getBlockNumber();
            const confirmationCount = currentBlock - receipt.blockNumber + 1n;
            if (confirmationCount < BigInt(confirmations)) {
              const elapsed = Date.now() - startTime;
              if (elapsed >= timeout) {
                reject(
                  new TransactionError(`Transaction confirmation timeout after ${timeout}ms`, hash)
                );
                return;
              }
              setTimeout(poll, pollingInterval);
              return;
            }
          }
          resolve(receipt);
        } else {
          const elapsed = Date.now() - startTime;
          if (elapsed >= timeout) {
            reject(new TransactionError(`Transaction receipt timeout after ${timeout}ms`, hash));
            return;
          }
          setTimeout(poll, pollingInterval);
        }
      } catch (error) {
        const elapsed = Date.now() - startTime;
        if (elapsed >= timeout) {
          reject(
            new TransactionError(`Transaction receipt timeout after ${timeout}ms`, hash, error)
          );
          return;
        }
        setTimeout(poll, pollingInterval);
      }
    };
    poll();
  });
}
async function executeTransaction(clients, operation, args, options = {}) {
  const { timeout = 6e4, confirmations = 1, onSubmitted, onConfirmed, onError } = options;
  try {
    const hash = await operation(clients, ...args);
    onSubmitted?.(hash);
    const receipt = await waitForTransactionReceipt(clients.publicClient, hash, {
      timeout,
      confirmations
    });
    const success = receipt.status === "success";
    if (success) {
      onConfirmed?.(receipt);
    } else {
      const error = new TransactionError("Transaction failed on-chain", hash, receipt);
      onError?.(error, hash);
      throw error;
    }
    return {
      hash,
      receipt,
      success
    };
  } catch (error) {
    const txError = error instanceof TransactionError ? error : new TransactionError(
      `Transaction execution failed: ${error instanceof Error ? error.message : "Unknown error"}`,
      void 0,
      error
    );
    onError?.(txError, txError.hash);
    throw txError;
  }
}
async function extractNetworkClients(publicClient, walletClient) {
  try {
    const address = walletClient.account?.address;
    if (!address) {
      throw new WalletError("WalletClient must have an account", "NO_ACCOUNT");
    }
    const chainId = await walletClient.getChainId();
    return createNetworkClients(publicClient, walletClient, address, chainId);
  } catch (error) {
    throw new WalletError(
      `Failed to extract network clients: ${error instanceof Error ? error.message : "Unknown error"}`,
      "EXTRACTION_FAILED",
      error
    );
  }
}
async function validateNetworkPrerequisites(clients, requirements) {
  const { targetChainId, minBalance, requiredAddress } = requirements;
  const networkStatus = await checkNetworkStatus(clients, targetChainId);
  const balanceResult = await checkBalance(clients.publicClient, clients.address, minBalance);
  const addressValid = requiredAddress ? clients.address.toLowerCase() === requiredAddress.toLowerCase() : true;
  return {
    networkValid: networkStatus.isCorrectNetwork,
    balanceValid: balanceResult.sufficient,
    addressValid,
    details: {
      currentChainId: networkStatus.currentChainId,
      balance: balanceResult.balance,
      address: clients.address
    }
  };
}

// src/utils/transaction.ts
function createTransactionTracker() {
  let status = { state: "idle" };
  let timeoutHandle;
  let abortController;
  const updateStatus = (newStatus) => {
    status = { ...status, ...newStatus };
  };
  const reset = () => {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
      timeoutHandle = void 0;
    }
    if (abortController) {
      abortController.abort();
      abortController = void 0;
    }
    status = { state: "idle" };
  };
  const abort = () => {
    if (abortController) {
      abortController.abort();
    }
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
      timeoutHandle = void 0;
    }
    updateStatus({
      state: "error",
      aborted: true,
      error: "Transaction aborted by user"
    });
  };
  const execute = async (operation, clients, args, options = {}) => {
    const {
      timeout = 6e4,
      confirmations = 1,
      onSubmitted,
      onConfirmed,
      onError,
      signal
    } = options;
    try {
      reset();
      abortController = new AbortController();
      if (signal) {
        if (signal.aborted) {
          throw new TransactionError("Operation was aborted before execution");
        }
        signal.addEventListener("abort", () => {
          abort();
        });
      }
      updateStatus({
        state: "submitting",
        startTime: Date.now(),
        error: void 0,
        hash: void 0,
        receipt: void 0,
        aborted: false
      });
      if (abortController.signal.aborted) {
        throw new TransactionError("Transaction aborted");
      }
      const hash = await operation(clients, ...args);
      if (abortController.signal.aborted) {
        throw new TransactionError("Transaction aborted after submission", hash);
      }
      updateStatus({
        state: "pending",
        hash,
        submitTime: Date.now()
      });
      onSubmitted?.(hash);
      if (timeout > 0) {
        timeoutHandle = setTimeout(() => {
          if (status.state === "pending" && !abortController?.signal.aborted) {
            updateStatus({
              state: "timeout",
              error: `Transaction timeout after ${timeout}ms`
            });
          }
        }, timeout);
      }
      const receipt = await Promise.race([
        waitForTransactionReceipt(clients.publicClient, hash, { timeout, confirmations }),
        new Promise((_, reject) => {
          abortController?.signal.addEventListener("abort", () => {
            reject(new TransactionError("Transaction aborted while waiting for receipt", hash));
          });
        })
      ]);
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
        timeoutHandle = void 0;
      }
      const success = receipt.status === "success";
      updateStatus({
        state: success ? "success" : "error",
        receipt,
        confirmTime: Date.now(),
        error: success ? void 0 : "Transaction failed on-chain"
      });
      if (success) {
        onConfirmed?.(receipt);
      } else {
        const error = new TransactionError("Transaction failed on-chain", hash, receipt);
        onError?.(error, hash);
        throw error;
      }
      return {
        hash,
        receipt,
        success
      };
    } catch (error) {
      const txError = error instanceof TransactionError ? error : new TransactionError(
        `Transaction execution failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        status.hash,
        error
      );
      updateStatus({
        state: "error",
        error: txError.message
      });
      onError?.(txError, status.hash);
      throw txError;
    }
  };
  return {
    get status() {
      return { ...status };
    },
    get isIdle() {
      return status.state === "idle";
    },
    get isSubmitting() {
      return status.state === "submitting";
    },
    get isPending() {
      return status.state === "pending";
    },
    get isSuccess() {
      return status.state === "success";
    },
    get isError() {
      return status.state === "error";
    },
    get isTimeout() {
      return status.state === "timeout";
    },
    get isAborted() {
      return status.aborted === true;
    },
    get isComplete() {
      return ["success", "error", "timeout"].includes(status.state);
    },
    abort,
    reset,
    execute
  };
}
async function executeBatchTransactions(operations, clients, batchOptions) {
  const { mode, failFast = false, onProgress } = batchOptions;
  const results = [];
  if (mode === "sequential") {
    for (let i = 0; i < operations.length; i++) {
      const op = operations[i];
      if (!op) continue;
      const { operation, args, options } = op;
      try {
        const tracker = createTransactionTracker();
        const result = await tracker.execute(operation, clients, args, options);
        results.push(result);
        onProgress?.(i + 1, operations.length, results);
      } catch (error) {
        const txError = error instanceof Error ? error : new Error(String(error));
        results.push(txError);
        onProgress?.(i + 1, operations.length, results);
        if (failFast) {
          for (let j = i + 1; j < operations.length; j++) {
            results.push(new Error("Cancelled due to previous failure"));
          }
          break;
        }
      }
    }
  } else {
    const promises = operations.map(async ({ operation, args, options }) => {
      try {
        const tracker = createTransactionTracker();
        return await tracker.execute(operation, clients, args, options);
      } catch (error) {
        return error instanceof Error ? error : new Error(String(error));
      }
    });
    const allResults = await Promise.allSettled(promises);
    results.push(...allResults.map((r) => r.status === "fulfilled" ? r.value : r.reason));
    onProgress?.(operations.length, operations.length, results);
  }
  const successCount = results.filter((r) => !(r instanceof Error)).length;
  const errorCount = results.length - successCount;
  return {
    results,
    successCount,
    errorCount,
    allSuccessful: errorCount === 0
  };
}
async function executeTransactionWithRetry(operation, clients, args, options = {}, retryOptions = {}) {
  const {
    maxRetries = 3,
    initialDelay = 1e3,
    maxDelay = 1e4,
    backoffFactor = 2,
    retryCondition = () => true
  } = retryOptions;
  let lastError;
  let delay = initialDelay;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const tracker = createTransactionTracker();
      return await tracker.execute(operation, clients, args, options);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (attempt === maxRetries) {
        break;
      }
      if (!retryCondition(lastError)) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay = Math.min(delay * backoffFactor, maxDelay);
    }
  }
  throw lastError;
}
async function estimateTransactionGas(clients, transaction, options = {}) {
  const {
    gasLimitMultiplier = 1.2,
    maxFeePerGasMultiplier = 1.1,
    priorityFeeMultiplier = 1.1
  } = options;
  try {
    const estimatedGas = await clients.publicClient.estimateGas(transaction);
    const gasLimit = BigInt(Math.ceil(Number(estimatedGas) * gasLimitMultiplier));
    let maxFeePerGas;
    let maxPriorityFeePerGas;
    try {
      const feeData = await clients.publicClient.estimateFeesPerGas();
      if (feeData.maxFeePerGas) {
        maxFeePerGas = BigInt(Math.ceil(Number(feeData.maxFeePerGas) * maxFeePerGasMultiplier));
      }
      if (feeData.maxPriorityFeePerGas) {
        maxPriorityFeePerGas = BigInt(
          Math.ceil(Number(feeData.maxPriorityFeePerGas) * priorityFeeMultiplier)
        );
      }
    } catch (error) {
    }
    return {
      gasLimit,
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch (error) {
    throw new TransactionError(
      `Gas estimation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
      void 0,
      error
    );
  }
}

// src/utils/client-factories.ts
var import_viem2 = require("viem");
var import_accounts = require("viem/accounts");
function isBrowser() {
  return typeof window !== "undefined" && typeof window.ethereum !== "undefined";
}
function getEthereumProvider() {
  if (!isBrowser()) return null;
  const ethereum = window.ethereum;
  return ethereum || null;
}
function createClientsFromPrivateKey(chain, privateKey, rpcUrl) {
  try {
    const account = (0, import_accounts.privateKeyToAccount)(privateKey);
    const publicClient = (0, import_viem2.createPublicClient)({
      chain,
      transport: (0, import_viem2.http)(rpcUrl || chain.rpcUrls.default.http[0])
    });
    const walletClient = (0, import_viem2.createWalletClient)({
      account,
      chain,
      transport: (0, import_viem2.http)(rpcUrl || chain.rpcUrls.default.http[0])
    });
    return createNetworkClients(publicClient, walletClient, account.address, chain.id);
  } catch (error) {
    throw new WalletError(
      `Failed to create clients from private key: ${error instanceof Error ? error.message : "Unknown error"}`,
      "CLIENT_CREATION_FAILED",
      error
    );
  }
}
async function createClientsFromBrowser(chain, rpcUrl) {
  if (!isBrowser()) {
    throw new WalletError(
      "Browser wallet connection is only available in browser environment",
      "NOT_BROWSER_ENVIRONMENT"
    );
  }
  const provider = getEthereumProvider();
  if (!provider) {
    throw new WalletError(
      "No Ethereum provider found. Please install a wallet like MetaMask.",
      "NO_PROVIDER"
    );
  }
  try {
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    if (!accounts || accounts.length === 0) {
      throw new WalletError("No accounts available", "NO_ACCOUNTS");
    }
    const address = accounts[0];
    const chainId = await provider.request({ method: "eth_chainId" });
    const currentChainId = parseInt(chainId, 16);
    if (currentChainId !== chain.id) {
      await switchToNetwork(provider, chain.id);
    }
    const publicClient = (0, import_viem2.createPublicClient)({
      chain,
      transport: (0, import_viem2.http)(rpcUrl || chain.rpcUrls.default.http[0])
    });
    const walletClient = (0, import_viem2.createWalletClient)({
      account: address,
      chain,
      transport: (0, import_viem2.custom)(provider)
    });
    return createNetworkClients(publicClient, walletClient, address, chain.id);
  } catch (error) {
    if (error instanceof WalletError || error instanceof NetworkError) {
      throw error;
    }
    throw new WalletError(
      `Failed to connect browser wallet: ${error instanceof Error ? error.message : "Unknown error"}`,
      "BROWSER_CONNECTION_FAILED",
      error
    );
  }
}
async function switchToNetwork(provider, chainId) {
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: `0x${chainId.toString(16)}` }]
    });
  } catch (error) {
    const errorObj = error;
    if (errorObj.code === 4902) {
      throw new NetworkError(
        `Network ${chainId} not found in wallet. Please add it manually.`,
        "NETWORK_NOT_FOUND",
        error
      );
    }
    throw new NetworkError(
      `Failed to switch network: ${errorObj.message || "Unknown error"}`,
      "NETWORK_SWITCH_FAILED",
      error
    );
  }
}
async function addNetwork(provider, config) {
  try {
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: `0x${config.chainId.toString(16)}`,
          chainName: config.name,
          rpcUrls: [config.rpcUrl],
          blockExplorerUrls: config.blockExplorer ? [config.blockExplorer] : void 0,
          nativeCurrency: {
            name: "ETH",
            symbol: "ETH",
            decimals: 18
          }
        }
      ]
    });
  } catch (error) {
    const errorObj = error;
    throw new NetworkError(
      `Failed to add network: ${errorObj.message || "Unknown error"}`,
      "NETWORK_ADD_FAILED",
      error
    );
  }
}
async function autoCreateClients(chain, options = {}) {
  const { privateKey, rpcUrl, preferBrowser = false } = options;
  if (privateKey) {
    return createClientsFromPrivateKey(chain, privateKey, rpcUrl);
  }
  if (isBrowser() && (preferBrowser || !privateKey)) {
    return createClientsFromBrowser(chain, rpcUrl);
  }
  throw new WalletError(
    "No wallet connection method available. Provide a private key for server-side usage or use in browser environment.",
    "NO_CONNECTION_METHOD"
  );
}

// src/actions/blockchains/deploy_app_auth.ts
var kmsAuthAbi = [
  {
    inputs: [
      { name: "deployer", type: "address" },
      { name: "disableUpgrades", type: "bool" },
      { name: "allowAnyDevice", type: "bool" },
      { name: "deviceId", type: "bytes32" },
      { name: "composeHash", type: "bytes32" }
    ],
    name: "deployAndRegisterApp",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "appId", type: "address", indexed: true },
      { name: "deployer", type: "address", indexed: true }
    ],
    name: "AppDeployedViaFactory",
    type: "event",
    anonymous: false
  },
  {
    inputs: [{ name: "appId", type: "address", indexed: false }],
    name: "AppRegistered",
    type: "event",
    anonymous: false
  }
];
var DeployAppAuthRequestBaseSchema = import_zod32.z.object({
  // Chain configuration (conditionally required)
  chain: import_zod32.z.unknown().optional(),
  rpcUrl: import_zod32.z.string().optional(),
  // Contract configuration (required)
  kmsContractAddress: import_zod32.z.string(),
  // Authentication mode: either privateKey OR walletClient (required, mutually exclusive)
  privateKey: import_zod32.z.string().optional(),
  walletClient: import_zod32.z.unknown().optional(),
  // Public client (optional, will create default if not provided)
  publicClient: import_zod32.z.unknown().optional(),
  // App configuration (optional)
  allowAnyDevice: import_zod32.z.boolean().optional().default(false),
  deviceId: import_zod32.z.string().optional().default("0000000000000000000000000000000000000000000000000000000000000000"),
  composeHash: import_zod32.z.string().optional().default("0000000000000000000000000000000000000000000000000000000000000000"),
  disableUpgrades: import_zod32.z.boolean().optional().default(false),
  // Validation configuration (optional)
  skipPrerequisiteChecks: import_zod32.z.boolean().optional().default(false),
  minBalance: import_zod32.z.string().optional()
  // ETH amount as string, e.g., "0.01"
}).passthrough();
var DeployAppAuthRequestSchema = DeployAppAuthRequestBaseSchema.refine(
  (data) => {
    const hasPrivateKey = !!data.privateKey;
    const hasWalletClient = !!data.walletClient;
    return hasPrivateKey !== hasWalletClient;
  },
  {
    message: "Either 'privateKey' or 'walletClient' must be provided, but not both",
    path: ["privateKey", "walletClient"]
  }
).refine(
  (data) => {
    const hasPublicClient = !!data.publicClient;
    const hasWalletClient = !!data.walletClient;
    const hasChain = !!data.chain;
    if (hasPublicClient && hasWalletClient) {
      return true;
    }
    return hasChain;
  },
  {
    message: "Chain is required when publicClient or walletClient is not provided",
    path: ["chain"]
  }
);
var DeployAppAuthSchema = import_zod32.z.object({
  appId: import_zod32.z.string(),
  appAuthAddress: import_zod32.z.string(),
  deployer: import_zod32.z.string(),
  transactionHash: import_zod32.z.string(),
  blockNumber: import_zod32.z.bigint().optional(),
  gasUsed: import_zod32.z.bigint().optional()
}).passthrough();
function parseDeploymentResult(receipt, deployer, kmsContractAddress) {
  try {
    const logs = (0, import_viem3.parseEventLogs)({
      abi: kmsAuthAbi,
      eventName: "AppDeployedViaFactory",
      logs: receipt.logs,
      strict: false
    });
    if (logs.length === 0) {
      if (receipt.status === "reverted") {
        throw new Error(`Transaction failed: ${receipt.transactionHash}`);
      }
      throw new Error(
        `Transaction ${receipt.transactionHash} has no AppDeployedViaFactory events. The deployment failed. Status: ${receipt.status}. Found ${receipt.logs.length} logs.`
      );
    }
    const deploymentEvent = logs[0];
    if (!deploymentEvent?.args) {
      throw new Error("Event has no data");
    }
    const { appId, deployer: eventDeployer } = deploymentEvent.args;
    if (!appId) {
      throw new Error("Event missing appId");
    }
    return {
      appId,
      appAuthAddress: appId,
      deployer,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    throw new Error(`Parse failed: ${error}`);
  }
}
async function deployAppAuth(request, parameters) {
  const validatedRequest = DeployAppAuthRequestSchema.parse(request);
  const {
    chain,
    rpcUrl,
    kmsContractAddress,
    privateKey,
    walletClient: providedWalletClient,
    publicClient: providedPublicClient,
    allowAnyDevice: rawAllowAnyDevice = false,
    deviceId = "0000000000000000000000000000000000000000000000000000000000000000",
    composeHash = "0000000000000000000000000000000000000000000000000000000000000000",
    disableUpgrades = false,
    skipPrerequisiteChecks = false,
    minBalance,
    timeout = 12e4,
    // 2 minutes default
    retryOptions,
    signal,
    onTransactionStateChange,
    onTransactionSubmitted,
    onTransactionConfirmed
  } = validatedRequest;
  const defaultDeviceId = "0000000000000000000000000000000000000000000000000000000000000000";
  const hasSpecificDevice = deviceId !== defaultDeviceId && deviceId !== "0x" + defaultDeviceId;
  const allowAnyDevice = hasSpecificDevice ? false : rawAllowAnyDevice;
  let publicClient;
  let walletClient;
  let deployerAddress;
  let chainId;
  if (privateKey) {
    const account = (0, import_accounts2.privateKeyToAccount)(privateKey);
    if (providedPublicClient) {
      if (typeof providedPublicClient !== "object" || !providedPublicClient) {
        throw new Error("publicClient is invalid");
      }
      publicClient = providedPublicClient;
    } else {
      if (!chain) {
        throw new Error("Chain required for publicClient");
      }
      publicClient = (0, import_viem3.createPublicClient)({
        chain,
        transport: (0, import_viem3.http)(rpcUrl)
      });
    }
    if (!chain) {
      throw new Error("Chain required for walletClient");
    }
    walletClient = (0, import_viem3.createWalletClient)({
      account,
      chain,
      transport: (0, import_viem3.http)(rpcUrl)
    });
    deployerAddress = account.address;
    chainId = chain.id;
  } else if (providedWalletClient) {
    if (typeof providedWalletClient !== "object" || !providedWalletClient) {
      throw new Error("walletClient is invalid");
    }
    walletClient = providedWalletClient;
    if (providedPublicClient) {
      if (typeof providedPublicClient !== "object" || !providedPublicClient) {
        throw new Error("publicClient is invalid");
      }
      publicClient = providedPublicClient;
    } else {
      if (!chain) {
        throw new Error("Chain required for publicClient");
      }
      publicClient = (0, import_viem3.createPublicClient)({
        chain,
        transport: (0, import_viem3.http)(rpcUrl)
      });
    }
    if (!walletClient.account?.address) {
      throw new Error("WalletClient needs an account");
    }
    deployerAddress = walletClient.account.address;
    if (chain) {
      chainId = chain.id;
    } else {
      chainId = await walletClient.getChainId();
    }
  } else {
    throw new Error("Need privateKey or walletClient");
  }
  const networkClients = {
    publicClient,
    walletClient,
    address: deployerAddress,
    chainId
  };
  const transactionTracker = createTransactionTracker();
  if (onTransactionStateChange && typeof onTransactionStateChange === "function") {
    const pollStatus = () => {
      onTransactionStateChange(
        transactionTracker.status
      );
      if (!transactionTracker.isComplete) {
        setTimeout(pollStatus, 100);
      }
    };
    setTimeout(pollStatus, 10);
  }
  if (!skipPrerequisiteChecks) {
    const requirements = {
      targetChainId: chainId,
      minBalance: minBalance ? (0, import_viem3.parseEther)(minBalance) : (0, import_viem3.parseEther)("0.001")
      // Default 0.001 ETH
    };
    const validation = await validateNetworkPrerequisites(networkClients, requirements);
    if (!validation.networkValid) {
      throw new Error(
        `Wrong network. Need chain ${requirements.targetChainId}, got ${validation.details.currentChainId}`
      );
    }
    if (!validation.balanceValid) {
      const requiredEth = Number(requirements.minBalance) / 1e18;
      const currentEth = Number(validation.details.balance) / 1e18;
      throw new Error(`Not enough ETH. Need ${requiredEth}, have ${currentEth.toFixed(6)}`);
    }
  }
  const deviceIdHex = asHex(deviceId);
  const composeHashHex = asHex(composeHash);
  const deviceIdBytes = `0x${deviceIdHex.slice(2).padEnd(64, "0")}`;
  const composeHashBytes = `0x${composeHashHex.slice(2).padEnd(64, "0")}`;
  const deployOperation = async (clients) => {
    try {
      const code = await clients.publicClient.getCode({ address: kmsContractAddress });
      if (!code || code === "0x") {
        throw new Error(`No contract at ${kmsContractAddress}`);
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("No contract at")) {
        throw error;
      }
    }
    const contractCall = {
      address: kmsContractAddress,
      abi: kmsAuthAbi,
      functionName: "deployAndRegisterApp",
      args: [
        clients.address,
        disableUpgrades,
        allowAnyDevice,
        deviceIdBytes,
        composeHashBytes
      ],
      account: clients.walletClient.account || clients.address,
      chain: chain || null
    };
    return await clients.walletClient.writeContract(contractCall);
  };
  const transactionResult = retryOptions ? await executeTransactionWithRetry(
    deployOperation,
    networkClients,
    [],
    {
      timeout,
      confirmations: 1,
      onSubmitted: onTransactionSubmitted,
      onConfirmed: onTransactionConfirmed,
      signal
    },
    retryOptions
  ) : await transactionTracker.execute(deployOperation, networkClients, [], {
    timeout,
    confirmations: 1,
    onSubmitted: onTransactionSubmitted,
    onConfirmed: onTransactionConfirmed,
    signal
  });
  const result = parseDeploymentResult(
    transactionResult.receipt,
    deployerAddress,
    kmsContractAddress
  );
  if (parameters?.schema === false) {
    return result;
  }
  const schema = parameters?.schema || DeployAppAuthSchema;
  return schema.parse(result);
}
async function safeDeployAppAuth(request, parameters) {
  try {
    const result = await deployAppAuth(request, parameters);
    return { success: true, data: result };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown deployment error";
    const requestError = {
      isRequestError: true,
      message: errorMessage,
      status: 500,
      // Use 500 for blockchain errors since they're not HTTP errors
      detail: errorMessage
    };
    return {
      success: false,
      error: requestError
    };
  }
}

// src/actions/blockchains/add_compose_hash.ts
var import_zod33 = require("zod");
var import_viem4 = require("viem");
var import_accounts3 = require("viem/accounts");
var appAuthAbi = [
  {
    inputs: [{ name: "composeHash", type: "bytes32" }],
    name: "addComposeHash",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "composeHash", type: "bytes32", indexed: false }],
    name: "ComposeHashAdded",
    type: "event",
    anonymous: false
  }
];
var AddComposeHashRequestSchema = import_zod33.z.object({
  // Chain configuration (conditionally required)
  chain: import_zod33.z.unknown().optional(),
  rpcUrl: import_zod33.z.string().optional(),
  appId: import_zod33.z.string(),
  composeHash: import_zod33.z.string(),
  // Authentication mode: either privateKey OR walletClient (required, mutually exclusive)
  privateKey: import_zod33.z.string().optional(),
  walletClient: import_zod33.z.unknown().optional(),
  // Public client (optional, will create default if not provided)
  publicClient: import_zod33.z.unknown().optional(),
  // Validation configuration (optional)
  skipPrerequisiteChecks: import_zod33.z.boolean().optional().default(false),
  minBalance: import_zod33.z.string().optional(),
  // ETH amount as string, e.g., "0.01"
  // Transaction control options
  timeout: import_zod33.z.number().optional().default(12e4),
  retryOptions: import_zod33.z.unknown().optional(),
  signal: import_zod33.z.unknown().optional(),
  // Progress callbacks
  onTransactionStateChange: import_zod33.z.function().optional(),
  onTransactionSubmitted: import_zod33.z.function().optional(),
  onTransactionConfirmed: import_zod33.z.function().optional()
}).passthrough().refine(
  (data) => {
    const hasPrivateKey = !!data.privateKey;
    const hasWalletClient = !!data.walletClient;
    return hasPrivateKey !== hasWalletClient;
  },
  {
    message: "Either 'privateKey' or 'walletClient' must be provided, but not both",
    path: ["privateKey", "walletClient"]
  }
).refine(
  (data) => {
    const hasPublicClient = !!data.publicClient;
    const hasWalletClient = !!data.walletClient;
    const hasChain = !!data.chain;
    if (hasPublicClient && hasWalletClient) return true;
    return hasChain;
  },
  {
    message: "Chain is required when publicClient or walletClient is not provided",
    path: ["chain"]
  }
);
var AddComposeHashSchema = import_zod33.z.object({
  composeHash: import_zod33.z.string(),
  appId: import_zod33.z.string(),
  transactionHash: import_zod33.z.string(),
  blockNumber: import_zod33.z.bigint().optional(),
  gasUsed: import_zod33.z.bigint().optional()
}).passthrough();
function parseComposeHashResult(receipt, composeHash, appAuthAddress, appId) {
  console.log(receipt.logs);
  try {
    const logs = (0, import_viem4.parseEventLogs)({
      abi: appAuthAbi,
      eventName: "ComposeHashAdded",
      logs: receipt.logs,
      strict: false
    });
    if (logs.length > 0) {
      const event = logs[0];
      if (event?.args?.composeHash !== composeHash) {
        console.warn(
          `Event compose hash (${event?.args?.composeHash}) does not match expected (${composeHash})`
        );
      }
    }
    return {
      composeHash,
      appAuthAddress,
      appId,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  } catch (parseError) {
    console.warn("Failed to parse ComposeHashAdded event, returning basic result:", parseError);
    return {
      composeHash,
      appAuthAddress,
      appId,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  }
}
async function addComposeHash(request, parameters) {
  const validatedRequest = AddComposeHashRequestSchema.parse(request);
  const {
    chain,
    rpcUrl,
    appId,
    composeHash,
    privateKey,
    walletClient: providedWalletClient,
    publicClient: providedPublicClient,
    timeout = 12e4,
    retryOptions,
    signal,
    onTransactionStateChange,
    onTransactionSubmitted,
    onTransactionConfirmed,
    skipPrerequisiteChecks = false,
    minBalance
  } = validatedRequest;
  let publicClient;
  let walletClient;
  let address;
  let chainId;
  const appAuthAddress = appId.startsWith("0x") ? appId : `0x${appId}`;
  if (privateKey) {
    const account = (0, import_accounts3.privateKeyToAccount)(privateKey);
    if (providedPublicClient) {
      publicClient = providedPublicClient;
    } else {
      if (!chain) throw new Error("Chain required when creating publicClient");
      publicClient = (0, import_viem4.createPublicClient)({ chain, transport: (0, import_viem4.http)(rpcUrl) });
    }
    if (!chain) throw new Error("Chain required when creating walletClient");
    walletClient = (0, import_viem4.createWalletClient)({
      account,
      chain,
      transport: (0, import_viem4.http)(rpcUrl)
    });
    address = account.address;
    chainId = chain.id;
  } else if (providedWalletClient) {
    walletClient = providedWalletClient;
    if (providedPublicClient) {
      publicClient = providedPublicClient;
    } else {
      if (!chain) throw new Error("Chain required when creating publicClient");
      publicClient = (0, import_viem4.createPublicClient)({ chain, transport: (0, import_viem4.http)(rpcUrl) });
    }
    if (!walletClient.account?.address) {
      throw new Error("WalletClient must have an account with address");
    }
    address = walletClient.account.address;
    chainId = chain ? chain.id : await walletClient.getChainId();
  } else {
    throw new Error("Either privateKey or walletClient must be provided");
  }
  const networkClients = {
    publicClient,
    walletClient,
    address,
    chainId
  };
  const transactionTracker = createTransactionTracker();
  if (onTransactionStateChange && typeof onTransactionStateChange === "function") {
    const pollStatus = () => {
      onTransactionStateChange(transactionTracker.status);
      if (!transactionTracker.isComplete) {
        setTimeout(pollStatus, 100);
      }
    };
    setTimeout(pollStatus, 10);
  }
  if (!skipPrerequisiteChecks) {
    const requirements = {
      targetChainId: chainId,
      minBalance: minBalance ? (0, import_viem4.parseEther)(minBalance) : (0, import_viem4.parseEther)("0.001")
    };
    const validation = await validateNetworkPrerequisites(networkClients, requirements);
    if (!validation.networkValid) {
      throw new Error(
        `Network mismatch: Expected chain ${requirements.targetChainId}, but wallet is on chain ${validation.details.currentChainId}`
      );
    }
    if (!validation.balanceValid) {
      const requiredEth = Number(requirements.minBalance) / 1e18;
      const currentEth = Number(validation.details.balance) / 1e18;
      throw new Error(
        `Insufficient balance: Required ${requiredEth} ETH, but account has ${currentEth.toFixed(6)} ETH`
      );
    }
  }
  const addComposeHashOperation = async (clients) => {
    const hash = await clients.walletClient.writeContract({
      address: appAuthAddress,
      abi: appAuthAbi,
      functionName: "addComposeHash",
      args: [asHex(composeHash)],
      account: clients.walletClient.account || clients.address,
      chain: chain || null
    });
    return hash;
  };
  const transactionResult = retryOptions ? await executeTransactionWithRetry(
    addComposeHashOperation,
    networkClients,
    [],
    {
      timeout,
      confirmations: 1,
      onSubmitted: onTransactionSubmitted,
      onConfirmed: onTransactionConfirmed,
      signal
    },
    retryOptions
  ) : await transactionTracker.execute(addComposeHashOperation, networkClients, [], {
    timeout,
    confirmations: 1,
    onSubmitted: onTransactionSubmitted,
    onConfirmed: onTransactionConfirmed,
    signal
  });
  const result = parseComposeHashResult(
    transactionResult.receipt,
    asHex(composeHash),
    appAuthAddress,
    appId
  );
  if (parameters?.schema === false) {
    return result;
  }
  const schema = parameters?.schema || AddComposeHashSchema;
  return schema.parse(result);
}
async function safeAddComposeHash(request, parameters) {
  try {
    const result = await addComposeHash(request, parameters);
    return { success: true, data: result };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown blockchain error";
    return {
      success: false,
      error: {
        isRequestError: true,
        message: errorMessage,
        status: 500,
        // Blockchain errors use 500
        detail: errorMessage
      }
    };
  }
}

// src/actions/cvms/watch_cvm_state.ts
var import_zod34 = require("zod");
var WatchCvmStateParamsSchema = import_zod34.z.object({
  target: import_zod34.z.string().describe("Target status to wait for (e.g., 'running', 'stopped')"),
  interval: import_zod34.z.number().min(5).max(30).default(5).describe("Polling interval in seconds"),
  timeout: import_zod34.z.number().min(10).max(600).default(300).describe("Timeout per attempt in seconds"),
  maxRetries: import_zod34.z.number().min(0).default(Number.POSITIVE_INFINITY).describe("Maximum number of retry attempts (Infinity for unlimited)"),
  retryDelay: import_zod34.z.number().min(0).default(5e3).describe("Delay between retries in milliseconds")
});
var WatchCvmStateRequestSchema = WatchCvmStateParamsSchema;
var WatchAbortedError = class extends Error {
  constructor() {
    super("Watch operation was aborted");
    this.name = "WatchAbortedError";
  }
};
var MaxRetriesExceededError = class extends Error {
  constructor(attempts) {
    super(`Maximum retry attempts (${attempts}) exceeded`);
    this.attempts = attempts;
    this.name = "MaxRetriesExceededError";
  }
};
function parseSSEEvent(eventType, data) {
  try {
    const parsed = JSON.parse(data);
    return { type: eventType, data: parsed };
  } catch {
    return { type: "error", data: { error: "Failed to parse SSE event" } };
  }
}
async function watchCvmState(client, request, options = {}) {
  const { cvmId } = CvmIdSchema.parse(request);
  const { target, interval, timeout, maxRetries, retryDelay } = WatchCvmStateParamsSchema.parse(request);
  const { signal, onEvent } = options;
  let attempt = 0;
  while (attempt < maxRetries) {
    if (signal?.aborted) {
      throw new WatchAbortedError();
    }
    attempt++;
    try {
      const result = await watchSingleAttempt(
        client,
        cvmId,
        target,
        interval,
        timeout,
        signal,
        onEvent
      );
      if (result) {
        return result;
      }
      if (attempt >= maxRetries) {
        throw new MaxRetriesExceededError(attempt);
      }
      await sleep(retryDelay, signal);
    } catch (error) {
      if (signal?.aborted) {
        throw new WatchAbortedError();
      }
      if (error instanceof WatchAbortedError || error instanceof MaxRetriesExceededError) {
        throw error;
      }
      if (attempt >= maxRetries) {
        throw error;
      }
      if (onEvent) {
        onEvent({
          type: "error",
          data: { error: error instanceof Error ? error.message : String(error) }
        });
      }
      await sleep(retryDelay, signal);
    }
  }
  throw new MaxRetriesExceededError(attempt);
}
async function watchSingleAttempt(client, cvmId, target, interval, timeout, signal, onEvent) {
  const params = new URLSearchParams({
    target,
    interval: String(interval),
    timeout: String(timeout)
  });
  const baseURL = client.config.baseURL || "";
  const fullUrl = `${baseURL}/cvms/${cvmId}/state?${params.toString()}`;
  const headers = {
    Accept: "text/event-stream",
    "Cache-Control": "no-cache"
  };
  if (!client.config.useCookieAuth && client.config.apiKey) {
    headers["X-API-Key"] = client.config.apiKey;
  }
  if (client.config.headers) {
    Object.entries(client.config.headers).forEach(([key, value]) => {
      if (typeof value === "string") {
        headers[key] = value;
      }
    });
  }
  const response = await client.raw.native(fullUrl, {
    method: "GET",
    headers,
    signal,
    ...client.config.useCookieAuth ? { credentials: "include" } : {}
  });
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  if (!response.body) {
    throw new Error("Response body is null");
  }
  return parseSSEStream(response.body, signal, onEvent);
}
async function parseSSEStream(stream, signal, onEvent) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let finalState = null;
  let currentEvent = "";
  let currentData = "";
  const processLine = (line) => {
    if (line.startsWith("event:")) {
      currentEvent = line.slice(6).trim();
    } else if (line.startsWith("data:")) {
      currentData = line.slice(5).trim();
    } else if (line === "") {
      if (currentEvent && currentData) {
        const event = parseSSEEvent(currentEvent, currentData);
        if (event.type === "state") {
          finalState = event.data;
        }
        onEvent?.(event);
        if (event.type === "complete") {
          return "complete";
        }
        if (event.type === "timeout") {
          return "timeout";
        }
      }
      currentEvent = "";
      currentData = "";
    }
    return null;
  };
  try {
    while (true) {
      if (signal?.aborted) {
        throw new WatchAbortedError();
      }
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const result = processLine(line.trim());
        if (result === "complete") {
          return finalState;
        }
        if (result === "timeout") {
          return null;
        }
      }
    }
    return finalState;
  } catch (error) {
    if (error instanceof WatchAbortedError) {
      throw error;
    }
    throw new Error(`SSE stream error: ${error instanceof Error ? error.message : String(error)}`);
  } finally {
    reader.releaseLock();
  }
}
function sleep(ms, signal) {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(new WatchAbortedError());
      return;
    }
    const timer = setTimeout(resolve, ms);
    if (signal) {
      signal.addEventListener("abort", () => {
        clearTimeout(timer);
        reject(new WatchAbortedError());
      });
    }
  });
}

// src/parse_dotenv.ts
var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
function parseEnv(input) {
  const obj = {};
  let lines = input.toString();
  lines = lines.replace(/\r\n?/gm, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    if (!key) continue;
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}
function parseEnvVars(input) {
  const parsed = parseEnv(input);
  const result = [];
  for (const [key, value] of Object.entries(parsed)) {
    result.push({ key, value });
  }
  return result;
}

// src/index.ts
var import_encrypt_env_vars2 = require("@phala/dstack-sdk/encrypt-env-vars");
var import_get_compose_hash3 = require("@phala/dstack-sdk/get-compose-hash");
var import_verify_env_encrypt_public_key = require("@phala/dstack-sdk/verify-env-encrypt-public-key");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AddComposeHashSchema,
  AllFamiliesResponseSchema,
  ApiErrorSchema,
  AuthError,
  AvailableNodesSchema,
  BusinessError,
  CommitCvmComposeFileUpdateRequestSchema,
  CommitCvmComposeFileUpdateSchema,
  CommitCvmProvisionRequestSchema,
  CommitCvmProvisionSchema,
  CurrentUserSchema,
  CvmAttestationSchema,
  CvmContainersStatsSchema,
  CvmIdBaseSchema,
  CvmIdObjectSchema,
  CvmIdSchema,
  CvmInfoSchema,
  CvmLegacyDetailSchema,
  CvmNetworkSchema,
  CvmNetworkUrlsSchema,
  CvmNodeSchema,
  CvmStateSchema,
  CvmSystemInfoSchema,
  DeleteCvmRequestSchema,
  DeployAppAuthRequestSchema,
  DeployAppAuthSchema,
  FamilyGroupSchema,
  FamilyInstanceTypesResponseSchema,
  GetAppEnvEncryptPubKeyRequestSchema,
  GetAppEnvEncryptPubKeySchema,
  GetAvailableOSImagesRequestSchema,
  GetAvailableOSImagesResponseSchema,
  GetCvmAttestationRequestSchema,
  GetCvmComposeFileRequestSchema,
  GetCvmContainersStatsRequestSchema,
  GetCvmDockerComposeRequestSchema,
  GetCvmInfoRequestSchema,
  GetCvmListRequestSchema,
  GetCvmListSchema,
  GetCvmNetworkRequestSchema,
  GetCvmStateRequestSchema,
  GetCvmStatsRequestSchema,
  GetKmsInfoRequestSchema,
  GetKmsListRequestSchema,
  GetKmsListSchema,
  InstanceTypeSchema,
  KmsInfoSchema,
  ListFamilyInstanceTypesRequestSchema,
  ListWorkspacesSchema,
  ManagedUserSchema,
  MaxRetriesExceededError,
  NetworkError,
  NextAppIdsRequestSchema,
  NextAppIdsSchema,
  OSImageVariantSchema,
  PaginationMetadataSchema,
  PhalaCloudError,
  ProvisionCvmComposeFileUpdateRequestSchema,
  ProvisionCvmComposeFileUpdateResultSchema,
  ProvisionCvmRequestSchema,
  ProvisionCvmSchema,
  RequestError,
  ResourceError,
  RestartCvmRequestSchema,
  SUPPORTED_API_VERSIONS,
  SUPPORTED_CHAINS,
  ServerError,
  ShutdownCvmRequestSchema,
  StartCvmRequestSchema,
  StopCvmRequestSchema,
  TransactionError,
  UnknownError,
  UpdateCvmEnvsRequestSchema,
  UpdateCvmEnvsResultSchema,
  UpdateCvmResourcesRequestSchema,
  UpdateCvmVisibilityRequestSchema,
  UpdateOsImageRequestSchema,
  VMSchema,
  ValidationError,
  VmInfoSchema,
  WalletError,
  WatchAbortedError,
  WatchCvmStateRequestSchema,
  WorkspaceResponseSchema,
  addComposeHash,
  addNetwork,
  asHex,
  autoCreateClients,
  checkBalance,
  checkNetworkStatus,
  commitCvmComposeFileUpdate,
  commitCvmProvision,
  createBaseClient,
  createClient,
  createClientsFromBrowser,
  createClientsFromPrivateKey,
  createNetworkClients,
  createTransactionTracker,
  defineAction,
  defineSimpleAction,
  deleteCvm,
  deployAppAuth,
  dumpAppCompose,
  encryptEnvVars,
  estimateTransactionGas,
  executeBatchTransactions,
  executeTransaction,
  executeTransactionWithRetry,
  extractNetworkClients,
  formatErrorMessage,
  formatStructuredError,
  formatValidationErrors,
  getAppEnvEncryptPubKey,
  getAvailableNodes,
  getAvailableOsImages,
  getComposeHash,
  getCurrentUser,
  getCvmAttestation,
  getCvmComposeFile,
  getCvmContainersStats,
  getCvmDockerCompose,
  getCvmInfo,
  getCvmList,
  getCvmNetwork,
  getCvmState,
  getCvmStats,
  getErrorMessage,
  getKmsInfo,
  getKmsList,
  getValidationFields,
  getWorkspace,
  listAllInstanceTypeFamilies,
  listFamilyInstanceTypes,
  listWorkspaces,
  nextAppIds,
  parseApiError,
  parseEnv,
  parseEnvVars,
  preprocessAppCompose,
  provisionCvm,
  provisionCvmComposeFileUpdate,
  refineCvmId,
  restartCvm,
  safeAddComposeHash,
  safeCommitCvmComposeFileUpdate,
  safeCommitCvmProvision,
  safeDeleteCvm,
  safeDeployAppAuth,
  safeGetAppEnvEncryptPubKey,
  safeGetAvailableNodes,
  safeGetAvailableOsImages,
  safeGetCurrentUser,
  safeGetCvmAttestation,
  safeGetCvmComposeFile,
  safeGetCvmContainersStats,
  safeGetCvmDockerCompose,
  safeGetCvmInfo,
  safeGetCvmList,
  safeGetCvmNetwork,
  safeGetCvmState,
  safeGetCvmStats,
  safeGetKmsInfo,
  safeGetKmsList,
  safeGetWorkspace,
  safeListAllInstanceTypeFamilies,
  safeListFamilyInstanceTypes,
  safeListWorkspaces,
  safeNextAppIds,
  safeProvisionCvm,
  safeProvisionCvmComposeFileUpdate,
  safeRestartCvm,
  safeShutdownCvm,
  safeStartCvm,
  safeStopCvm,
  safeUpdateCvmEnvs,
  safeUpdateCvmResources,
  safeUpdateCvmVisibility,
  safeUpdateOsImage,
  safeValidateActionParameters,
  shutdownCvm,
  sortObject,
  startCvm,
  stopCvm,
  switchToNetwork,
  updateCvmEnvs,
  updateCvmResources,
  updateCvmVisibility,
  updateOsImage,
  validateActionParameters,
  validateNetworkPrerequisites,
  verifyEnvEncryptPublicKey,
  waitForTransactionReceipt,
  watchCvmState,
  withComposeMethods
});
