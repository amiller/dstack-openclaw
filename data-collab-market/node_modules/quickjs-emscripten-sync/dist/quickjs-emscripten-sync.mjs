var D = Object.defineProperty;
var A = (n, e, t) => e in n ? D(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var c = (n, e, t) => A(n, typeof e != "symbol" ? e + "" : e, t);
const B = (n) => {
  const e = new U(n);
  return new Proxy(n, {
    get(t, r, s) {
      return r in e ? e[r] : Reflect.get(t, r, s);
    }
  });
};
class U {
  constructor(e) {
    c(this, "context");
    c(this, "fn");
    c(this, "fnGenerator");
    c(this, "fnCounter", Number.MIN_SAFE_INTEGER);
    c(this, "fnMap", /* @__PURE__ */ new Map());
    /** Similar to the original newFunction, but no matter how many new functions are generated, newFunction is called only once. */
    c(this, "newFunction", (e, t) => {
      this.fnCounter++;
      const r = this.fnCounter;
      return this.fnMap.set(r, t), this.context.unwrapResult(
        this.context.callFunction(
          this.fnGenerator,
          this.context.undefined,
          this.context.newString(e),
          this.context.newNumber(t.length),
          this.context.newNumber(r),
          this.fn
        )
      );
    });
    this.context = e;
    const t = this.fnMap;
    this.fn = this.context.newFunction("", function(r, ...s) {
      const o = e.getNumber(r), i = t.get(o);
      if (!i) throw new Error("function is not registered");
      return i.call(this, ...s);
    }), this.fnGenerator = e.unwrapResult(
      e.evalCode(`((name, length, id, f) => {
        const fn = function(...args) {
          return f.call(this, id, ...args);
        };
        fn.name = name;
        fn.length = length;
        return fn;
      })`)
    );
  }
  disposeEx() {
    this.fnGenerator.dispose(), this.fn.dispose();
  }
}
const I = [
  // basic objects
  [Symbol, "Symbol"],
  [Symbol.prototype, "Symbol.prototype"],
  [Object, "Object"],
  [Object.prototype, "Object.prototype"],
  [Function, "Function"],
  [Function.prototype, "Function.prototype"],
  [Boolean, "Boolean"],
  [Boolean.prototype, "Boolean.prototype"],
  [Array, "Array"],
  [Array.prototype, "Array.prototype"],
  // [BigInt, "BigInt"],
  // [BigInt.prototype, "BigInt.prototype"],
  // errors
  [Error, "Error"],
  [Error.prototype, "Error.prototype"],
  [EvalError, "EvalError"],
  [EvalError.prototype, "EvalError.prototype"],
  [RangeError, "RangeError"],
  [RangeError.prototype, "RangeError.prototype"],
  [ReferenceError, "ReferenceError"],
  [ReferenceError.prototype, "ReferenceError.prototype"],
  [SyntaxError, "SyntaxError"],
  [SyntaxError.prototype, "SyntaxError.prototype"],
  [TypeError, "TypeError"],
  [TypeError.prototype, "TypeError.prototype"],
  [URIError, "URIError"],
  [URIError.prototype, "URIError.prototype"],
  // built-in symbols
  ...Object.getOwnPropertyNames(Symbol).filter((n) => typeof Symbol[n] == "symbol").map((n) => [Symbol[n], `Symbol.${n}`])
];
function T(n, e) {
  const t = n.unwrapResult(n.evalCode(e)), r = (o, ...i) => n.unwrapResult(n.callFunction(t, o != null ? o : n.undefined, ...i)), s = () => t.dispose();
  return r.dispose = s, r[Symbol.dispose] = s, r.alive = !0, Object.defineProperty(r, "alive", {
    get: () => t.alive
  }), r;
}
function y(n, e, t, ...r) {
  const s = T(n, e);
  try {
    return s(t, ...r);
  } finally {
    s.dispose();
  }
}
function G(n, e, t) {
  return n.dump(y(n, "(a, b) => a instanceof b", void 0, e, t));
}
function J(n, e) {
  return n.dump(
    y(n, 'a => typeof a === "object" && a !== null || typeof a === "function"', void 0, e)
  );
}
function W(n, e) {
  const t = JSON.stringify(e);
  return t ? y(n, "JSON.parse", void 0, n.newString(t)) : n.undefined;
}
function _e(n, e) {
  try {
    return e(n);
  } finally {
    for (const t of n)
      t.alive && t.dispose();
  }
}
function z([n, e], t) {
  try {
    return t(n);
  } finally {
    e && n.dispose();
  }
}
function g(n, e) {
  try {
    return e(...n.map((t) => t[0]));
  } finally {
    for (const [t, r] of n)
      r && t.dispose();
  }
}
function $(n) {
  return "handle" in n;
}
function L(n) {
  return $(n) ? n.handle : n;
}
function V(n, e, t, r) {
  var o;
  let s;
  for (const i of r)
    if (s = i(e, n), s) break;
  return s ? (o = t(e, s)) != null ? o : s : void 0;
}
function Q(n, e) {
  return typeof n != "symbol" ? void 0 : y(
    e,
    "d => Symbol(d)",
    void 0,
    n.description ? e.newString(n.description) : e.undefined
  );
}
function q(n, e) {
  return n instanceof Date ? y(e, "d => new Date(d)", void 0, e.newNumber(n.getTime())) : void 0;
}
const X = [Q, q];
function Y(n) {
  return typeof n == "function" && /^class\s/.test(Function.prototype.toString.call(n));
}
function v(n) {
  return typeof n == "function" || typeof n == "object" && n !== null;
}
function E(n, e) {
  const t = /* @__PURE__ */ new Set(), r = (s) => {
    if (!(!v(s) || t.has(s) || (e == null ? void 0 : e(s, t)) === !1)) {
      if (t.add(s), Array.isArray(s)) {
        for (const o of s)
          r(o);
        return;
      }
      if (typeof s == "object") {
        const o = Object.getPrototypeOf(s);
        o && o !== Object.prototype && r(o);
      }
      for (const o of Object.values(Object.getOwnPropertyDescriptors(s)))
        "value" in o && r(o.value), "get" in o && r(o.get), "set" in o && r(o.set);
    }
  };
  return r(n), t;
}
function be(n, e) {
  return E(n, e ? (t, r) => r.size < e : void 0).size;
}
function Z() {
  let n = () => {
  }, e = () => {
  };
  return {
    promise: new Promise((r, s) => {
      n = r, e = s;
    }),
    resolve: n,
    reject: e
  };
}
function M(n, e, t, r) {
  const s = n.newObject(), o = (a, u) => {
    const p = r(a), l = typeof u.value == "undefined" ? void 0 : r(u.value), f = typeof u.get == "undefined" ? void 0 : r(u.get), d = typeof u.set == "undefined" ? void 0 : r(u.set);
    n.newObject().consume((m) => {
      Object.entries(u).forEach(([h, _]) => {
        const b = h === "value" ? l : h === "get" ? f : h === "set" ? d : _ ? n.true : n.false;
        b && n.setProp(m, h, b);
      }), n.setProp(s, p, m);
    });
  }, i = Object.getOwnPropertyDescriptors(e);
  Object.entries(i).forEach(([a, u]) => o(a, u)), Object.getOwnPropertySymbols(i).forEach((a) => o(a, i[a])), y(n, "Object.defineProperties", void 0, t, s).dispose(), s.dispose();
}
function K(n, e, t, r, s, o) {
  var u;
  if (typeof e != "function") return;
  const i = n.newFunction(e.name, function(...p) {
    const l = r(this), f = p.map((d) => r(d));
    if (Y(e) && v(l)) {
      const d = new e(...f);
      return Object.entries(d).forEach(([m, h]) => {
        n.setProp(this, m, t(h));
      }), this;
    }
    return t(o ? o(e, l, f) : e.apply(l, f));
  }).consume(
    (p) => (
      // fucntions created by vm.newFunction are not callable as a class constrcutor
      y(
        n,
        `Cls => {
          const fn = function(...args) { return Cls.apply(this, args); };
          fn.name = Cls.name;
          fn.length = Cls.length;
          return fn;
        }`,
        void 0,
        p
      )
    )
  ), a = (u = s(e, i)) != null ? u : i;
  return M(n, e, i, t), a;
}
function x(n, e, t) {
  var o;
  const r = W(n, e);
  return (o = t(e, r)) != null ? o : r;
}
function ee(n, e, t, r) {
  var u;
  if (typeof e != "object" || e === null) return;
  const s = Array.isArray(e) ? n.newArray() : n.newObject(), o = (u = r(e, s)) != null ? u : s, i = Object.getPrototypeOf(e), a = i && i !== Object.prototype && i !== Array.prototype ? t(i) : void 0;
  return a && y(n, "Object.setPrototypeOf", void 0, o, a).dispose(), M(n, e, s, t), o;
}
function te(n, e) {
  switch (typeof e) {
    case "undefined":
      return n.undefined;
    case "number":
      return n.newNumber(e);
    case "string":
      return n.newString(e);
    case "boolean":
      return e ? n.true : n.false;
    case "object":
      return e === null ? n.null : void 0;
  }
}
function ne(n, e, t, r) {
  var o;
  if (!(e instanceof Promise)) return;
  const s = n.newPromise();
  return e.then(
    (i) => s.resolve(t(i)),
    (i) => s.reject(t(i))
  ), (o = r(e, s)) != null ? o : s.handle;
}
function R(n, e) {
  var l, f, d, m, h;
  const { ctx: t, unmarshal: r, isMarshalable: s, find: o, pre: i } = e;
  {
    const _ = te(t, n);
    if (_)
      return _;
  }
  {
    const _ = o(n);
    if (_) return _;
  }
  const a = s == null ? void 0 : s(n);
  if (a === !1)
    return t.undefined;
  const u = (_, b) => i(_, b, a);
  if (a === "json")
    return x(t, n, u);
  const p = (_) => R(_, e);
  return (h = (m = (d = (f = V(t, n, u, [...X, ...(l = e.custom) != null ? l : []])) != null ? f : ne(t, n, p, u)) != null ? d : K(t, n, p, r, u, e.preApply)) != null ? m : ee(t, n, p, u)) != null ? h : t.undefined;
}
function re(n, e, t, r) {
  var o;
  let s;
  for (const i of r)
    if (s = i(e, n), s) break;
  return s ? (o = t(s, e)) != null ? o : s : void 0;
}
function se(n, e) {
  if (e.typeof(n) !== "symbol") return;
  const t = e.getString(e.getProp(n, "description"));
  return Symbol(t);
}
function oe(n, e) {
  if (!e.dump(y(e, "a => a instanceof Date", void 0, n))) return;
  const t = e.getNumber(y(e, "a => a.getTime()", void 0, n));
  return new Date(t);
}
const ie = [se, oe];
function k(n, e, t, r) {
  n.newFunction("", (s, o) => {
    const [i] = r(s);
    if (typeof i != "string" && typeof i != "number" && typeof i != "symbol")
      return;
    const a = [
      ["value", !0],
      ["get", !0],
      ["set", !0],
      ["configurable", !1],
      ["enumerable", !1],
      ["writable", !1]
    ].reduce((u, [p, l]) => {
      const f = n.getProp(o, p), d = n.typeof(f);
      if (d === "undefined") return u;
      if (!l && d === "boolean")
        return u[p] = n.dump(n.getProp(o, p)), u;
      const [m, h] = r(f);
      return h && f.dispose(), u[p] = m, u;
    }, {});
    Object.defineProperty(t, i, a);
  }).consume((s) => {
    y(
      n,
      `(o, fn) => {
        const descs = Object.getOwnPropertyDescriptors(o);
        Object.entries(descs).forEach(([k, v]) => fn(k, v));
        Object.getOwnPropertySymbols(descs).forEach(k => fn(k, descs[k]));
      }`,
      void 0,
      e,
      s
    ).dispose();
  });
}
function ue(n, e, t, r, s) {
  var a;
  if (n.typeof(e) !== "function") return;
  const o = function(...u) {
    return g(
      [t(this), ...u.map((p) => t(p))],
      (p, ...l) => {
        if (new.target) {
          const [h] = r(
            y(n, "(Cls, ...args) => new Cls(...args)", p, e, ...l)
          );
          return Object.defineProperties(this, Object.getOwnPropertyDescriptors(h)), this;
        }
        const f = n.unwrapResult(n.callFunction(e, p, ...l)), [d, m] = r(f);
        return m && f.dispose(), d;
      }
    );
  }, i = (a = s(o, e)) != null ? a : o;
  return k(n, e, o, r), i;
}
function ae(n, e, t, r) {
  var a;
  if (n.typeof(e) !== "object" || // null check
  n.unwrapResult(n.evalCode("o => o === null")).consume((u) => n.dump(n.unwrapResult(n.callFunction(u, n.undefined, e)))))
    return;
  const s = y(n, "Array.isArray", void 0, e).consume((u) => n.dump(u)) ? [] : {}, o = (a = r(s, e)) != null ? a : s, i = y(
    n,
    `o => {
      const p = Object.getPrototypeOf(o);
      return !p || p === Object.prototype || p === Array.prototype ? undefined : p;
    }`,
    void 0,
    e
  ).consume((u) => {
    if (n.typeof(u) === "undefined") return;
    const [p] = t(u);
    return p;
  });
  return typeof i == "object" && Object.setPrototypeOf(o, i), k(n, e, s, t), o;
}
function pe(n, e) {
  const t = n.typeof(e);
  return t === "undefined" || t === "number" || t === "string" || t === "boolean" ? [n.dump(e), !0] : t === "object" && n.unwrapResult(n.evalCode("a => a === null")).consume((s) => n.dump(n.unwrapResult(n.callFunction(s, n.undefined, e)))) ? [null, !0] : [void 0, !1];
}
function fe(n, e, t, r) {
  var p;
  if (!ce(n, e)) return;
  const s = Z(), [o, i] = t(s.resolve), [a, u] = t(s.reject);
  return y(n, "(p, res, rej) => { p.then(res, rej); }", void 0, e, o, a), i && o.dispose(), u && a.dispose(), (p = r(s.promise, e)) != null ? p : s.promise;
}
function ce(n, e) {
  return e.owner ? n.unwrapResult(n.evalCode("Promise")).consume((t) => e.owner ? G(n, e, t) : !1) : !1;
}
function le(n, e) {
  const [t] = C(n, e);
  return t;
}
function C(n, e) {
  var u, p, l, f;
  const { ctx: t, marshal: r, find: s, pre: o } = e;
  {
    const [d, m] = pe(t, n);
    if (m) return [d, !1];
  }
  {
    const d = s(n);
    if (d)
      return [d, !0];
  }
  const i = (d) => C(d, e);
  return [(f = (l = (p = re(t, n, o, [...ie, ...(u = e.custom) != null ? u : []])) != null ? p : fe(t, n, r, o)) != null ? l : ue(t, n, r, i, o)) != null ? f : ae(t, n, i, o), !1];
}
class O {
  constructor(e) {
    c(this, "ctx");
    c(this, "_map1", /* @__PURE__ */ new Map());
    c(this, "_map2", /* @__PURE__ */ new Map());
    c(this, "_map3", /* @__PURE__ */ new Map());
    c(this, "_map4", /* @__PURE__ */ new Map());
    c(this, "_counterMap", /* @__PURE__ */ new Map());
    c(this, "_disposables", /* @__PURE__ */ new Set());
    c(this, "_mapGet");
    c(this, "_mapSet");
    c(this, "_mapDelete");
    c(this, "_mapClear");
    c(this, "_counter", Number.MIN_SAFE_INTEGER);
    this.ctx = e;
    const t = e.unwrapResult(
      e.evalCode(`() => {
        const mapSym = new Map();
        let map = new WeakMap();
        let map2 = new WeakMap();
        const isObj = o => typeof o === "object" && o !== null || typeof o === "function";
        return {
          get: key => mapSym.get(key) ?? map.get(key) ?? map2.get(key) ?? -1,
          set: (key, value, key2) => {
            if (typeof key === "symbol") mapSym.set(key, value);
            if (isObj(key)) map.set(key, value);
            if (isObj(key2)) map2.set(key2, value);
          },
          delete: (key, key2) => {
            mapSym.delete(key);
            map.delete(key);
            map2.delete(key2);
          },
          clear: () => {
            mapSym.clear();
            map = new WeakMap();
            map2 = new WeakMap();
          }
        };
      }`)
    ).consume((r) => this._call(r, void 0));
    this._mapGet = e.getProp(t, "get"), this._mapSet = e.getProp(t, "set"), this._mapDelete = e.getProp(t, "delete"), this._mapClear = e.getProp(t, "clear"), t.dispose(), this._disposables.add(this._mapGet), this._disposables.add(this._mapSet), this._disposables.add(this._mapDelete), this._disposables.add(this._mapClear);
  }
  set(e, t, r, s) {
    var a;
    if (!t.alive || s && !s.alive) return !1;
    const o = (a = this.get(e)) != null ? a : this.get(r);
    if (o)
      return o === t || o === s;
    const i = this._counter++;
    return this._map1.set(e, i), this._map3.set(i, t), this._counterMap.set(i, e), r && (this._map2.set(r, i), s && this._map4.set(i, s)), this.ctx.newNumber(i).consume((u) => {
      this._call(this._mapSet, void 0, t, u, s != null ? s : this.ctx.undefined);
    }), !0;
  }
  merge(e) {
    if (e)
      for (const t of e)
        t && t[1] && this.set(t[0], t[1], t[2], t[3]);
  }
  get(e) {
    var s;
    const t = (s = this._map1.get(e)) != null ? s : this._map2.get(e), r = typeof t == "number" ? this._map3.get(t) : void 0;
    if (r) {
      if (!r.alive) {
        this.delete(e);
        return;
      }
      return r;
    }
  }
  getByHandle(e) {
    if (e.alive)
      return this._counterMap.get(this.ctx.getNumber(this._call(this._mapGet, void 0, e)));
  }
  has(e) {
    return !!this.get(e);
  }
  hasHandle(e) {
    return typeof this.getByHandle(e) != "undefined";
  }
  keys() {
    return this._map1.keys();
  }
  delete(e, t) {
    var i;
    const r = (i = this._map1.get(e)) != null ? i : this._map2.get(e);
    if (typeof r == "undefined") return;
    const s = this._map3.get(r), o = this._map4.get(r);
    this._call(
      this._mapDelete,
      void 0,
      ...[s, o].filter((a) => !!(a != null && a.alive))
    ), this._map1.delete(e), this._map2.delete(e), this._map3.delete(r), this._map4.delete(r);
    for (const [a, u] of this._map1)
      if (u === r) {
        this._map1.delete(a);
        break;
      }
    for (const [a, u] of this._map2)
      if (u === r) {
        this._map2.delete(a);
        break;
      }
    for (const [a, u] of this._counterMap)
      if (u === e) {
        this._counterMap.delete(a);
        break;
      }
    t && (s != null && s.alive && s.dispose(), o != null && o.alive && o.dispose());
  }
  deleteByHandle(e, t) {
    const r = this.getByHandle(e);
    typeof r != "undefined" && this.delete(r, t);
  }
  clear() {
    this._counter = 0, this._map1.clear(), this._map2.clear(), this._map3.clear(), this._map4.clear(), this._counterMap.clear(), this._mapClear.alive && this._call(this._mapClear, void 0);
  }
  dispose() {
    for (const e of this._disposables.values())
      e.alive && e.dispose();
    for (const e of this._map3.values())
      e.alive && e.dispose();
    for (const e of this._map4.values())
      e.alive && e.dispose();
    this._disposables.clear(), this.clear();
  }
  get size() {
    return this._map1.size;
  }
  [Symbol.iterator]() {
    const e = this._map1.keys();
    return {
      next: () => {
        for (; ; ) {
          const t = e.next();
          if (t.done) return { value: void 0, done: !0 };
          const r = this._map1.get(t.value);
          if (typeof r == "undefined") continue;
          const s = this._map3.get(r), o = this._map4.get(r);
          if (!s) continue;
          const i = this._get2(r);
          return { value: [t.value, s, i, o], done: !1 };
        }
      }
    };
  }
  _get2(e) {
    for (const [t, r] of this._map2)
      if (r === e) return t;
  }
  _call(e, t, ...r) {
    return this.ctx.unwrapResult(
      this.ctx.callFunction(
        e,
        typeof t == "undefined" ? this.ctx.undefined : t,
        ...r
      )
    );
  }
}
function de(n, e, t, r, s, o, i) {
  if (!v(e) || e instanceof Promise || e instanceof Date || i && !i(e))
    return;
  if (he(e, t)) return e;
  const a = new Proxy(e, {
    get(u, p) {
      return p === t ? u : Reflect.get(u, p);
    },
    set(u, p, l, f) {
      var h;
      const d = w(l, t), m = (h = o == null ? void 0 : o(f)) != null ? h : "host";
      return m !== "vm" && !Reflect.set(u, p, d, f) || m === "host" || !n.alive || g(
        [s(f), s(p), s(d)],
        (_, b, P) => {
          const [S, H] = j(n, _, r);
          H ? S.consume((N) => n.setProp(N, b, P)) : n.setProp(S, b, P);
        }
      ), !0;
    },
    deleteProperty(u, p) {
      var f;
      const l = (f = o == null ? void 0 : o(a)) != null ? f : "host";
      return g([s(a), s(p)], (d, m) => {
        const [h, _] = j(n, d, r);
        if (l === "vm" || Reflect.deleteProperty(u, p)) {
          if (l === "host" || !n.alive) return !0;
          _ ? h.consume((b) => y(n, "(a, b) => delete a[b]", void 0, b, m)) : y(n, "(a, b) => delete a[b]", void 0, h, m);
        }
        return !0;
      });
    }
  });
  return a;
}
function me(n, e, t, r, s, o, i) {
  if (!J(n, e) || i && !i(e, n))
    return [void 0, !1];
  if (F(n, e, r)) return [e, !1];
  const a = (l) => {
    const f = o == null ? void 0 : o(s(l));
    return typeof f == "string" ? n.newString(f) : n.undefined;
  }, u = (l, f, d) => {
    const m = s(l);
    if (!m) return;
    const h = s(f);
    if (h === "__proto__") return;
    const _ = s(d);
    w(m, t)[h] = _;
  }, p = (l, f) => {
    const d = s(l);
    if (!d) return;
    const m = s(f);
    delete w(d, t)[m];
  };
  return n.newFunction("proxyFuncs", (l, ...f) => {
    switch (n.getNumber(l)) {
      case 1:
        return a(f[0]);
      case 2:
        return u(f[0], f[1], f[2]);
      case 3:
        return p(f[0], f[1]);
    }
    return n.undefined;
  }).consume((l) => [
    y(
      n,
      `(target, sym, proxyFuncs) => {
          const rec =  new Proxy(target, {
            get(obj, key, receiver) {
              return key === sym ? obj : Reflect.get(obj, key, receiver)
            },
            set(obj, key, value, receiver) {
              const v = typeof value === "object" && value !== null || typeof value === "function"
                ? value[sym] ?? value
                : value;
              const sync = proxyFuncs(1, receiver) ?? "vm";
              if (sync === "host" || Reflect.set(obj, key, v, receiver)) {
                if (sync !== "vm") {
                  proxyFuncs(2, receiver, key, v);
                }
              }
              return true;
            },
            deleteProperty(obj, key) {
              const sync = proxyFuncs(1, rec) ?? "vm";
              if (sync === "host" || Reflect.deleteProperty(obj, key)) {
                if (sync !== "vm") {
                  proxyFuncs(3, rec, key);
                }
              }
              return true;
            },
          });
          return rec;
        }`,
      void 0,
      e,
      r,
      l
    ),
    !0
  ]);
}
function w(n, e) {
  var t;
  return v(n) && (t = n[e]) != null ? t : n;
}
function j(n, e, t) {
  return F(n, e, t) ? [n.getProp(e, t), !0] : [e, !1];
}
function he(n, e) {
  return v(n) && !!n[e];
}
function F(n, e, t) {
  return !!n.dump(
    y(
      n,
      // promise and date cannot be wrapped
      '(a, s) => (a instanceof Promise) || (a instanceof Date) || (typeof a === "object" && a !== null || typeof a === "function") && !!a[s]',
      void 0,
      e,
      t
    )
  );
}
class ve {
  /** Constructs a new Arena instance. It requires a quickjs-emscripten context initialized with `quickjs.newContext()`. */
  constructor(e, t) {
    c(this, "context");
    c(this, "_map");
    c(this, "_registeredMap");
    c(this, "_registeredMapDispose", /* @__PURE__ */ new Set());
    c(this, "_sync", /* @__PURE__ */ new Set());
    c(this, "_temporalSync", /* @__PURE__ */ new Set());
    c(this, "_symbol", Symbol());
    c(this, "_symbolHandle");
    c(this, "_options");
    c(this, "_isMarshalable", (e) => {
      var r, s;
      const t = (r = this._options) == null ? void 0 : r.isMarshalable;
      return (s = typeof t == "function" ? t(this._unwrap(e)) : t) != null ? s : "json";
    });
    c(this, "_marshalFind", (e) => {
      var s, o, i;
      const t = this._unwrap(e);
      return (i = (o = (s = this._registeredMap.get(e)) != null ? s : t !== e ? this._registeredMap.get(t) : void 0) != null ? o : this._map.get(e)) != null ? i : t !== e ? this._map.get(t) : void 0;
    });
    c(this, "_marshalPre", (e, t, r) => {
      var s;
      if (r !== "json")
        return (s = this._register(e, L(t), this._map)) == null ? void 0 : s[1];
    });
    c(this, "_marshalPreApply", (e, t, r) => {
      const s = v(t) ? this._unwrap(t) : void 0;
      s && this._temporalSync.add(s);
      try {
        return e.apply(t, r);
      } finally {
        s && this._temporalSync.delete(s);
      }
    });
    c(this, "_marshal", (e) => {
      var s, o;
      const t = this._registeredMap.get(e);
      if (t)
        return [t, !1];
      const r = R((s = this._wrap(e)) != null ? s : e, {
        ctx: this.context,
        unmarshal: this._unmarshal,
        isMarshalable: this._isMarshalable,
        find: this._marshalFind,
        pre: this._marshalPre,
        preApply: this._marshalPreApply,
        custom: (o = this._options) == null ? void 0 : o.customMarshaller
      });
      return [r, !this._map.hasHandle(r)];
    });
    c(this, "_preUnmarshal", (e, t) => {
      var r;
      return (r = this._register(e, t, void 0, !0)) == null ? void 0 : r[0];
    });
    c(this, "_unmarshalFind", (e) => {
      var t;
      return (t = this._registeredMap.getByHandle(e)) != null ? t : this._map.getByHandle(e);
    });
    c(this, "_unmarshal", (e) => {
      var s;
      const t = this._registeredMap.getByHandle(e);
      if (typeof t != "undefined")
        return t;
      const [r] = this._wrapHandle(e);
      return le(r != null ? r : e, {
        ctx: this.context,
        marshal: this._marshal,
        find: this._unmarshalFind,
        pre: this._preUnmarshal,
        custom: (s = this._options) == null ? void 0 : s.customUnmarshaller
      });
    });
    c(this, "_syncMode", (e) => {
      const t = this._unwrap(e);
      return this._sync.has(t) || this._temporalSync.has(t) ? "both" : void 0;
    });
    c(this, "_unwrapIfNotSynced", (e) => {
      const t = this._unwrap(e);
      return t instanceof Promise || !this._sync.has(t) ? t : e;
    });
    var r;
    t != null && t.compat && !("runtime" in e) && (e.runtime = {
      hasPendingJob: () => e.hasPendingJob(),
      executePendingJobs: (s) => e.executePendingJobs(s)
    }), this.context = t != null && t.experimentalContextEx ? B(e) : e, this._options = t, this._symbolHandle = e.unwrapResult(e.evalCode("Symbol()")), this._map = new O(e), this._registeredMap = new O(e), this.registerAll((r = t == null ? void 0 : t.registeredObjects) != null ? r : I);
  }
  /**
   * Dispose of the arena and managed handles. This method won't dispose the VM itself, so the VM has to be disposed of manually.
   */
  dispose() {
    var e, t;
    this._map.dispose(), this._registeredMap.dispose(), this._symbolHandle.dispose(), (t = (e = this.context).disposeEx) == null || t.call(e);
  }
  /**
   * Evaluate JS code in the VM and get the result as an object on the host side. It also converts and re-throws error objects when an error is thrown during evaluation.
   */
  evalCode(e) {
    const t = this.context.evalCode(e);
    return this._unwrapResultAndUnmarshal(t);
  }
  /**
   * Evaluate ES module code in the VM and get the module's exports.
   *
   * Requires quickjs-emscripten >= 0.29.0 for export access.
   *
   * @param code - The ES module code to evaluate
   * @param filename - Optional filename for debugging purposes (default: "module.js")
   * @returns The module's exports object, or a Promise resolving to exports if using top-level await
   *
   * @example
   * ```js
   * // Simple module with exports
   * const exports = arena.evalModule(`
   *   export const value = 42;
   *   export function greet(name) {
   *     return "Hello, " + name;
   *   }
   * `);
   * console.log(exports.value); // 42
   * console.log(exports.greet("World")); // "Hello, World"
   *
   * // Module with default export
   * const mod = arena.evalModule('export default function(x) { return x * 2; }');
   * console.log(mod.default(21)); // 42
   *
   * // Module with top-level await
   * const promise = arena.evalModule('export const data = await Promise.resolve(123);');
   * arena.executePendingJobs();
   * const exports = await promise;
   * console.log(exports.data); // 123
   * ```
   */
  evalModule(e, t = "module.js") {
    const r = this.context.evalCode(e, t, { type: "module" });
    return this._unwrapResultAndUnmarshal(r);
  }
  /**
   * Almost same as `vm.executePendingJobs()`, but it converts and re-throws error objects when an error is thrown during evaluation.
   */
  executePendingJobs(e) {
    const t = this.context.runtime.executePendingJobs(e);
    if ("value" in t)
      return t.value;
    throw this._unwrapIfNotSynced(t.error.consume(this._unmarshal));
  }
  /**
   * Set the max memory this runtime can allocate.
   * To remove the limit, set to `-1`.
   *
   * This is useful for preventing runaway memory usage in untrusted code.
   *
   * @param limitBytes - Maximum memory in bytes, or -1 to remove limit
   *
   * @example
   * ```js
   * // Limit sandbox to 10MB
   * arena.setMemoryLimit(10 * 1024 * 1024);
   *
   * try {
   *   arena.evalCode(`const huge = new Array(1000000000);`);
   * } catch (e) {
   *   console.log("Memory limit exceeded");
   * }
   * ```
   */
  setMemoryLimit(e) {
    this.context.runtime.setMemoryLimit(e);
  }
  /**
   * Set the max stack size for this runtime, in bytes.
   * To remove the limit, set to `0`.
   *
   * This is useful for preventing stack overflow from deeply nested calls or recursion.
   *
   * @param stackSize - Maximum stack size in bytes, or 0 to remove limit
   *
   * @example
   * ```js
   * // Limit stack to 512KB
   * arena.setMaxStackSize(512 * 1024);
   *
   * try {
   *   arena.evalCode(`function recurse() { recurse(); } recurse();`);
   * } catch (e) {
   *   console.log("Stack overflow prevented");
   * }
   * ```
   */
  setMaxStackSize(e) {
    this.context.runtime.setMaxStackSize(e);
  }
  /**
   * Get detailed memory usage statistics for this runtime.
   *
   * @returns An object containing detailed memory allocation information
   *
   * @example
   * ```js
   * const stats = arena.getMemoryUsage();
   * console.log(`Memory used: ${stats.memory_used_size} bytes`);
   * console.log(`Object count: ${stats.obj_count}`);
   * console.log(`Memory limit: ${stats.malloc_limit}`);
   * ```
   */
  getMemoryUsage() {
    const e = this.context.runtime.computeMemoryUsage();
    try {
      return this.context.dump(e);
    } finally {
      e.dispose();
    }
  }
  /**
   * Get a human-readable description of memory usage in this runtime.
   *
   * @returns A formatted string showing memory statistics
   *
   * @example
   * ```js
   * console.log(arena.dumpMemoryUsage());
   * // Output:
   * // QuickJS memory usage:
   * //   malloc_limit: 4294967295
   * //   memory_used_size: 67078
   * //   ...
   * ```
   */
  dumpMemoryUsage() {
    return this.context.runtime.dumpMemoryUsage();
  }
  /**
   * Expose objects as global objects in the VM.
   *
   * By default, exposed objects are not synchronized between the host and the VM.
   * If you want to sync an objects, first wrap the object with sync method, and then expose the wrapped object.
   */
  expose(e) {
    for (const [t, r] of Object.entries(e))
      z(this._marshal(r), (s) => {
        this.context.setProp(this.context.global, t, s);
      });
  }
  /**
   * Enables sync for the object between the host and the VM and returns objects wrapped with proxies.
   *
   * The return value is necessary in order to reflect changes to the object from the host to the VM. Please note that setting a value in the field or deleting a field in the original object will not synchronize it.
   */
  sync(e) {
    const t = this._wrap(e);
    return typeof t == "undefined" ? e : (E(t, (r) => {
      const s = this._unwrap(r);
      this._sync.add(s);
    }), t);
  }
  /**
   * Register a pair of objects that will be considered the same between the host and the QuickJS VM.
   *
   * Instead of a string, you can also pass a QuickJSHandle directly. In that case, however, when  you have to dispose them manually when destroying the VM.
   */
  register(e, t) {
    if (this._registeredMap.has(e)) return;
    const r = typeof t == "string" ? this._unwrapResult(this.context.evalCode(t)) : t;
    this.context.sameValue(r, this.context.undefined) || (typeof t == "string" && this._registeredMapDispose.add(e), this._registeredMap.set(e, r));
  }
  /**
   * Execute `register` methods for each pair.
   */
  registerAll(e) {
    for (const [t, r] of e)
      this.register(t, r);
  }
  /**
   * Unregister a pair of objects that were registered with `registeredObjects` option and `register` method.
   */
  unregister(e, t) {
    this._registeredMap.delete(e, this._registeredMapDispose.has(e) || t), this._registeredMapDispose.delete(e);
  }
  /**
   * Execute `unregister` methods for each target.
   */
  unregisterAll(e, t) {
    for (const r of e)
      this.unregister(r, t);
  }
  startSync(e) {
    if (!v(e)) return;
    const t = this._unwrap(e);
    this._sync.add(t);
  }
  endSync(e) {
    this._sync.delete(this._unwrap(e));
  }
  _unwrapResult(e) {
    if ("value" in e)
      return e.value;
    throw this._unwrapIfNotSynced(e.error.consume(this._unmarshal));
  }
  _unwrapResultAndUnmarshal(e) {
    if (e)
      return this._unwrapIfNotSynced(this._unwrapResult(e).consume(this._unmarshal));
  }
  _register(e, t, r = this._map, s) {
    if (this._registeredMap.has(e) || this._registeredMap.hasHandle(t))
      return;
    let o = this._wrap(e);
    const [i] = this._wrapHandle(t), a = e instanceof Promise;
    if (!i || !o && !a) return;
    a && (o = e);
    const u = this._unwrap(e), [p, l] = this._unwrapHandle(t);
    if (r.set(o, i, u, p))
      s && this._sync.add(u);
    else throw l && p.dispose(), new Error("already registered");
    return [o, i];
  }
  _wrap(e) {
    var t;
    return de(
      this.context,
      e,
      this._symbol,
      this._symbolHandle,
      this._marshal,
      this._syncMode,
      (t = this._options) == null ? void 0 : t.isWrappable
    );
  }
  _unwrap(e) {
    return w(e, this._symbol);
  }
  _wrapHandle(e) {
    var t;
    return me(
      this.context,
      e,
      this._symbol,
      this._symbolHandle,
      this._unmarshal,
      this._syncMode,
      (t = this._options) == null ? void 0 : t.isHandleWrappable
    );
  }
  _unwrapHandle(e) {
    return j(this.context, e, this._symbolHandle);
  }
}
export {
  ve as Arena,
  O as VMMap,
  y as call,
  be as complexity,
  _e as consumeAll,
  I as defaultRegisteredObjects,
  Y as isES2015Class,
  J as isHandleObject,
  v as isObject,
  W as json,
  R as marshal,
  le as unmarshal,
  E as walkObject
};
