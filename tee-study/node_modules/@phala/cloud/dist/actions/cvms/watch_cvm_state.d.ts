import { z } from "zod";
import { type Client } from "../../client";
import { type CvmIdInput } from "../../types/cvm_id";
import { type CvmState } from "./get_cvm_state";
/**
 * SSE event data structures
 */
type SSEStateEvent = {
    type: "state";
    data: CvmState;
};
type SSECompleteEvent = {
    type: "complete";
    data: {
        status: string;
        elapsed: number;
        target: string;
    };
};
type SSETimeoutEvent = {
    type: "timeout";
    data: {
        error: string;
        elapsed: number;
        target: string;
    };
};
type SSEErrorEvent = {
    type: "error";
    data: {
        error: string;
        elapsed?: number;
        message?: string;
    };
};
export type SSEEvent = SSEStateEvent | SSECompleteEvent | SSETimeoutEvent | SSEErrorEvent;
/**
 * Watch CVM state request input (before transformation)
 */
export type WatchCvmStateRequest = CvmIdInput & {
    target: string;
    interval?: number;
    timeout?: number;
    maxRetries?: number;
    retryDelay?: number;
};
export declare const WatchCvmStateRequestSchema: z.ZodObject<{
    target: z.ZodString;
    interval: z.ZodDefault<z.ZodNumber>;
    timeout: z.ZodDefault<z.ZodNumber>;
    maxRetries: z.ZodDefault<z.ZodNumber>;
    retryDelay: z.ZodDefault<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    timeout: number;
    retryDelay: number;
    maxRetries: number;
    target: string;
    interval: number;
}, {
    target: string;
    timeout?: number | undefined;
    retryDelay?: number | undefined;
    maxRetries?: number | undefined;
    interval?: number | undefined;
}>;
/**
 * Options for watch operation
 */
export interface WatchCvmStateOptions {
    signal?: AbortSignal;
    onEvent?: (event: SSEEvent) => void;
}
/**
 * Error thrown when watch operation is aborted
 */
export declare class WatchAbortedError extends Error {
    constructor();
}
/**
 * Error thrown when max retries exceeded
 */
export declare class MaxRetriesExceededError extends Error {
    readonly attempts: number;
    constructor(attempts: number);
}
/**
 * Watch CVM state changes using Server-Sent Events (SSE)
 *
 * This action streams state updates from the backend until the target status is reached,
 * timeout occurs, or an error happens. It automatically retries on timeout/error up to
 * maxRetries times, providing unlimited watch capability.
 *
 * Key features:
 * - Streams real-time state updates via SSE
 * - Automatic retry on timeout (backend max 600s, but SDK can retry infinitely)
 * - AbortController support for cancellation
 * - Callback for each SSE event
 * - Resolves with final state when target reached
 *
 * @param client - The API client
 * @param request - Request parameters
 * @param request.id - CVM ID (or use uuid, app_id, instance_id)
 * @param request.target - Target status to wait for (e.g., "running")
 * @param request.interval - Polling interval in seconds (5-30, default: 5)
 * @param request.timeout - Timeout per attempt in seconds (10-600, default: 300)
 * @param request.maxRetries - Max retry attempts (default: Infinity)
 * @param request.retryDelay - Delay between retries in ms (default: 5000)
 * @param options - Optional behavior parameters
 * @param options.signal - AbortSignal for cancellation
 * @param options.onEvent - Callback invoked for each SSE event
 * @returns Promise that resolves with final CVM state when target is reached
 *
 * @throws {WatchAbortedError} If operation is aborted via signal
 * @throws {MaxRetriesExceededError} If max retries exceeded without reaching target
 * @throws {Error} For other unexpected errors
 *
 * @example
 * ```typescript
 * // Basic usage: wait for CVM to reach "running" status
 * const state = await watchCvmState(client, {
 *   id: "cvm-123",
 *   target: "running"
 * })
 * console.log("CVM is now running!")
 *
 * // With event callback and abort controller
 * const controller = new AbortController()
 * try {
 *   const state = await watchCvmState(
 *     client,
 *     {
 *       id: "cvm-123",
 *       target: "running",
 *       interval: 10,
 *       maxRetries: 5
 *     },
 *     {
 *       signal: controller.signal,
 *       onEvent: (event) => {
 *         if (event.type === "state") {
 *           console.log("Current status:", event.data.status)
 *         }
 *       }
 *     }
 *   )
 * } catch (error) {
 *   if (error instanceof WatchAbortedError) {
 *     console.log("Watch cancelled")
 *   }
 * }
 *
 * // Cancel after 30 seconds
 * setTimeout(() => controller.abort(), 30000)
 * ```
 */
export declare function watchCvmState(client: Client, request: WatchCvmStateRequest, options?: WatchCvmStateOptions): Promise<CvmState>;
export {};
