// src/client.ts
import { ofetch } from "ofetch";
import debug from "debug";
import mitt from "mitt";

// src/utils/errors.ts
import { z } from "zod";
var ApiErrorSchema = z.object({
  detail: z.union([
    z.string(),
    z.array(
      z.object({
        msg: z.string(),
        type: z.string().optional(),
        ctx: z.record(z.unknown()).optional(),
        loc: z.array(z.union([z.string(), z.number()])).optional(),
        input: z.unknown().optional()
      }).passthrough()
      // Allow additional fields
    ),
    z.record(z.unknown())
  ]).optional(),
  type: z.string().optional(),
  code: z.string().optional()
});
var PhalaCloudError = class extends Error {
  constructor(message, data) {
    super(message);
    this.name = this.constructor.name;
    this.status = data.status;
    this.statusText = data.statusText;
    this.detail = data.detail;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
};
var RequestError = class _RequestError extends PhalaCloudError {
  constructor(message, options) {
    super(message, {
      status: options?.status ?? 0,
      statusText: options?.statusText ?? "Unknown Error",
      detail: options?.detail || message
    });
    this.name = "RequestError";
    this.isRequestError = true;
    this.data = options?.data;
    this.request = options?.request;
    this.response = options?.response;
    this.code = options?.code;
    this.type = options?.type;
  }
  /**
   * Create RequestError from FetchError
   */
  static fromFetchError(error) {
    const parseResult = ApiErrorSchema.safeParse(error.data);
    if (parseResult.success) {
      return new _RequestError(error.message, {
        status: error.status ?? void 0,
        statusText: error.statusText ?? void 0,
        data: error.data,
        request: error.request ?? void 0,
        response: error.response ?? void 0,
        detail: parseResult.data.detail,
        code: parseResult.data.code ?? void 0,
        type: parseResult.data.type ?? void 0
      });
    }
    return new _RequestError(error.message, {
      status: error.status ?? void 0,
      statusText: error.statusText ?? void 0,
      data: error.data,
      request: error.request ?? void 0,
      response: error.response ?? void 0,
      detail: error.data?.detail || "Unknown API error",
      code: error.status?.toString() ?? void 0
    });
  }
  /**
   * Create RequestError from generic Error
   */
  static fromError(error, request) {
    return new _RequestError(error.message, {
      request: request ?? void 0,
      detail: error.message
    });
  }
};
var ValidationError = class extends PhalaCloudError {
  constructor(message, data) {
    super(message, data);
    this.isValidationError = true;
    this.validationErrors = data.validationErrors;
  }
};
var AuthError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isAuthError = true;
  }
};
var BusinessError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isBusinessError = true;
  }
};
var ServerError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isServerError = true;
  }
};
var UnknownError = class extends PhalaCloudError {
  constructor() {
    super(...arguments);
    this.isUnknownError = true;
  }
};
function extractFieldPath(loc) {
  if (!loc || !Array.isArray(loc)) {
    return "unknown";
  }
  const filtered = loc.filter((part) => {
    if (typeof part === "string") {
      return !["body", "query", "path", "header"].includes(part);
    }
    return true;
  });
  return filtered.length > 0 ? filtered.join(".") : "unknown";
}
function parseValidationErrors(detail) {
  if (!Array.isArray(detail)) {
    return {
      errors: [],
      message: typeof detail === "string" ? detail : "Validation error"
    };
  }
  const errors = detail.map(
    (item, index) => {
      const field = extractFieldPath(item.loc);
      let displayField = field;
      if (field === "unknown" && item.type) {
        displayField = item.type === "missing" ? "required field" : item.type;
      }
      return {
        field: displayField,
        message: item.msg,
        type: item.type,
        context: item.ctx
      };
    }
  );
  const count = errors.length;
  const message = count === 1 ? `Validation failed: ${errors[0].message}` : `Validation failed (${count} issue${count > 1 ? "s" : ""})`;
  return { errors, message };
}
function categorizeErrorType(status) {
  if (status === 422) {
    return "validation";
  }
  if (status === 401) {
    return "auth";
  }
  if (status === 403) {
    return "auth";
  }
  if (status >= 400 && status < 500) {
    return "business";
  }
  if (status >= 500) {
    return "server";
  }
  return "unknown";
}
function extractPrimaryMessage(status, detail, defaultMessage) {
  if (status === 422 && Array.isArray(detail)) {
    const { message } = parseValidationErrors(detail);
    return message;
  }
  if (typeof detail === "string") {
    return detail;
  }
  if (detail && typeof detail === "object" && "message" in detail) {
    const msg = detail.message;
    if (typeof msg === "string") {
      return msg;
    }
  }
  return defaultMessage;
}
function parseApiError(requestError) {
  const status = requestError.status ?? 0;
  const statusText = requestError.statusText ?? "Unknown Error";
  const detail = requestError.detail;
  const structured = parseStructuredError(detail);
  if (structured) {
    return new ResourceError(structured.message, {
      status,
      statusText,
      detail,
      errorCode: structured.error_code,
      structuredDetails: structured.details,
      suggestions: structured.suggestions,
      links: structured.links
    });
  }
  const errorType = categorizeErrorType(status);
  const message = extractPrimaryMessage(status, detail, requestError.message);
  const commonData = { status, statusText, detail };
  if (errorType === "validation" && Array.isArray(detail)) {
    const { errors } = parseValidationErrors(detail);
    return new ValidationError(message, {
      ...commonData,
      validationErrors: errors
    });
  }
  if (errorType === "auth") {
    return new AuthError(message, commonData);
  }
  if (errorType === "business") {
    return new BusinessError(message, commonData);
  }
  if (errorType === "server") {
    return new ServerError(message, commonData);
  }
  return new UnknownError(message, commonData);
}
function getValidationFields(error) {
  if (error instanceof ValidationError) {
    return error.validationErrors.map((e) => e.field);
  }
  return [];
}
function formatValidationErrors(errors, options) {
  const { numbered = true, indent = 2, showFields = true } = options ?? {};
  const indentStr = " ".repeat(indent);
  return errors.map((error, index) => {
    const prefix = numbered ? `${index + 1}. ` : "\u2022 ";
    const field = showFields ? `${error.field}: ` : "";
    return `${indentStr}${prefix}${field}${error.message}`;
  }).join("\n");
}
function formatErrorMessage(error, options) {
  const { showFields = true, showType = false } = options ?? {};
  const parts = [];
  if (showType) {
    parts.push(`[${error.constructor.name.toUpperCase()}]`);
  }
  parts.push(error.message);
  if (error instanceof ValidationError && error.validationErrors.length > 0) {
    parts.push("");
    parts.push(formatValidationErrors(error.validationErrors, { showFields }));
  }
  return parts.join("\n");
}
function getErrorMessage(error) {
  if (typeof error.detail === "string") {
    return error.detail;
  }
  if (Array.isArray(error.detail)) {
    if (error.detail.length > 0) {
      return error.detail[0]?.msg || "Validation error";
    }
    return "Validation error";
  }
  if (typeof error.detail === "object" && error.detail !== null) {
    return JSON.stringify(error.detail);
  }
  return "Unknown error occurred";
}
var ResourceError = class extends BusinessError {
  constructor(message, data) {
    super(message, data);
    this.isResourceError = true;
    this.errorCode = data.errorCode;
    this.structuredDetails = data.structuredDetails;
    this.suggestions = data.suggestions;
    this.links = data.links;
  }
};
function parseStructuredError(detail) {
  if (!detail || typeof detail !== "object") {
    return null;
  }
  const obj = detail;
  if (obj.error_code && typeof obj.error_code === "string" && obj.message && typeof obj.message === "string") {
    return {
      error_code: obj.error_code,
      message: obj.message,
      details: obj.details,
      suggestions: obj.suggestions,
      links: obj.links
    };
  }
  return null;
}
function formatStructuredError(error, options) {
  const { showErrorCode = true, showSuggestions = true, showLinks = true } = options ?? {};
  const parts = [];
  if (showErrorCode && error.errorCode) {
    parts.push(`Error [${error.errorCode}]: ${error.message}`);
  } else {
    parts.push(error.message);
  }
  if (error.structuredDetails && error.structuredDetails.length > 0) {
    parts.push("");
    parts.push("Details:");
    error.structuredDetails.forEach((d) => {
      if (d.message) {
        parts.push(`  - ${d.message}`);
      } else if (d.field && d.value !== void 0) {
        parts.push(`  - ${d.field}: ${d.value}`);
      }
    });
  }
  if (showSuggestions && error.suggestions && error.suggestions.length > 0) {
    parts.push("");
    parts.push("Suggestions:");
    error.suggestions.forEach((s) => {
      parts.push(`  - ${s}`);
    });
  }
  if (showLinks && error.links && error.links.length > 0) {
    parts.push("");
    parts.push("Learn more:");
    error.links.forEach((link) => {
      parts.push(`  - ${link.label}: ${link.url}`);
    });
  }
  return parts.join("\n");
}

// src/client.ts
var SUPPORTED_API_VERSIONS = ["2025-05-31", "2025-10-28"];
var logger = debug("phala::api-client");
function formatHeaders(headers) {
  return Object.entries(headers).map(([key, value]) => `    -H "${key}: ${value}"`).join("\n");
}
function formatBody(body) {
  if (!body) return "";
  const bodyStr = typeof body === "string" ? body : JSON.stringify(body, null, 2);
  return `    -d '${bodyStr.replace(/'/g, "\\'")}'`;
}
function formatResponse(status, statusText, headers, body) {
  const headerEntries = [];
  headers.forEach((value, key) => {
    headerEntries.push(`${key}: ${value}`);
  });
  const headerStr = headerEntries.join("\n");
  const bodyStr = typeof body === "string" ? body : JSON.stringify(body, null, 2);
  return [
    `< HTTP/1.1 ${status} ${statusText}`,
    headerStr ? `< ${headerStr.replace(/\n/g, "\n< ")}` : "",
    "",
    bodyStr
  ].filter(Boolean).join("\n");
}
var Client = class {
  constructor(config = {}) {
    this.emitter = mitt();
    const resolvedConfig = {
      ...config,
      apiKey: config.apiKey || process?.env?.PHALA_CLOUD_API_KEY,
      baseURL: config.baseURL || process?.env?.PHALA_CLOUD_API_PREFIX || "https://cloud-api.phala.network/api/v1"
    };
    const version = resolvedConfig.version && SUPPORTED_API_VERSIONS.includes(resolvedConfig.version) ? resolvedConfig.version : SUPPORTED_API_VERSIONS[SUPPORTED_API_VERSIONS.length - 1];
    this.config = resolvedConfig;
    const { apiKey, baseURL, timeout, headers, useCookieAuth, onResponseError, ...fetchOptions } = resolvedConfig;
    const requestHeaders = {
      "X-Phala-Version": version,
      "Content-Type": "application/json"
    };
    if (headers && typeof headers === "object") {
      Object.entries(headers).forEach(([key, value]) => {
        if (typeof value === "string") {
          requestHeaders[key] = value;
        }
      });
    }
    if (!useCookieAuth && apiKey) {
      requestHeaders["X-API-Key"] = apiKey;
    }
    this.fetchInstance = ofetch.create({
      baseURL,
      timeout: timeout || 3e4,
      headers: requestHeaders,
      ...useCookieAuth ? { credentials: "include" } : {},
      ...fetchOptions,
      // Log request in cURL format
      onRequest({ request, options }) {
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          const fullUrl = url.startsWith("http") ? url : `${baseURL}${url}`;
          const headerObj = {};
          if (options.headers && typeof options.headers === "object") {
            Object.entries(options.headers).forEach(([key, value]) => {
              if (typeof value === "string") {
                headerObj[key] = value;
              }
            });
          }
          const curlCommand = [
            `> curl -X ${method} "${fullUrl}"`,
            formatHeaders(headerObj),
            options.body ? formatBody(options.body) : ""
          ].filter(Boolean).join("\n");
          logger("\n=== REQUEST ===\n%s\n", curlCommand);
        }
      },
      // Log response in cURL format
      onResponse({ request, response, options }) {
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          logger(
            "\n=== RESPONSE [%s %s] (%dms) ===\n%s\n",
            method,
            url,
            response.headers.get("x-response-time") || "?",
            formatResponse(response.status, response.statusText, response.headers, response._data)
          );
        }
      },
      // Generic handlers for response error (similar to request.ts)
      onResponseError: ({ request, response, options }) => {
        console.warn(`HTTP ${response.status}: ${response.url}`);
        if (logger.enabled) {
          const method = options.method || "GET";
          const url = typeof request === "string" ? request : request.url;
          logger(
            "\n=== ERROR RESPONSE [%s %s] ===\n%s\n",
            method,
            url,
            formatResponse(response.status, response.statusText, response.headers, response._data)
          );
        }
        if (onResponseError) {
          onResponseError({ request, response, options });
        }
      }
    });
  }
  /**
   * Get the underlying ofetch instance for advanced usage
   */
  get raw() {
    return this.fetchInstance;
  }
  on(type, handler) {
    this.emitter.on(type, handler);
  }
  off(type, handler) {
    this.emitter.off(type, handler);
  }
  once(type, handler) {
    const wrappedHandler = (event) => {
      handler(event);
      this.emitter.off(type, wrappedHandler);
    };
    this.emitter.on(type, wrappedHandler);
  }
  // ===== Direct methods (throw on error) =====
  /**
   * Perform GET request (throws PhalaCloudError on error)
   */
  async get(request, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "GET"
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform POST request (throws PhalaCloudError on error)
   */
  async post(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "POST",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform PUT request (throws PhalaCloudError on error)
   */
  async put(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "PUT",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform PATCH request (throws PhalaCloudError on error)
   */
  async patch(request, body, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "PATCH",
        body
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  /**
   * Perform DELETE request (throws PhalaCloudError on error)
   */
  async delete(request, options) {
    try {
      return await this.fetchInstance(request, {
        ...options,
        method: "DELETE"
      });
    } catch (error) {
      const requestError = this.convertToRequestError(error);
      const phalaCloudError = this.emitError(requestError);
      throw phalaCloudError;
    }
  }
  // ===== Safe methods (return SafeResult) =====
  /**
   * Convert any error to RequestError
   */
  convertToRequestError(error) {
    if (error && typeof error === "object" && "data" in error) {
      return RequestError.fromFetchError(error);
    }
    if (error instanceof Error) {
      return RequestError.fromError(error);
    }
    return new RequestError("Unknown error occurred", {
      detail: "Unknown error occurred"
    });
  }
  /**
   * Broadcast error to event listeners (fire-and-forget)
   * @param requestError - The request error to handle
   * @returns PhalaCloudError instance to throw immediately
   */
  emitError(requestError) {
    const phalaCloudError = parseApiError(requestError);
    this.emitter.emit("error", phalaCloudError);
    return phalaCloudError;
  }
  /**
   * Safe wrapper for any request method (zod-style result)
   * Returns PhalaCloudError (all errors extend this base class)
   */
  async safeRequest(fn) {
    try {
      const data = await fn();
      return { success: true, data };
    } catch (error) {
      if (error instanceof PhalaCloudError) {
        return { success: false, error };
      }
      const requestError = this.convertToRequestError(error);
      this.emitError(requestError);
      return { success: false, error: requestError };
    }
  }
  /**
   * Safe GET request (returns SafeResult)
   */
  async safeGet(request, options) {
    return this.safeRequest(() => this.get(request, options));
  }
  /**
   * Safe POST request (returns SafeResult)
   */
  async safePost(request, body, options) {
    return this.safeRequest(() => this.post(request, body, options));
  }
  /**
   * Safe PUT request (returns SafeResult)
   */
  async safePut(request, body, options) {
    return this.safeRequest(() => this.put(request, body, options));
  }
  /**
   * Safe PATCH request (returns SafeResult)
   */
  async safePatch(request, body, options) {
    return this.safeRequest(() => this.patch(request, body, options));
  }
  /**
   * Safe DELETE request (returns SafeResult)
   */
  async safeDelete(request, options) {
    return this.safeRequest(() => this.delete(request, options));
  }
  /**
   * Extend client with additional actions
   *
   * @example
   * ```typescript
   * const client = createClient({ apiKey: 'xxx' })
   *   .extend(publicActions)
   *   .extend(cvmActions)
   *
   * await client.getCurrentUser() // Method call instead of function call
   * ```
   */
  extend(actions) {
    const actionsObj = typeof actions === "function" ? actions(this) : actions;
    const extended = Object.create(this);
    for (const [key, action] of Object.entries(actionsObj)) {
      if (typeof action === "function") {
        extended[key] = (...args) => action(this, ...args);
      }
    }
    return extended;
  }
};
function createClient(config = {}) {
  return new Client(config);
}

// src/actions/get_current_user.ts
import { z as z2 } from "zod";

// src/utils/validate-parameters.ts
function validateActionParameters(parameters) {
  if (parameters?.schema !== void 0 && parameters?.schema !== false) {
    if (typeof parameters.schema !== "object" || parameters.schema === null || !("parse" in parameters.schema) || typeof parameters.schema.parse !== "function") {
      throw new Error("Invalid schema: must be a Zod schema object, false, or undefined");
    }
  }
}
function safeValidateActionParameters(parameters) {
  if (parameters?.schema !== void 0 && parameters?.schema !== false) {
    if (typeof parameters.schema !== "object" || parameters.schema === null || !("parse" in parameters.schema) || typeof parameters.schema.parse !== "function") {
      return {
        success: false,
        error: {
          name: "ZodError",
          message: "Invalid schema: must be a Zod schema object, false, or undefined",
          issues: [
            {
              code: "invalid_type",
              expected: "object",
              received: typeof parameters.schema,
              path: ["schema"],
              message: "Invalid schema: must be a Zod schema object, false, or undefined"
            }
          ]
        }
      };
    }
  }
  return void 0;
}

// src/utils/define-action.ts
function defineSimpleAction(schema, fn) {
  function action(client, parameters) {
    return _actionImpl(client, parameters);
  }
  async function _actionImpl(client, parameters) {
    validateActionParameters(parameters);
    const response = await fn(client);
    if (parameters?.schema === false) {
      return response;
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.parse(response);
  }
  function safeAction(client, parameters) {
    return _safeActionImpl(client, parameters);
  }
  async function _safeActionImpl(client, parameters) {
    const parameterValidationError = safeValidateActionParameters(parameters);
    if (parameterValidationError) {
      return parameterValidationError;
    }
    const httpResult = await (async () => {
      try {
        const data = await fn(client);
        return { success: true, data };
      } catch (error) {
        if (error && typeof error === "object" && "status" in error) {
          return { success: false, error };
        }
        if (error && typeof error === "object" && "issues" in error) {
          return { success: false, error };
        }
        return {
          success: false,
          error: {
            name: "Error",
            message: error instanceof Error ? error.message : String(error)
          }
        };
      }
    })();
    if (!httpResult.success) {
      return httpResult;
    }
    if (parameters?.schema === false) {
      return { success: true, data: httpResult.data };
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.safeParse(httpResult.data);
  }
  return {
    action,
    safeAction
  };
}
function defineAction(schema, fn) {
  function action(client, ...args) {
    const [params, parameters] = args;
    return _actionImpl(client, params, parameters);
  }
  async function _actionImpl(client, params, parameters) {
    validateActionParameters(parameters);
    const response = await fn(client, params);
    if (parameters?.schema === false) {
      return response;
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.parse(response);
  }
  function safeAction(client, ...args) {
    const [params, parameters] = args;
    return _safeActionImpl(client, params, parameters);
  }
  async function _safeActionImpl(client, params, parameters) {
    const parameterValidationError = safeValidateActionParameters(parameters);
    if (parameterValidationError) {
      return parameterValidationError;
    }
    const httpResult = await (async () => {
      try {
        const data = await fn(client, params);
        return { success: true, data };
      } catch (error) {
        if (error && typeof error === "object" && "status" in error) {
          return { success: false, error };
        }
        if (error && typeof error === "object" && "issues" in error) {
          return { success: false, error };
        }
        return {
          success: false,
          error: {
            name: "Error",
            message: error instanceof Error ? error.message : String(error)
          }
        };
      }
    })();
    if (!httpResult.success) {
      return httpResult;
    }
    if (parameters?.schema === false) {
      return { success: true, data: httpResult.data };
    }
    const actualSchema = parameters?.schema || schema;
    return actualSchema.safeParse(httpResult.data);
  }
  return {
    action,
    safeAction
  };
}

// src/actions/get_current_user.ts
var CurrentUserSchema = z2.object({
  username: z2.string(),
  email: z2.string(),
  credits: z2.number(),
  granted_credits: z2.number(),
  avatar: z2.string(),
  team_name: z2.string(),
  team_tier: z2.string()
}).passthrough();
var { action: getCurrentUser, safeAction: safeGetCurrentUser } = defineSimpleAction(
  CurrentUserSchema,
  async (client) => {
    return await client.get("/auth/me");
  }
);

// src/actions/get_available_nodes.ts
import { z as z4 } from "zod";

// src/types/kms_info.ts
import { z as z3 } from "zod";

// src/types/supported_chains.ts
import { anvil, base, mainnet } from "viem/chains";
var SUPPORTED_CHAINS = {
  [mainnet.id]: mainnet,
  [base.id]: base,
  [anvil.id]: anvil
};

// src/types/kms_info.ts
var KmsInfoBaseSchema = z3.object({
  id: z3.string(),
  slug: z3.string().nullable(),
  url: z3.string(),
  version: z3.string(),
  chain_id: z3.number().nullable(),
  kms_contract_address: z3.string().nullable().transform((val) => val),
  gateway_app_id: z3.string().nullable().transform((val) => val)
}).passthrough();
var KmsInfoSchema = KmsInfoBaseSchema.transform((data) => {
  if (data.chain_id != null) {
    const chain = SUPPORTED_CHAINS[data.chain_id];
    if (chain) {
      return { ...data, chain };
    }
  }
  return data;
});

// src/actions/get_available_nodes.ts
var AvailableOSImageSchema = z4.object({
  name: z4.string(),
  is_dev: z4.boolean(),
  version: z4.union([
    z4.tuple([z4.number(), z4.number(), z4.number()]),
    z4.tuple([z4.number(), z4.number(), z4.number(), z4.number()])
  ]),
  os_image_hash: z4.string().nullable().optional()
}).passthrough();
var TeepodCapacitySchema = z4.object({
  teepod_id: z4.number(),
  name: z4.string(),
  listed: z4.boolean(),
  resource_score: z4.number(),
  remaining_vcpu: z4.number(),
  remaining_memory: z4.number(),
  remaining_cvm_slots: z4.number(),
  images: z4.array(AvailableOSImageSchema),
  support_onchain_kms: z4.boolean().optional(),
  fmspc: z4.string().nullable().optional(),
  device_id: z4.string().nullable().optional(),
  region_identifier: z4.string().nullable().optional(),
  default_kms: z4.string().nullable().optional(),
  kms_list: z4.array(z4.string()).default([])
}).passthrough();
var ResourceThresholdSchema = z4.object({
  max_instances: z4.number().nullable().optional(),
  max_vcpu: z4.number().nullable().optional(),
  max_memory: z4.number().nullable().optional(),
  max_disk: z4.number().nullable().optional()
}).passthrough();
var AvailableNodesSchema = z4.object({
  tier: z4.string(),
  // TeamTier is string enum
  capacity: ResourceThresholdSchema,
  nodes: z4.array(TeepodCapacitySchema),
  kms_list: z4.array(KmsInfoSchema)
}).passthrough();
var { action: getAvailableNodes, safeAction: safeGetAvailableNodes } = defineSimpleAction(
  AvailableNodesSchema,
  async (client) => {
    return await client.get("/teepods/available");
  }
);

// src/actions/list-instance-types.ts
import { z as z5 } from "zod";
var InstanceTypeSchema = z5.object({
  id: z5.string(),
  name: z5.string(),
  description: z5.string(),
  vcpu: z5.number(),
  memory_mb: z5.number(),
  hourly_rate: z5.string(),
  requires_gpu: z5.boolean(),
  default_disk_size_gb: z5.number().default(20),
  family: z5.string().nullable()
}).passthrough();
var FamilyGroupSchema = z5.object({
  name: z5.string(),
  items: z5.array(InstanceTypeSchema),
  total: z5.number()
}).strict();
var AllFamiliesResponseSchema = z5.object({
  result: z5.array(FamilyGroupSchema)
}).strict();
var FamilyInstanceTypesResponseSchema = z5.object({
  items: z5.array(InstanceTypeSchema),
  total: z5.number(),
  family: z5.string()
}).strict();
var ListFamilyInstanceTypesRequestSchema = z5.object({
  family: z5.string()
}).strict();
var { action: listAllInstanceTypeFamilies, safeAction: safeListAllInstanceTypeFamilies } = defineAction(
  AllFamiliesResponseSchema,
  async (client) => {
    return await client.get("/instance-types");
  }
);
var { action: listFamilyInstanceTypes, safeAction: safeListFamilyInstanceTypes } = defineAction(FamilyInstanceTypesResponseSchema, async (client, request) => {
  const validated = ListFamilyInstanceTypesRequestSchema.parse(request);
  return await client.get(`/instance-types/${validated.family}`);
});

// src/actions/workspaces/list_workspaces.ts
import { z as z6 } from "zod";
var WorkspaceResponseSchema = z6.object({
  id: z6.string(),
  name: z6.string(),
  slug: z6.string().nullable(),
  tier: z6.string(),
  role: z6.string(),
  created_at: z6.string()
}).passthrough();
var PaginationMetadataSchema = z6.object({
  has_more: z6.boolean(),
  next_cursor: z6.string().nullable(),
  total: z6.number().nullable()
}).passthrough();
var ListWorkspacesSchema = z6.object({
  data: z6.array(WorkspaceResponseSchema),
  pagination: PaginationMetadataSchema
}).passthrough();
var { action: listWorkspaces, safeAction: safeListWorkspaces } = defineAction(ListWorkspacesSchema, async (client, request) => {
  const queryParams = new URLSearchParams();
  if (request?.cursor) queryParams.append("cursor", request.cursor);
  if (request?.limit) queryParams.append("limit", request.limit.toString());
  const url = queryParams.toString() ? `/workspaces?${queryParams.toString()}` : "/workspaces";
  return await client.get(url);
});

// src/actions/workspaces/get_workspace.ts
var { action: getWorkspace, safeAction: safeGetWorkspace } = defineAction(WorkspaceResponseSchema, async (client, teamSlug) => {
  return await client.get(`/workspaces/${teamSlug}`);
});

// src/types/cvm_info.ts
import { z as z7 } from "zod";
var VmInfoSchema = z7.object({
  id: z7.string(),
  name: z7.string(),
  status: z7.string(),
  uptime: z7.string(),
  app_url: z7.string().nullable(),
  app_id: z7.string(),
  instance_id: z7.string().nullable(),
  configuration: z7.any().optional(),
  // TODO: add VmConfiguration schema if needed
  exited_at: z7.string().nullable(),
  boot_progress: z7.string().nullable(),
  boot_error: z7.string().nullable(),
  shutdown_progress: z7.string().nullable(),
  image_version: z7.string().nullable()
});
var ManagedUserSchema = z7.object({
  id: z7.number(),
  username: z7.string()
});
var CvmNodeSchema = z7.object({
  id: z7.number(),
  name: z7.string(),
  region_identifier: z7.string().nullable().optional()
});
var CvmNetworkUrlsSchema = z7.object({
  app: z7.string(),
  instance: z7.string()
});
var CvmInfoSchema = z7.object({
  hosted: VmInfoSchema,
  name: z7.string(),
  managed_user: ManagedUserSchema.nullable(),
  node: CvmNodeSchema.nullable(),
  listed: z7.boolean().default(false),
  status: z7.string(),
  in_progress: z7.boolean().default(false),
  dapp_dashboard_url: z7.string().nullable(),
  syslog_endpoint: z7.string().nullable(),
  allow_upgrade: z7.boolean().default(false),
  project_id: z7.string().nullable(),
  // HashedId is represented as string in JS
  project_type: z7.string().nullable(),
  billing_period: z7.string().nullable(),
  kms_info: KmsInfoSchema.nullable(),
  vcpu: z7.number().nullable(),
  memory: z7.number().nullable(),
  disk_size: z7.number().nullable(),
  gateway_domain: z7.string().nullable(),
  public_urls: z7.array(CvmNetworkUrlsSchema)
});
var CvmLegacyDetailSchema = z7.object({
  id: z7.number(),
  name: z7.string(),
  status: z7.string(),
  in_progress: z7.boolean().optional().default(false),
  teepod_id: z7.number().nullable(),
  teepod: CvmNodeSchema.optional().nullable(),
  app_id: z7.string(),
  vm_uuid: z7.string().nullable(),
  instance_id: z7.string().nullable(),
  vcpu: z7.number(),
  memory: z7.number(),
  disk_size: z7.number(),
  base_image: z7.string().nullable(),
  encrypted_env_pubkey: z7.string().nullable(),
  listed: z7.boolean().optional().default(false),
  project_id: z7.string().optional().nullable(),
  project_type: z7.string().optional().nullable(),
  public_sysinfo: z7.boolean().optional().default(false),
  public_logs: z7.boolean().optional().default(false),
  dapp_dashboard_url: z7.string().optional().nullable(),
  syslog_endpoint: z7.string().optional().nullable(),
  kms_info: KmsInfoSchema.optional().nullable(),
  contract_address: z7.string().optional().nullable(),
  deployer_address: z7.string().optional().nullable(),
  scheduled_delete_at: z7.string().optional().nullable(),
  public_urls: z7.array(CvmNetworkUrlsSchema).optional().default([]),
  gateway_domain: z7.string().optional().nullable()
});
var VMSchema = z7.object({
  id: z7.number(),
  name: z7.string(),
  status: z7.string(),
  teepod_id: z7.number(),
  teepod: CvmNodeSchema.optional().nullable(),
  user_id: z7.number().optional().nullable(),
  app_id: z7.string(),
  vm_uuid: z7.string().nullable(),
  instance_id: z7.string().nullable(),
  app_url: z7.string().optional().nullable(),
  base_image: z7.string().nullable(),
  vcpu: z7.number(),
  memory: z7.number(),
  disk_size: z7.number(),
  manifest_version: z7.number().optional().nullable(),
  version: z7.string().optional().nullable(),
  runner: z7.string().optional().nullable(),
  docker_compose_file: z7.string().optional().nullable(),
  features: z7.array(z7.string()).optional().nullable(),
  created_at: z7.string(),
  // datetime serialized as ISO string
  encrypted_env_pubkey: z7.string().nullable()
});

// src/types/cvm_id.ts
import { z as z8 } from "zod";
var CvmIdObjectSchema = z8.object({
  /** Direct CVM ID (any format) */
  id: z8.string().optional(),
  /** UUID format (with or without dashes) */
  uuid: z8.string().regex(
    /^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i,
    "Invalid UUID format"
  ).optional(),
  /** App ID (40 characters, optionally prefixed with 'app_id_') */
  app_id: z8.string().optional(),
  /** Instance ID (40 characters, optionally prefixed with 'instance_') */
  instance_id: z8.string().optional()
});
var refineCvmId = (schema) => schema.refine(
  (data) => {
    const obj = data;
    return !!(obj.id || obj.uuid || obj.app_id || obj.instance_id);
  },
  {
    message: "One of id, uuid, app_id, or instance_id must be provided"
  }
);
var CvmIdBaseSchema = refineCvmId(CvmIdObjectSchema);
var CvmIdSchema = CvmIdBaseSchema.transform((data) => {
  let rawValue;
  if (data.id) {
    rawValue = data.id;
  } else if (data.uuid) {
    rawValue = data.uuid;
  } else if (data.app_id) {
    rawValue = data.app_id;
  } else if (data.instance_id) {
    rawValue = data.instance_id;
  } else {
    throw new Error("No valid identifier provided");
  }
  const uuidRegex = /^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i;
  const appIdRegex = /^[0-9a-f]{40}$/i;
  let cvmId;
  if (uuidRegex.test(rawValue)) {
    cvmId = rawValue.replace(/-/g, "");
  } else if (appIdRegex.test(rawValue)) {
    cvmId = `app_${rawValue}`;
  } else {
    cvmId = rawValue;
  }
  return { cvmId };
});

// src/actions/cvms/get_cvm_info.ts
var GetCvmInfoRequestSchema = CvmIdSchema;
var { action: getCvmInfo, safeAction: safeGetCvmInfo } = defineAction(CvmLegacyDetailSchema, async (client, request) => {
  const { cvmId } = GetCvmInfoRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}`);
});

// src/actions/cvms/get_cvm_list.ts
import { z as z9 } from "zod";
var GetCvmListRequestSchema = z9.object({
  page: z9.number().int().min(1).optional(),
  page_size: z9.number().int().min(1).optional(),
  node_id: z9.number().int().min(1).optional(),
  teepod_id: z9.number().int().min(1).optional(),
  user_id: z9.string().optional()
}).strict();
var GetCvmListSchema = z9.object({
  items: z9.array(CvmInfoSchema),
  total: z9.number(),
  page: z9.number(),
  page_size: z9.number(),
  pages: z9.number()
}).strict();
var { action: getCvmList, safeAction: safeGetCvmList } = defineAction(GetCvmListSchema, async (client, request) => {
  const validatedRequest = GetCvmListRequestSchema.parse(request ?? {});
  return await client.get("/cvms/paginated", { params: validatedRequest });
});

// src/actions/cvms/provision_cvm.ts
import { z as z10 } from "zod";
var ProvisionCvmSchema = z10.object({
  app_id: z10.string().nullable().optional(),
  app_env_encrypt_pubkey: z10.string().nullable().optional(),
  compose_hash: z10.string(),
  fmspc: z10.string().nullable().optional(),
  device_id: z10.string().nullable().optional(),
  os_image_hash: z10.string().nullable().optional(),
  instance_type: z10.string().nullable().optional(),
  teepod_id: z10.number().nullable().optional(),
  // Will be transformed to node_id
  node_id: z10.number().nullable().optional(),
  kms_id: z10.string().nullable().optional()
}).passthrough().transform((data) => {
  if ("teepod_id" in data && data.teepod_id !== void 0) {
    const { teepod_id, ...rest } = data;
    return { ...rest, node_id: teepod_id };
  }
  return data;
});
var ProvisionCvmRequestSchema = z10.object({
  node_id: z10.number().optional(),
  // recommended - optional, system auto-selects if not specified
  teepod_id: z10.number().optional(),
  // deprecated, for compatibility
  region: z10.string().optional(),
  // optional - region filter for auto-selection
  name: z10.string(),
  instance_type: z10.string().default("tdx.small"),
  // defaults to "tdx.small"
  image: z10.string().optional(),
  vcpu: z10.number().optional(),
  memory: z10.number().optional(),
  disk_size: z10.number().optional(),
  compose_file: z10.object({
    allowed_envs: z10.array(z10.string()).optional(),
    pre_launch_script: z10.string().optional(),
    docker_compose_file: z10.string().optional(),
    name: z10.string().optional().default(""),
    // optional with default empty string
    kms_enabled: z10.boolean().optional(),
    public_logs: z10.boolean().optional(),
    public_sysinfo: z10.boolean().optional(),
    gateway_enabled: z10.boolean().optional(),
    // recommended
    tproxy_enabled: z10.boolean().optional()
    // deprecated, for compatibility
  }),
  listed: z10.boolean().optional(),
  kms_id: z10.string().optional(),
  kms: z10.enum(["PHALA", "ETHEREUM", "BASE"]).optional(),
  // KMS type selection (defaults to PHALA)
  kms_contract: z10.string().optional(),
  // KMS contract address for on-chain KMS
  env_keys: z10.array(z10.string()).optional(),
  // Manual nonce specification (Advanced - PHALA KMS only)
  nonce: z10.number().optional(),
  // User-specified nonce for deterministic app_id generation
  app_id: z10.string().optional()
  // Expected app_id (must match calculated app_id from nonce)
}).passthrough();
function handleGatewayCompatibility(appCompose) {
  if (!appCompose.compose_file) {
    return appCompose;
  }
  const composeFile = { ...appCompose.compose_file };
  if (typeof composeFile.gateway_enabled === "boolean" && typeof composeFile.tproxy_enabled === "boolean") {
    delete composeFile.tproxy_enabled;
  } else if (typeof composeFile.tproxy_enabled === "boolean" && typeof composeFile.gateway_enabled === "undefined") {
    composeFile.gateway_enabled = composeFile.tproxy_enabled;
    delete composeFile.tproxy_enabled;
    if (typeof window !== "undefined" ? window.console : globalThis.console) {
      console.warn(
        "[phala/cloud] tproxy_enabled is deprecated, please use gateway_enabled instead. See docs for migration."
      );
    }
  }
  return {
    ...appCompose,
    compose_file: composeFile
  };
}
var { action: provisionCvm, safeAction: safeProvisionCvm } = defineAction(ProvisionCvmSchema, async (client, appCompose) => {
  const validated = ProvisionCvmRequestSchema.parse(appCompose);
  const body = handleGatewayCompatibility(validated);
  let requestBody = { ...body };
  if (typeof body.node_id === "number") {
    requestBody = { ...body, teepod_id: body.node_id };
    delete requestBody.node_id;
  } else if (typeof body.teepod_id === "number") {
    console.warn("[phala/cloud] teepod_id is deprecated, please use node_id instead.");
  }
  return await client.post("/cvms/provision", requestBody);
});

// src/actions/cvms/commit_cvm_provision.ts
import { z as z11 } from "zod";
var CommitCvmProvisionSchema = z11.object({
  id: z11.number(),
  name: z11.string(),
  status: z11.string(),
  teepod_id: z11.number(),
  teepod: z11.object({
    id: z11.number(),
    name: z11.string()
  }).nullable(),
  user_id: z11.number().nullable(),
  app_id: z11.string().nullable(),
  vm_uuid: z11.string().nullable(),
  instance_id: z11.string().nullable(),
  app_url: z11.string().nullable(),
  base_image: z11.string().nullable(),
  vcpu: z11.number(),
  memory: z11.number(),
  disk_size: z11.number(),
  manifest_version: z11.number().nullable(),
  version: z11.string().nullable(),
  runner: z11.string().nullable(),
  docker_compose_file: z11.string().nullable(),
  features: z11.array(z11.string()).nullable(),
  created_at: z11.string(),
  encrypted_env_pubkey: z11.string().nullable().optional(),
  app_auth_contract_address: z11.string().nullable().optional(),
  deployer_address: z11.string().nullable().optional()
}).passthrough();
var CommitCvmProvisionRequestSchema = z11.object({
  encrypted_env: z11.string().optional().nullable(),
  app_id: z11.string(),
  compose_hash: z11.string(),
  kms_id: z11.string().optional(),
  contract_address: z11.string().optional(),
  deployer_address: z11.string().optional(),
  env_keys: z11.array(z11.string()).optional().nullable()
}).passthrough();
var { action: commitCvmProvision, safeAction: safeCommitCvmProvision } = defineAction(CommitCvmProvisionSchema, async (client, payload) => {
  return await client.post("/cvms", payload);
});

// src/types/app_compose.ts
import { z as z12 } from "zod";
var LooseAppComposeSchema = z12.object({
  allowed_envs: z12.array(z12.string()).optional(),
  docker_compose_file: z12.string(),
  features: z12.array(z12.string()).optional(),
  name: z12.string().optional(),
  manifest_version: z12.number().optional(),
  kms_enabled: z12.boolean().optional(),
  public_logs: z12.boolean().optional(),
  public_sysinfo: z12.boolean().optional(),
  tproxy_enabled: z12.boolean().optional(),
  pre_launch_script: z12.string().optional(),
  env_pubkey: z12.string().optional(),
  salt: z12.string().optional().nullable()
}).passthrough();

// src/utils/get_compose_hash.ts
import crypto from "crypto";
function sortObject(obj) {
  if (obj === void 0 || obj === null) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map(sortObject);
  } else if (obj && typeof obj === "object" && obj.constructor === Object) {
    return Object.keys(obj).sort().reduce((result, key) => {
      const value = obj[key];
      result[key] = sortObject(value);
      return result;
    }, {});
  }
  return obj;
}
function preprocessAppCompose(dic) {
  const obj = { ...dic };
  if (obj.runner === "bash" && "docker_compose_file" in obj) {
    delete obj.docker_compose_file;
  } else if (obj.runner === "docker-compose" && "bash_script" in obj) {
    delete obj.bash_script;
  }
  if ("pre_launch_script" in obj && !obj.pre_launch_script) {
    delete obj.pre_launch_script;
  }
  return obj;
}
function dumpAppCompose(dic) {
  const ordered = sortObject(dic);
  let json = JSON.stringify(ordered, null, 4);
  json = json.replace(/": /g, '":');
  return json;
}
function getComposeHash(app_compose) {
  const preprocessed = preprocessAppCompose(app_compose);
  const manifest_str = dumpAppCompose(preprocessed);
  return crypto.createHash("sha256").update(manifest_str, "utf8").digest("hex");
}
function withComposeMethods(compose) {
  const appCompose = compose;
  return {
    ...compose,
    getHash: () => getComposeHash(appCompose),
    toString: () => dumpAppCompose(preprocessAppCompose(appCompose))
  };
}

// src/actions/cvms/get_cvm_compose_file.ts
var GetCvmComposeFileResultSchema = LooseAppComposeSchema.transform(
  (data) => withComposeMethods(data)
);
var GetCvmComposeFileRequestSchema = CvmIdSchema;
var { action: getCvmComposeFile, safeAction: safeGetCvmComposeFile } = defineAction(GetCvmComposeFileResultSchema, async (client, request) => {
  const { cvmId } = GetCvmComposeFileRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/compose_file`);
});

// src/actions/cvms/provision_cvm_compose_file_update.ts
import { z as z13 } from "zod";
var ProvisionCvmComposeFileUpdateRequestSchema = z13.object({
  id: z13.string().optional(),
  uuid: z13.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: z13.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: z13.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  app_compose: LooseAppComposeSchema,
  update_env_vars: z13.boolean().optional().nullable()
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => {
  return {
    cvmId: data.id || data.uuid || data.app_id || data.instance_id,
    request: { ...data.app_compose, update_env_vars: data.update_env_vars },
    _raw: data
  };
});
var ProvisionCvmComposeFileUpdateResultSchema = z13.object({
  app_id: z13.string().nullable(),
  device_id: z13.string().nullable(),
  compose_hash: z13.string(),
  kms_info: KmsInfoSchema.nullable().optional()
}).passthrough();
var { action: provisionCvmComposeFileUpdate, safeAction: safeProvisionCvmComposeFileUpdate } = defineAction(ProvisionCvmComposeFileUpdateResultSchema, async (client, request) => {
  const validatedRequest = ProvisionCvmComposeFileUpdateRequestSchema.parse(request);
  return await client.post(
    `/cvms/${validatedRequest.cvmId}/compose_file/provision`,
    validatedRequest.request
  );
});

// src/actions/cvms/commit_cvm_compose_file_update.ts
import { z as z14 } from "zod";
var CommitCvmComposeFileUpdateRequestSchema = z14.object({
  id: z14.string().optional(),
  uuid: z14.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: z14.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: z14.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  compose_hash: z14.string().min(1, "Compose hash is required"),
  encrypted_env: z14.string().optional(),
  env_keys: z14.array(z14.string()).optional(),
  update_env_vars: z14.boolean().optional().nullable()
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => ({
  cvmId: data.id || data.uuid || data.app_id || data.instance_id,
  compose_hash: data.compose_hash,
  encrypted_env: data.encrypted_env,
  env_keys: data.env_keys,
  update_env_vars: !!data.update_env_vars,
  _raw: data
}));
var CommitCvmComposeFileUpdateSchema = z14.any().transform(() => void 0);
var { action: commitCvmComposeFileUpdate, safeAction: safeCommitCvmComposeFileUpdate } = defineAction(
  CommitCvmComposeFileUpdateSchema,
  async (client, request) => {
    const validatedRequest = CommitCvmComposeFileUpdateRequestSchema.parse(request);
    return await client.patch(`/cvms/${validatedRequest.cvmId}/compose_file`, {
      compose_hash: validatedRequest.compose_hash,
      encrypted_env: validatedRequest.encrypted_env,
      env_keys: validatedRequest.env_keys
    });
  }
);

// src/actions/cvms/update_cvm_envs.ts
import { z as z15 } from "zod";
var UpdateCvmEnvsRequestSchema = z15.object({
  id: z15.string().optional(),
  uuid: z15.string().regex(/^[0-9a-f]{8}[-]?[0-9a-f]{4}[-]?4[0-9a-f]{3}[-]?[89ab][0-9a-f]{3}[-]?[0-9a-f]{12}$/i).optional(),
  app_id: z15.string().refine(
    (val) => !val.startsWith("app_") && val.length === 40,
    "app_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("app_") ? val : `app_${val}`).optional(),
  instance_id: z15.string().refine(
    (val) => !val.startsWith("instance_") && val.length === 40,
    "instance_id should be 40 characters without prefix"
  ).transform((val) => val.startsWith("instance_") ? val : `instance_${val}`).optional(),
  encrypted_env: z15.string().describe("Encrypted environment variables (hex string)"),
  env_keys: z15.array(z15.string()).optional().describe("List of allowed environment variable keys"),
  compose_hash: z15.string().optional().describe("Compose hash for verification (Phase 2, required when env_keys changes)"),
  transaction_hash: z15.string().optional().describe(
    "On-chain transaction hash for verification (Phase 2, required when env_keys changes)"
  )
}).refine(
  (data) => !!(data.id || data.uuid || data.app_id || data.instance_id),
  "One of id, uuid, app_id, or instance_id must be provided"
).transform((data) => {
  return {
    cvmId: data.id || data.uuid || data.app_id || data.instance_id,
    request: {
      encrypted_env: data.encrypted_env,
      env_keys: data.env_keys,
      compose_hash: data.compose_hash,
      transaction_hash: data.transaction_hash
    },
    _raw: data
  };
});
var UpdateCvmEnvsInProgressSchema = z15.object({
  status: z15.literal("in_progress"),
  message: z15.string(),
  correlation_id: z15.string(),
  allowed_envs_changed: z15.boolean()
});
var UpdateCvmEnvsPreconditionRequiredSchema = z15.object({
  status: z15.literal("precondition_required"),
  message: z15.string(),
  compose_hash: z15.string(),
  app_id: z15.string(),
  device_id: z15.string(),
  kms_info: KmsInfoSchema
});
var UpdateCvmEnvsResultSchema = z15.union([
  UpdateCvmEnvsInProgressSchema,
  UpdateCvmEnvsPreconditionRequiredSchema
]);
var { action: updateCvmEnvs, safeAction: safeUpdateCvmEnvs } = defineAction(UpdateCvmEnvsResultSchema, async (client, request) => {
  const validatedRequest = UpdateCvmEnvsRequestSchema.parse(request);
  try {
    const response = await client.patch(
      `/cvms/${validatedRequest.cvmId}/envs`,
      validatedRequest.request
    );
    return response;
  } catch (error) {
    if (error instanceof PhalaCloudError && error.status === 428) {
      const detail = error.detail;
      if (detail && typeof detail === "object") {
        const detailObj = detail;
        return {
          status: "precondition_required",
          message: detailObj.message || "Compose hash verification required",
          compose_hash: detailObj.compose_hash,
          app_id: detailObj.app_id,
          device_id: detailObj.device_id,
          kms_info: detailObj.kms_info
        };
      }
    }
    throw error;
  }
});

// src/actions/kms/get_kms_info.ts
import { z as z16 } from "zod";
var GetKmsInfoRequestSchema = z16.object({
  kms_id: z16.string().min(1, "KMS ID is required")
});
var { action: getKmsInfo, safeAction: safeGetKmsInfo } = defineAction(KmsInfoSchema, async (client, request) => {
  const validatedRequest = GetKmsInfoRequestSchema.parse(request);
  return await client.get(`/kms/${validatedRequest.kms_id}`);
});

// src/actions/kms/get_kms_list.ts
import { z as z17 } from "zod";
var GetKmsListRequestSchema = z17.object({
  page: z17.number().int().min(1).optional(),
  page_size: z17.number().int().min(1).optional(),
  is_onchain: z17.boolean().optional()
}).strict();
var GetKmsListSchema = z17.object({
  items: z17.array(KmsInfoSchema),
  total: z17.number(),
  page: z17.number(),
  page_size: z17.number(),
  pages: z17.number()
}).strict();
var { action: getKmsList, safeAction: safeGetKmsList } = defineAction(GetKmsListSchema, async (client, request) => {
  const validatedRequest = GetKmsListRequestSchema.parse(request ?? {});
  return await client.get("/kms", { params: validatedRequest });
});

// src/actions/kms/get_app_env_encrypt_pubkey.ts
import { z as z18 } from "zod";
var GetAppEnvEncryptPubKeyRequestSchema = z18.object({
  kms: z18.string().min(1, "KMS ID or slug is required"),
  app_id: z18.string().refine(
    (val) => val.length === 40 || val.startsWith("0x") && val.length === 42,
    "App ID must be exactly 40 characters or 42 characters with 0x prefix"
  )
}).strict();
var GetAppEnvEncryptPubKeySchema = z18.object({
  public_key: z18.string(),
  signature: z18.string()
}).strict();
var { action: getAppEnvEncryptPubKey, safeAction: safeGetAppEnvEncryptPubKey } = defineAction(GetAppEnvEncryptPubKeySchema, async (client, payload) => {
  const validatedRequest = GetAppEnvEncryptPubKeyRequestSchema.parse(payload);
  return await client.get(`/kms/${validatedRequest.kms}/pubkey/${validatedRequest.app_id}`);
});

// src/actions/kms/next_app_ids.ts
import { z as z19 } from "zod";
var NextAppIdsRequestSchema = z19.object({
  counts: z19.number().int().min(1).max(20).optional().default(1)
}).strict();
var NextAppIdsSchema = z19.object({
  app_ids: z19.array(
    z19.object({
      app_id: z19.string(),
      nonce: z19.number().int().min(0)
    })
  )
}).strict();
var { action: nextAppIds, safeAction: safeNextAppIds } = defineAction(NextAppIdsSchema, async (client, payload) => {
  const validatedRequest = NextAppIdsRequestSchema.parse(payload ?? {});
  const params = new URLSearchParams();
  params.append("counts", validatedRequest.counts.toString());
  return await client.get(`/kms/phala/next_app_id?${params.toString()}`);
});

// src/actions/cvms/start_cvm.ts
var StartCvmRequestSchema = CvmIdSchema;
var { action: startCvm, safeAction: safeStartCvm } = defineAction(VMSchema, async (client, request) => {
  const { cvmId } = StartCvmRequestSchema.parse(request);
  return await client.post(`/cvms/${cvmId}/start`);
});

// src/actions/cvms/stop_cvm.ts
var StopCvmRequestSchema = CvmIdSchema;
var { action: stopCvm, safeAction: safeStopCvm } = defineAction(
  VMSchema,
  async (client, request) => {
    const { cvmId } = StopCvmRequestSchema.parse(request);
    return await client.post(`/cvms/${cvmId}/stop`);
  }
);

// src/actions/cvms/shutdown_cvm.ts
var ShutdownCvmRequestSchema = CvmIdSchema;
var { action: shutdownCvm, safeAction: safeShutdownCvm } = defineAction(VMSchema, async (client, request) => {
  const { cvmId } = ShutdownCvmRequestSchema.parse(request);
  return await client.post(`/cvms/${cvmId}/shutdown`);
});

// src/actions/cvms/restart_cvm.ts
import { z as z20 } from "zod";
var RestartCvmRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    force: z20.boolean().optional()
  })
);
var { action: restartCvm, safeAction: safeRestartCvm } = defineAction(VMSchema, async (client, request) => {
  const parsed = RestartCvmRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { force = false } = parsed;
  return await client.post(`/cvms/${cvmId}/restart`, { force });
});

// src/actions/cvms/delete_cvm.ts
import { z as z21 } from "zod";
var DeleteCvmRequestSchema = CvmIdSchema;
var { action: deleteCvm, safeAction: safeDeleteCvm } = defineAction(
  z21.void(),
  async (client, request) => {
    const { cvmId } = DeleteCvmRequestSchema.parse(request);
    await client.delete(`/cvms/${cvmId}`);
    return void 0;
  }
);

// src/actions/cvms/get_cvm_stats.ts
import { z as z22 } from "zod";
var DiskInfoSchema = z22.object({
  name: z22.string(),
  mount_point: z22.string(),
  total_size: z22.number(),
  free_size: z22.number()
});
var SystemInfoSchema = z22.object({
  os_name: z22.string(),
  os_version: z22.string(),
  kernel_version: z22.string(),
  cpu_model: z22.string(),
  num_cpus: z22.number(),
  total_memory: z22.number(),
  available_memory: z22.number(),
  used_memory: z22.number(),
  free_memory: z22.number(),
  total_swap: z22.number(),
  used_swap: z22.number(),
  free_swap: z22.number(),
  uptime: z22.number(),
  loadavg_one: z22.number(),
  loadavg_five: z22.number(),
  loadavg_fifteen: z22.number(),
  disks: z22.array(DiskInfoSchema)
});
var CvmSystemInfoSchema = z22.object({
  is_online: z22.boolean(),
  is_public: z22.boolean().default(false),
  error: z22.string().nullable(),
  sysinfo: SystemInfoSchema.nullable(),
  status: z22.string().nullable(),
  in_progress: z22.boolean().default(false),
  boot_progress: z22.string().nullable(),
  boot_error: z22.string().nullable()
});
var GetCvmStatsRequestSchema = CvmIdSchema;
var { action: getCvmStats, safeAction: safeGetCvmStats } = defineAction(CvmSystemInfoSchema, async (client, request) => {
  const { cvmId } = GetCvmStatsRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/stats`);
});

// src/actions/cvms/get_cvm_network.ts
import { z as z23 } from "zod";
var CvmNetworkUrlsSchema2 = z23.object({
  app: z23.string(),
  instance: z23.string()
});
var CvmNetworkSchema = z23.object({
  is_online: z23.boolean(),
  is_public: z23.boolean().default(true),
  error: z23.string().nullable(),
  internal_ip: z23.string().nullable(),
  latest_handshake: z23.string().nullable(),
  public_urls: z23.array(CvmNetworkUrlsSchema2).nullable()
});
var GetCvmNetworkRequestSchema = CvmIdSchema;
var { action: getCvmNetwork, safeAction: safeGetCvmNetwork } = defineAction(CvmNetworkSchema, async (client, request) => {
  const { cvmId } = GetCvmNetworkRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/network`);
});

// src/actions/cvms/get_cvm_docker_compose.ts
import { z as z24 } from "zod";
var GetCvmDockerComposeRequestSchema = CvmIdSchema;
var { action: getCvmDockerCompose, safeAction: safeGetCvmDockerCompose } = defineAction(z24.string(), async (client, request) => {
  const { cvmId } = GetCvmDockerComposeRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/docker-compose.yml`);
});

// src/actions/cvms/get_cvm_containers_stats.ts
import { z as z25 } from "zod";
var ContainerInfoSchema = z25.object({
  id: z25.string(),
  names: z25.array(z25.string()),
  image: z25.string(),
  image_id: z25.string(),
  command: z25.string().nullable().optional(),
  created: z25.number(),
  state: z25.string(),
  status: z25.string(),
  log_endpoint: z25.string().nullable()
});
var CvmContainersStatsSchema = z25.object({
  is_online: z25.boolean(),
  is_public: z25.boolean().default(true),
  error: z25.string().nullable(),
  docker_compose_file: z25.string().nullable(),
  manifest_version: z25.number().nullable(),
  version: z25.string().nullable(),
  runner: z25.string().nullable(),
  features: z25.array(z25.string()).nullable(),
  containers: z25.array(ContainerInfoSchema).nullable()
});
var GetCvmContainersStatsRequestSchema = CvmIdSchema;
var { action: getCvmContainersStats, safeAction: safeGetCvmContainersStats } = defineAction(CvmContainersStatsSchema, async (client, request) => {
  const { cvmId } = GetCvmContainersStatsRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/composition`);
});

// src/actions/cvms/get_cvm_attestation.ts
import { z as z26 } from "zod";
var CertificateSubjectSchema = z26.object({
  common_name: z26.string().nullable(),
  organization: z26.string().nullable(),
  country: z26.string().nullable(),
  state: z26.string().nullable(),
  locality: z26.string().nullable()
});
var CertificateIssuerSchema = z26.object({
  common_name: z26.string().nullable(),
  organization: z26.string().nullable(),
  country: z26.string().nullable()
});
var CertificateSchema = z26.object({
  subject: CertificateSubjectSchema,
  issuer: CertificateIssuerSchema,
  serial_number: z26.string(),
  not_before: z26.string(),
  // datetime serialized as ISO string
  not_after: z26.string(),
  // datetime serialized as ISO string
  version: z26.string(),
  fingerprint: z26.string(),
  signature_algorithm: z26.string(),
  sans: z26.array(z26.string()).nullable(),
  is_ca: z26.boolean(),
  position_in_chain: z26.number().nullable(),
  quote: z26.string().nullable(),
  app_id: z26.string().nullable().optional(),
  cert_usage: z26.string().nullable().optional()
});
var EventLogSchema = z26.object({
  imr: z26.number(),
  event_type: z26.number(),
  digest: z26.string(),
  event: z26.string(),
  event_payload: z26.string()
});
var TcbInfoSchema = z26.object({
  mrtd: z26.string(),
  rootfs_hash: z26.string().nullable().optional(),
  rtmr0: z26.string(),
  rtmr1: z26.string(),
  rtmr2: z26.string(),
  rtmr3: z26.string(),
  event_log: z26.array(EventLogSchema),
  app_compose: z26.string()
});
var CvmAttestationSchema = z26.object({
  name: z26.string().nullable(),
  is_online: z26.boolean(),
  is_public: z26.boolean().default(true),
  error: z26.string().nullable(),
  app_certificates: z26.array(CertificateSchema).nullable(),
  tcb_info: TcbInfoSchema.nullable(),
  compose_file: z26.string().nullable()
});
var GetCvmAttestationRequestSchema = CvmIdSchema;
var { action: getCvmAttestation, safeAction: safeGetCvmAttestation } = defineAction(CvmAttestationSchema, async (client, request) => {
  const { cvmId } = GetCvmAttestationRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/attestation`);
});

// src/actions/cvms/update_cvm_resources.ts
import { z as z27 } from "zod";
var UpdateCvmResourcesRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    vcpu: z27.number().optional(),
    memory: z27.number().optional(),
    disk_size: z27.number().optional(),
    instance_type: z27.string().optional(),
    allow_restart: z27.boolean().optional()
  })
);
var { action: updateCvmResources, safeAction: safeUpdateCvmResources } = defineAction(z27.void(), async (client, request) => {
  const parsed = UpdateCvmResourcesRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { ...body } = parsed;
  await client.patch(`/cvms/${cvmId}/resources`, body);
  return void 0;
});

// src/actions/cvms/update_cvm_visibility.ts
import { z as z28 } from "zod";
var UpdateCvmVisibilityRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    public_sysinfo: z28.boolean(),
    public_logs: z28.boolean()
  })
);
var { action: updateCvmVisibility, safeAction: safeUpdateCvmVisibility } = defineAction(CvmLegacyDetailSchema, async (client, request) => {
  const parsed = UpdateCvmVisibilityRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { public_sysinfo, public_logs } = parsed;
  return await client.patch(`/cvms/${cvmId}/visibility`, { public_sysinfo, public_logs });
});

// src/actions/cvms/get_available_os_images.ts
import { z as z29 } from "zod";
var OSImageVariantSchema = z29.object({
  name: z29.string(),
  os_image_hash: z29.string().nullable(),
  is_current: z29.boolean()
});
var AvailableOSImageSchema2 = z29.object({
  version: z29.union([
    z29.tuple([z29.number(), z29.number(), z29.number(), z29.number()]),
    z29.tuple([z29.number(), z29.number(), z29.number()])
  ]),
  prod: OSImageVariantSchema.nullable(),
  dev: OSImageVariantSchema.nullable()
});
var GetAvailableOSImagesResponseSchema = z29.array(AvailableOSImageSchema2);
var GetAvailableOSImagesRequestSchema = CvmIdSchema;
var { action: getAvailableOsImages, safeAction: safeGetAvailableOsImages } = defineAction(GetAvailableOSImagesResponseSchema, async (client, request) => {
  const { cvmId } = GetAvailableOSImagesRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/available-os-images`);
});

// src/actions/cvms/update_os_image.ts
import { z as z30 } from "zod";
var UpdateOsImageRequestSchema = refineCvmId(
  CvmIdObjectSchema.extend({
    os_image_name: z30.string().min(1, "OS image name is required")
  })
);
var { action: updateOsImage, safeAction: safeUpdateOsImage } = defineAction(z30.void(), async (client, request) => {
  const parsed = UpdateOsImageRequestSchema.parse(request);
  const { cvmId } = CvmIdSchema.parse(parsed);
  const { os_image_name } = parsed;
  await client.patch(`/cvms/${cvmId}/os-image`, { os_image_name });
  return void 0;
});

// src/actions/cvms/get_cvm_state.ts
import { z as z31 } from "zod";
var CvmStateSchema = z31.object({
  id: z31.string().optional(),
  instance_id: z31.string().optional(),
  name: z31.string(),
  status: z31.string(),
  uptime: z31.string().optional(),
  exited_at: z31.string().optional(),
  boot_progress: z31.string().optional(),
  boot_error: z31.string().optional(),
  shutdown_progress: z31.string().optional()
});
var GetCvmStateRequestSchema = CvmIdSchema;
var { action: getCvmState, safeAction: safeGetCvmState } = defineAction(CvmStateSchema, async (client, request) => {
  const { cvmId } = GetCvmStateRequestSchema.parse(request);
  return await client.get(`/cvms/${cvmId}/state`);
});

// src/create-client.ts
function createClient2(config = {}) {
  const client = createClient(config);
  const allActions = {
    getCurrentUser,
    safeGetCurrentUser,
    getAvailableNodes,
    safeGetAvailableNodes,
    listAllInstanceTypeFamilies,
    safeListAllInstanceTypeFamilies,
    listFamilyInstanceTypes,
    safeListFamilyInstanceTypes,
    listWorkspaces,
    safeListWorkspaces,
    getWorkspace,
    safeGetWorkspace,
    getCvmInfo,
    safeGetCvmInfo,
    getCvmList,
    safeGetCvmList,
    provisionCvm,
    safeProvisionCvm,
    commitCvmProvision,
    safeCommitCvmProvision,
    getCvmComposeFile,
    safeGetCvmComposeFile,
    provisionCvmComposeFileUpdate,
    safeProvisionCvmComposeFileUpdate,
    commitCvmComposeFileUpdate,
    safeCommitCvmComposeFileUpdate,
    updateCvmEnvs,
    safeUpdateCvmEnvs,
    startCvm,
    safeStartCvm,
    stopCvm,
    safeStopCvm,
    shutdownCvm,
    safeShutdownCvm,
    restartCvm,
    safeRestartCvm,
    deleteCvm,
    safeDeleteCvm,
    getCvmStats,
    safeGetCvmStats,
    getCvmNetwork,
    safeGetCvmNetwork,
    getCvmDockerCompose,
    safeGetCvmDockerCompose,
    getCvmContainersStats,
    safeGetCvmContainersStats,
    getCvmAttestation,
    safeGetCvmAttestation,
    updateCvmResources,
    safeUpdateCvmResources,
    updateCvmVisibility,
    safeUpdateCvmVisibility,
    getAvailableOsImages,
    safeGetAvailableOsImages,
    updateOsImage,
    safeUpdateOsImage,
    getKmsInfo,
    safeGetKmsInfo,
    getKmsList,
    safeGetKmsList,
    getAppEnvEncryptPubKey,
    safeGetAppEnvEncryptPubKey,
    nextAppIds,
    safeNextAppIds,
    getCvmState,
    safeGetCvmState
  };
  return client.extend(allActions);
}

// src/actions/blockchains/deploy_app_auth.ts
import { z as z32 } from "zod";
import {
  createPublicClient as createPublicClient2,
  createWalletClient as createWalletClient2,
  http as http2,
  parseEventLogs,
  parseEther
} from "viem";
import { privateKeyToAccount as privateKeyToAccount2 } from "viem/accounts";

// src/utils/index.ts
import { encryptEnvVars } from "@phala/dstack-sdk/encrypt-env-vars";

// src/utils/as-hex.ts
import { isHex } from "viem";
function asHex(value) {
  if (typeof value === "string") {
    if (value.startsWith("0x") && isHex(value)) {
      return value;
    } else if (isHex(`0x${value}`)) {
      return `0x${value}`;
    }
  }
  throw new Error(`Invalid hex value: ${value}`);
}

// src/utils/network.ts
var NetworkError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "NetworkError";
  }
};
var WalletError = class extends Error {
  constructor(message, code, details) {
    super(message);
    this.code = code;
    this.details = details;
    this.name = "WalletError";
  }
};
var TransactionError = class extends Error {
  constructor(message, hash, details) {
    super(message);
    this.hash = hash;
    this.details = details;
    this.name = "TransactionError";
  }
};
function createNetworkClients(publicClient, walletClient, address, chainId) {
  return {
    publicClient,
    walletClient,
    address,
    chainId
  };
}
async function checkNetworkStatus(clients, targetChainId) {
  try {
    const currentChainId = await clients.walletClient.getChainId();
    return {
      isCorrectNetwork: currentChainId === targetChainId,
      currentChainId
    };
  } catch (error) {
    throw new NetworkError(
      `Failed to check network status: ${error instanceof Error ? error.message : "Unknown error"}`,
      "NETWORK_CHECK_FAILED",
      error
    );
  }
}
async function checkBalance(publicClient, address, minBalance) {
  try {
    const balance = await publicClient.getBalance({ address });
    return {
      address,
      balance,
      sufficient: minBalance ? balance >= minBalance : true,
      required: minBalance
    };
  } catch (error) {
    throw new NetworkError(
      `Failed to check balance: ${error instanceof Error ? error.message : "Unknown error"}`,
      "BALANCE_CHECK_FAILED",
      error
    );
  }
}
async function waitForTransactionReceipt(publicClient, hash, options = {}) {
  const {
    timeout = 6e4,
    // 60 seconds default
    pollingInterval = 2e3,
    // 2 seconds default
    confirmations = 1
  } = options;
  const startTime = Date.now();
  return new Promise((resolve, reject) => {
    const poll = async () => {
      try {
        const receipt = await publicClient.getTransactionReceipt({ hash });
        if (receipt) {
          if (confirmations > 1) {
            const currentBlock = await publicClient.getBlockNumber();
            const confirmationCount = currentBlock - receipt.blockNumber + 1n;
            if (confirmationCount < BigInt(confirmations)) {
              const elapsed = Date.now() - startTime;
              if (elapsed >= timeout) {
                reject(
                  new TransactionError(`Transaction confirmation timeout after ${timeout}ms`, hash)
                );
                return;
              }
              setTimeout(poll, pollingInterval);
              return;
            }
          }
          resolve(receipt);
        } else {
          const elapsed = Date.now() - startTime;
          if (elapsed >= timeout) {
            reject(new TransactionError(`Transaction receipt timeout after ${timeout}ms`, hash));
            return;
          }
          setTimeout(poll, pollingInterval);
        }
      } catch (error) {
        const elapsed = Date.now() - startTime;
        if (elapsed >= timeout) {
          reject(
            new TransactionError(`Transaction receipt timeout after ${timeout}ms`, hash, error)
          );
          return;
        }
        setTimeout(poll, pollingInterval);
      }
    };
    poll();
  });
}
async function executeTransaction(clients, operation, args, options = {}) {
  const { timeout = 6e4, confirmations = 1, onSubmitted, onConfirmed, onError } = options;
  try {
    const hash = await operation(clients, ...args);
    onSubmitted?.(hash);
    const receipt = await waitForTransactionReceipt(clients.publicClient, hash, {
      timeout,
      confirmations
    });
    const success = receipt.status === "success";
    if (success) {
      onConfirmed?.(receipt);
    } else {
      const error = new TransactionError("Transaction failed on-chain", hash, receipt);
      onError?.(error, hash);
      throw error;
    }
    return {
      hash,
      receipt,
      success
    };
  } catch (error) {
    const txError = error instanceof TransactionError ? error : new TransactionError(
      `Transaction execution failed: ${error instanceof Error ? error.message : "Unknown error"}`,
      void 0,
      error
    );
    onError?.(txError, txError.hash);
    throw txError;
  }
}
async function extractNetworkClients(publicClient, walletClient) {
  try {
    const address = walletClient.account?.address;
    if (!address) {
      throw new WalletError("WalletClient must have an account", "NO_ACCOUNT");
    }
    const chainId = await walletClient.getChainId();
    return createNetworkClients(publicClient, walletClient, address, chainId);
  } catch (error) {
    throw new WalletError(
      `Failed to extract network clients: ${error instanceof Error ? error.message : "Unknown error"}`,
      "EXTRACTION_FAILED",
      error
    );
  }
}
async function validateNetworkPrerequisites(clients, requirements) {
  const { targetChainId, minBalance, requiredAddress } = requirements;
  const networkStatus = await checkNetworkStatus(clients, targetChainId);
  const balanceResult = await checkBalance(clients.publicClient, clients.address, minBalance);
  const addressValid = requiredAddress ? clients.address.toLowerCase() === requiredAddress.toLowerCase() : true;
  return {
    networkValid: networkStatus.isCorrectNetwork,
    balanceValid: balanceResult.sufficient,
    addressValid,
    details: {
      currentChainId: networkStatus.currentChainId,
      balance: balanceResult.balance,
      address: clients.address
    }
  };
}

// src/utils/transaction.ts
function createTransactionTracker() {
  let status = { state: "idle" };
  let timeoutHandle;
  let abortController;
  const updateStatus = (newStatus) => {
    status = { ...status, ...newStatus };
  };
  const reset = () => {
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
      timeoutHandle = void 0;
    }
    if (abortController) {
      abortController.abort();
      abortController = void 0;
    }
    status = { state: "idle" };
  };
  const abort = () => {
    if (abortController) {
      abortController.abort();
    }
    if (timeoutHandle) {
      clearTimeout(timeoutHandle);
      timeoutHandle = void 0;
    }
    updateStatus({
      state: "error",
      aborted: true,
      error: "Transaction aborted by user"
    });
  };
  const execute = async (operation, clients, args, options = {}) => {
    const {
      timeout = 6e4,
      confirmations = 1,
      onSubmitted,
      onConfirmed,
      onError,
      signal
    } = options;
    try {
      reset();
      abortController = new AbortController();
      if (signal) {
        if (signal.aborted) {
          throw new TransactionError("Operation was aborted before execution");
        }
        signal.addEventListener("abort", () => {
          abort();
        });
      }
      updateStatus({
        state: "submitting",
        startTime: Date.now(),
        error: void 0,
        hash: void 0,
        receipt: void 0,
        aborted: false
      });
      if (abortController.signal.aborted) {
        throw new TransactionError("Transaction aborted");
      }
      const hash = await operation(clients, ...args);
      if (abortController.signal.aborted) {
        throw new TransactionError("Transaction aborted after submission", hash);
      }
      updateStatus({
        state: "pending",
        hash,
        submitTime: Date.now()
      });
      onSubmitted?.(hash);
      if (timeout > 0) {
        timeoutHandle = setTimeout(() => {
          if (status.state === "pending" && !abortController?.signal.aborted) {
            updateStatus({
              state: "timeout",
              error: `Transaction timeout after ${timeout}ms`
            });
          }
        }, timeout);
      }
      const receipt = await Promise.race([
        waitForTransactionReceipt(clients.publicClient, hash, { timeout, confirmations }),
        new Promise((_, reject) => {
          abortController?.signal.addEventListener("abort", () => {
            reject(new TransactionError("Transaction aborted while waiting for receipt", hash));
          });
        })
      ]);
      if (timeoutHandle) {
        clearTimeout(timeoutHandle);
        timeoutHandle = void 0;
      }
      const success = receipt.status === "success";
      updateStatus({
        state: success ? "success" : "error",
        receipt,
        confirmTime: Date.now(),
        error: success ? void 0 : "Transaction failed on-chain"
      });
      if (success) {
        onConfirmed?.(receipt);
      } else {
        const error = new TransactionError("Transaction failed on-chain", hash, receipt);
        onError?.(error, hash);
        throw error;
      }
      return {
        hash,
        receipt,
        success
      };
    } catch (error) {
      const txError = error instanceof TransactionError ? error : new TransactionError(
        `Transaction execution failed: ${error instanceof Error ? error.message : "Unknown error"}`,
        status.hash,
        error
      );
      updateStatus({
        state: "error",
        error: txError.message
      });
      onError?.(txError, status.hash);
      throw txError;
    }
  };
  return {
    get status() {
      return { ...status };
    },
    get isIdle() {
      return status.state === "idle";
    },
    get isSubmitting() {
      return status.state === "submitting";
    },
    get isPending() {
      return status.state === "pending";
    },
    get isSuccess() {
      return status.state === "success";
    },
    get isError() {
      return status.state === "error";
    },
    get isTimeout() {
      return status.state === "timeout";
    },
    get isAborted() {
      return status.aborted === true;
    },
    get isComplete() {
      return ["success", "error", "timeout"].includes(status.state);
    },
    abort,
    reset,
    execute
  };
}
async function executeBatchTransactions(operations, clients, batchOptions) {
  const { mode, failFast = false, onProgress } = batchOptions;
  const results = [];
  if (mode === "sequential") {
    for (let i = 0; i < operations.length; i++) {
      const op = operations[i];
      if (!op) continue;
      const { operation, args, options } = op;
      try {
        const tracker = createTransactionTracker();
        const result = await tracker.execute(operation, clients, args, options);
        results.push(result);
        onProgress?.(i + 1, operations.length, results);
      } catch (error) {
        const txError = error instanceof Error ? error : new Error(String(error));
        results.push(txError);
        onProgress?.(i + 1, operations.length, results);
        if (failFast) {
          for (let j = i + 1; j < operations.length; j++) {
            results.push(new Error("Cancelled due to previous failure"));
          }
          break;
        }
      }
    }
  } else {
    const promises = operations.map(async ({ operation, args, options }) => {
      try {
        const tracker = createTransactionTracker();
        return await tracker.execute(operation, clients, args, options);
      } catch (error) {
        return error instanceof Error ? error : new Error(String(error));
      }
    });
    const allResults = await Promise.allSettled(promises);
    results.push(...allResults.map((r) => r.status === "fulfilled" ? r.value : r.reason));
    onProgress?.(operations.length, operations.length, results);
  }
  const successCount = results.filter((r) => !(r instanceof Error)).length;
  const errorCount = results.length - successCount;
  return {
    results,
    successCount,
    errorCount,
    allSuccessful: errorCount === 0
  };
}
async function executeTransactionWithRetry(operation, clients, args, options = {}, retryOptions = {}) {
  const {
    maxRetries = 3,
    initialDelay = 1e3,
    maxDelay = 1e4,
    backoffFactor = 2,
    retryCondition = () => true
  } = retryOptions;
  let lastError;
  let delay = initialDelay;
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      const tracker = createTransactionTracker();
      return await tracker.execute(operation, clients, args, options);
    } catch (error) {
      lastError = error instanceof Error ? error : new Error(String(error));
      if (attempt === maxRetries) {
        break;
      }
      if (!retryCondition(lastError)) {
        break;
      }
      await new Promise((resolve) => setTimeout(resolve, delay));
      delay = Math.min(delay * backoffFactor, maxDelay);
    }
  }
  throw lastError;
}
async function estimateTransactionGas(clients, transaction, options = {}) {
  const {
    gasLimitMultiplier = 1.2,
    maxFeePerGasMultiplier = 1.1,
    priorityFeeMultiplier = 1.1
  } = options;
  try {
    const estimatedGas = await clients.publicClient.estimateGas(transaction);
    const gasLimit = BigInt(Math.ceil(Number(estimatedGas) * gasLimitMultiplier));
    let maxFeePerGas;
    let maxPriorityFeePerGas;
    try {
      const feeData = await clients.publicClient.estimateFeesPerGas();
      if (feeData.maxFeePerGas) {
        maxFeePerGas = BigInt(Math.ceil(Number(feeData.maxFeePerGas) * maxFeePerGasMultiplier));
      }
      if (feeData.maxPriorityFeePerGas) {
        maxPriorityFeePerGas = BigInt(
          Math.ceil(Number(feeData.maxPriorityFeePerGas) * priorityFeeMultiplier)
        );
      }
    } catch (error) {
    }
    return {
      gasLimit,
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch (error) {
    throw new TransactionError(
      `Gas estimation failed: ${error instanceof Error ? error.message : "Unknown error"}`,
      void 0,
      error
    );
  }
}

// src/utils/client-factories.ts
import {
  createPublicClient,
  createWalletClient,
  http,
  custom
} from "viem";
import { privateKeyToAccount } from "viem/accounts";
function isBrowser() {
  return typeof window !== "undefined" && typeof window.ethereum !== "undefined";
}
function getEthereumProvider() {
  if (!isBrowser()) return null;
  const ethereum = window.ethereum;
  return ethereum || null;
}
function createClientsFromPrivateKey(chain, privateKey, rpcUrl) {
  try {
    const account = privateKeyToAccount(privateKey);
    const publicClient = createPublicClient({
      chain,
      transport: http(rpcUrl || chain.rpcUrls.default.http[0])
    });
    const walletClient = createWalletClient({
      account,
      chain,
      transport: http(rpcUrl || chain.rpcUrls.default.http[0])
    });
    return createNetworkClients(publicClient, walletClient, account.address, chain.id);
  } catch (error) {
    throw new WalletError(
      `Failed to create clients from private key: ${error instanceof Error ? error.message : "Unknown error"}`,
      "CLIENT_CREATION_FAILED",
      error
    );
  }
}
async function createClientsFromBrowser(chain, rpcUrl) {
  if (!isBrowser()) {
    throw new WalletError(
      "Browser wallet connection is only available in browser environment",
      "NOT_BROWSER_ENVIRONMENT"
    );
  }
  const provider = getEthereumProvider();
  if (!provider) {
    throw new WalletError(
      "No Ethereum provider found. Please install a wallet like MetaMask.",
      "NO_PROVIDER"
    );
  }
  try {
    const accounts = await provider.request({
      method: "eth_requestAccounts"
    });
    if (!accounts || accounts.length === 0) {
      throw new WalletError("No accounts available", "NO_ACCOUNTS");
    }
    const address = accounts[0];
    const chainId = await provider.request({ method: "eth_chainId" });
    const currentChainId = parseInt(chainId, 16);
    if (currentChainId !== chain.id) {
      await switchToNetwork(provider, chain.id);
    }
    const publicClient = createPublicClient({
      chain,
      transport: http(rpcUrl || chain.rpcUrls.default.http[0])
    });
    const walletClient = createWalletClient({
      account: address,
      chain,
      transport: custom(provider)
    });
    return createNetworkClients(publicClient, walletClient, address, chain.id);
  } catch (error) {
    if (error instanceof WalletError || error instanceof NetworkError) {
      throw error;
    }
    throw new WalletError(
      `Failed to connect browser wallet: ${error instanceof Error ? error.message : "Unknown error"}`,
      "BROWSER_CONNECTION_FAILED",
      error
    );
  }
}
async function switchToNetwork(provider, chainId) {
  try {
    await provider.request({
      method: "wallet_switchEthereumChain",
      params: [{ chainId: `0x${chainId.toString(16)}` }]
    });
  } catch (error) {
    const errorObj = error;
    if (errorObj.code === 4902) {
      throw new NetworkError(
        `Network ${chainId} not found in wallet. Please add it manually.`,
        "NETWORK_NOT_FOUND",
        error
      );
    }
    throw new NetworkError(
      `Failed to switch network: ${errorObj.message || "Unknown error"}`,
      "NETWORK_SWITCH_FAILED",
      error
    );
  }
}
async function addNetwork(provider, config) {
  try {
    await provider.request({
      method: "wallet_addEthereumChain",
      params: [
        {
          chainId: `0x${config.chainId.toString(16)}`,
          chainName: config.name,
          rpcUrls: [config.rpcUrl],
          blockExplorerUrls: config.blockExplorer ? [config.blockExplorer] : void 0,
          nativeCurrency: {
            name: "ETH",
            symbol: "ETH",
            decimals: 18
          }
        }
      ]
    });
  } catch (error) {
    const errorObj = error;
    throw new NetworkError(
      `Failed to add network: ${errorObj.message || "Unknown error"}`,
      "NETWORK_ADD_FAILED",
      error
    );
  }
}
async function autoCreateClients(chain, options = {}) {
  const { privateKey, rpcUrl, preferBrowser = false } = options;
  if (privateKey) {
    return createClientsFromPrivateKey(chain, privateKey, rpcUrl);
  }
  if (isBrowser() && (preferBrowser || !privateKey)) {
    return createClientsFromBrowser(chain, rpcUrl);
  }
  throw new WalletError(
    "No wallet connection method available. Provide a private key for server-side usage or use in browser environment.",
    "NO_CONNECTION_METHOD"
  );
}

// src/actions/blockchains/deploy_app_auth.ts
var kmsAuthAbi = [
  {
    inputs: [
      { name: "deployer", type: "address" },
      { name: "disableUpgrades", type: "bool" },
      { name: "allowAnyDevice", type: "bool" },
      { name: "deviceId", type: "bytes32" },
      { name: "composeHash", type: "bytes32" }
    ],
    name: "deployAndRegisterApp",
    outputs: [{ name: "", type: "address" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { name: "appId", type: "address", indexed: true },
      { name: "deployer", type: "address", indexed: true }
    ],
    name: "AppDeployedViaFactory",
    type: "event",
    anonymous: false
  },
  {
    inputs: [{ name: "appId", type: "address", indexed: false }],
    name: "AppRegistered",
    type: "event",
    anonymous: false
  }
];
var DeployAppAuthRequestBaseSchema = z32.object({
  // Chain configuration (conditionally required)
  chain: z32.unknown().optional(),
  rpcUrl: z32.string().optional(),
  // Contract configuration (required)
  kmsContractAddress: z32.string(),
  // Authentication mode: either privateKey OR walletClient (required, mutually exclusive)
  privateKey: z32.string().optional(),
  walletClient: z32.unknown().optional(),
  // Public client (optional, will create default if not provided)
  publicClient: z32.unknown().optional(),
  // App configuration (optional)
  allowAnyDevice: z32.boolean().optional().default(false),
  deviceId: z32.string().optional().default("0000000000000000000000000000000000000000000000000000000000000000"),
  composeHash: z32.string().optional().default("0000000000000000000000000000000000000000000000000000000000000000"),
  disableUpgrades: z32.boolean().optional().default(false),
  // Validation configuration (optional)
  skipPrerequisiteChecks: z32.boolean().optional().default(false),
  minBalance: z32.string().optional()
  // ETH amount as string, e.g., "0.01"
}).passthrough();
var DeployAppAuthRequestSchema = DeployAppAuthRequestBaseSchema.refine(
  (data) => {
    const hasPrivateKey = !!data.privateKey;
    const hasWalletClient = !!data.walletClient;
    return hasPrivateKey !== hasWalletClient;
  },
  {
    message: "Either 'privateKey' or 'walletClient' must be provided, but not both",
    path: ["privateKey", "walletClient"]
  }
).refine(
  (data) => {
    const hasPublicClient = !!data.publicClient;
    const hasWalletClient = !!data.walletClient;
    const hasChain = !!data.chain;
    if (hasPublicClient && hasWalletClient) {
      return true;
    }
    return hasChain;
  },
  {
    message: "Chain is required when publicClient or walletClient is not provided",
    path: ["chain"]
  }
);
var DeployAppAuthSchema = z32.object({
  appId: z32.string(),
  appAuthAddress: z32.string(),
  deployer: z32.string(),
  transactionHash: z32.string(),
  blockNumber: z32.bigint().optional(),
  gasUsed: z32.bigint().optional()
}).passthrough();
function parseDeploymentResult(receipt, deployer, kmsContractAddress) {
  try {
    const logs = parseEventLogs({
      abi: kmsAuthAbi,
      eventName: "AppDeployedViaFactory",
      logs: receipt.logs,
      strict: false
    });
    if (logs.length === 0) {
      if (receipt.status === "reverted") {
        throw new Error(`Transaction failed: ${receipt.transactionHash}`);
      }
      throw new Error(
        `Transaction ${receipt.transactionHash} has no AppDeployedViaFactory events. The deployment failed. Status: ${receipt.status}. Found ${receipt.logs.length} logs.`
      );
    }
    const deploymentEvent = logs[0];
    if (!deploymentEvent?.args) {
      throw new Error("Event has no data");
    }
    const { appId, deployer: eventDeployer } = deploymentEvent.args;
    if (!appId) {
      throw new Error("Event missing appId");
    }
    return {
      appId,
      appAuthAddress: appId,
      deployer,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    throw new Error(`Parse failed: ${error}`);
  }
}
async function deployAppAuth(request, parameters) {
  const validatedRequest = DeployAppAuthRequestSchema.parse(request);
  const {
    chain,
    rpcUrl,
    kmsContractAddress,
    privateKey,
    walletClient: providedWalletClient,
    publicClient: providedPublicClient,
    allowAnyDevice: rawAllowAnyDevice = false,
    deviceId = "0000000000000000000000000000000000000000000000000000000000000000",
    composeHash = "0000000000000000000000000000000000000000000000000000000000000000",
    disableUpgrades = false,
    skipPrerequisiteChecks = false,
    minBalance,
    timeout = 12e4,
    // 2 minutes default
    retryOptions,
    signal,
    onTransactionStateChange,
    onTransactionSubmitted,
    onTransactionConfirmed
  } = validatedRequest;
  const defaultDeviceId = "0000000000000000000000000000000000000000000000000000000000000000";
  const hasSpecificDevice = deviceId !== defaultDeviceId && deviceId !== "0x" + defaultDeviceId;
  const allowAnyDevice = hasSpecificDevice ? false : rawAllowAnyDevice;
  let publicClient;
  let walletClient;
  let deployerAddress;
  let chainId;
  if (privateKey) {
    const account = privateKeyToAccount2(privateKey);
    if (providedPublicClient) {
      if (typeof providedPublicClient !== "object" || !providedPublicClient) {
        throw new Error("publicClient is invalid");
      }
      publicClient = providedPublicClient;
    } else {
      if (!chain) {
        throw new Error("Chain required for publicClient");
      }
      publicClient = createPublicClient2({
        chain,
        transport: http2(rpcUrl)
      });
    }
    if (!chain) {
      throw new Error("Chain required for walletClient");
    }
    walletClient = createWalletClient2({
      account,
      chain,
      transport: http2(rpcUrl)
    });
    deployerAddress = account.address;
    chainId = chain.id;
  } else if (providedWalletClient) {
    if (typeof providedWalletClient !== "object" || !providedWalletClient) {
      throw new Error("walletClient is invalid");
    }
    walletClient = providedWalletClient;
    if (providedPublicClient) {
      if (typeof providedPublicClient !== "object" || !providedPublicClient) {
        throw new Error("publicClient is invalid");
      }
      publicClient = providedPublicClient;
    } else {
      if (!chain) {
        throw new Error("Chain required for publicClient");
      }
      publicClient = createPublicClient2({
        chain,
        transport: http2(rpcUrl)
      });
    }
    if (!walletClient.account?.address) {
      throw new Error("WalletClient needs an account");
    }
    deployerAddress = walletClient.account.address;
    if (chain) {
      chainId = chain.id;
    } else {
      chainId = await walletClient.getChainId();
    }
  } else {
    throw new Error("Need privateKey or walletClient");
  }
  const networkClients = {
    publicClient,
    walletClient,
    address: deployerAddress,
    chainId
  };
  const transactionTracker = createTransactionTracker();
  if (onTransactionStateChange && typeof onTransactionStateChange === "function") {
    const pollStatus = () => {
      onTransactionStateChange(
        transactionTracker.status
      );
      if (!transactionTracker.isComplete) {
        setTimeout(pollStatus, 100);
      }
    };
    setTimeout(pollStatus, 10);
  }
  if (!skipPrerequisiteChecks) {
    const requirements = {
      targetChainId: chainId,
      minBalance: minBalance ? parseEther(minBalance) : parseEther("0.001")
      // Default 0.001 ETH
    };
    const validation = await validateNetworkPrerequisites(networkClients, requirements);
    if (!validation.networkValid) {
      throw new Error(
        `Wrong network. Need chain ${requirements.targetChainId}, got ${validation.details.currentChainId}`
      );
    }
    if (!validation.balanceValid) {
      const requiredEth = Number(requirements.minBalance) / 1e18;
      const currentEth = Number(validation.details.balance) / 1e18;
      throw new Error(`Not enough ETH. Need ${requiredEth}, have ${currentEth.toFixed(6)}`);
    }
  }
  const deviceIdHex = asHex(deviceId);
  const composeHashHex = asHex(composeHash);
  const deviceIdBytes = `0x${deviceIdHex.slice(2).padEnd(64, "0")}`;
  const composeHashBytes = `0x${composeHashHex.slice(2).padEnd(64, "0")}`;
  const deployOperation = async (clients) => {
    try {
      const code = await clients.publicClient.getCode({ address: kmsContractAddress });
      if (!code || code === "0x") {
        throw new Error(`No contract at ${kmsContractAddress}`);
      }
    } catch (error) {
      if (error instanceof Error && error.message.includes("No contract at")) {
        throw error;
      }
    }
    const contractCall = {
      address: kmsContractAddress,
      abi: kmsAuthAbi,
      functionName: "deployAndRegisterApp",
      args: [
        clients.address,
        disableUpgrades,
        allowAnyDevice,
        deviceIdBytes,
        composeHashBytes
      ],
      account: clients.walletClient.account || clients.address,
      chain: chain || null
    };
    return await clients.walletClient.writeContract(contractCall);
  };
  const transactionResult = retryOptions ? await executeTransactionWithRetry(
    deployOperation,
    networkClients,
    [],
    {
      timeout,
      confirmations: 1,
      onSubmitted: onTransactionSubmitted,
      onConfirmed: onTransactionConfirmed,
      signal
    },
    retryOptions
  ) : await transactionTracker.execute(deployOperation, networkClients, [], {
    timeout,
    confirmations: 1,
    onSubmitted: onTransactionSubmitted,
    onConfirmed: onTransactionConfirmed,
    signal
  });
  const result = parseDeploymentResult(
    transactionResult.receipt,
    deployerAddress,
    kmsContractAddress
  );
  if (parameters?.schema === false) {
    return result;
  }
  const schema = parameters?.schema || DeployAppAuthSchema;
  return schema.parse(result);
}
async function safeDeployAppAuth(request, parameters) {
  try {
    const result = await deployAppAuth(request, parameters);
    return { success: true, data: result };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown deployment error";
    const requestError = {
      isRequestError: true,
      message: errorMessage,
      status: 500,
      // Use 500 for blockchain errors since they're not HTTP errors
      detail: errorMessage
    };
    return {
      success: false,
      error: requestError
    };
  }
}

// src/actions/blockchains/add_compose_hash.ts
import { z as z33 } from "zod";
import {
  createPublicClient as createPublicClient3,
  createWalletClient as createWalletClient3,
  http as http3,
  parseEventLogs as parseEventLogs2,
  parseEther as parseEther2
} from "viem";
import { privateKeyToAccount as privateKeyToAccount3 } from "viem/accounts";
var appAuthAbi = [
  {
    inputs: [{ name: "composeHash", type: "bytes32" }],
    name: "addComposeHash",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ name: "composeHash", type: "bytes32", indexed: false }],
    name: "ComposeHashAdded",
    type: "event",
    anonymous: false
  }
];
var AddComposeHashRequestSchema = z33.object({
  // Chain configuration (conditionally required)
  chain: z33.unknown().optional(),
  rpcUrl: z33.string().optional(),
  appId: z33.string(),
  composeHash: z33.string(),
  // Authentication mode: either privateKey OR walletClient (required, mutually exclusive)
  privateKey: z33.string().optional(),
  walletClient: z33.unknown().optional(),
  // Public client (optional, will create default if not provided)
  publicClient: z33.unknown().optional(),
  // Validation configuration (optional)
  skipPrerequisiteChecks: z33.boolean().optional().default(false),
  minBalance: z33.string().optional(),
  // ETH amount as string, e.g., "0.01"
  // Transaction control options
  timeout: z33.number().optional().default(12e4),
  retryOptions: z33.unknown().optional(),
  signal: z33.unknown().optional(),
  // Progress callbacks
  onTransactionStateChange: z33.function().optional(),
  onTransactionSubmitted: z33.function().optional(),
  onTransactionConfirmed: z33.function().optional()
}).passthrough().refine(
  (data) => {
    const hasPrivateKey = !!data.privateKey;
    const hasWalletClient = !!data.walletClient;
    return hasPrivateKey !== hasWalletClient;
  },
  {
    message: "Either 'privateKey' or 'walletClient' must be provided, but not both",
    path: ["privateKey", "walletClient"]
  }
).refine(
  (data) => {
    const hasPublicClient = !!data.publicClient;
    const hasWalletClient = !!data.walletClient;
    const hasChain = !!data.chain;
    if (hasPublicClient && hasWalletClient) return true;
    return hasChain;
  },
  {
    message: "Chain is required when publicClient or walletClient is not provided",
    path: ["chain"]
  }
);
var AddComposeHashSchema = z33.object({
  composeHash: z33.string(),
  appId: z33.string(),
  transactionHash: z33.string(),
  blockNumber: z33.bigint().optional(),
  gasUsed: z33.bigint().optional()
}).passthrough();
function parseComposeHashResult(receipt, composeHash, appAuthAddress, appId) {
  console.log(receipt.logs);
  try {
    const logs = parseEventLogs2({
      abi: appAuthAbi,
      eventName: "ComposeHashAdded",
      logs: receipt.logs,
      strict: false
    });
    if (logs.length > 0) {
      const event = logs[0];
      if (event?.args?.composeHash !== composeHash) {
        console.warn(
          `Event compose hash (${event?.args?.composeHash}) does not match expected (${composeHash})`
        );
      }
    }
    return {
      composeHash,
      appAuthAddress,
      appId,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  } catch (parseError) {
    console.warn("Failed to parse ComposeHashAdded event, returning basic result:", parseError);
    return {
      composeHash,
      appAuthAddress,
      appId,
      transactionHash: receipt.transactionHash,
      blockNumber: receipt.blockNumber,
      gasUsed: receipt.gasUsed
    };
  }
}
async function addComposeHash(request, parameters) {
  const validatedRequest = AddComposeHashRequestSchema.parse(request);
  const {
    chain,
    rpcUrl,
    appId,
    composeHash,
    privateKey,
    walletClient: providedWalletClient,
    publicClient: providedPublicClient,
    timeout = 12e4,
    retryOptions,
    signal,
    onTransactionStateChange,
    onTransactionSubmitted,
    onTransactionConfirmed,
    skipPrerequisiteChecks = false,
    minBalance
  } = validatedRequest;
  let publicClient;
  let walletClient;
  let address;
  let chainId;
  const appAuthAddress = appId.startsWith("0x") ? appId : `0x${appId}`;
  if (privateKey) {
    const account = privateKeyToAccount3(privateKey);
    if (providedPublicClient) {
      publicClient = providedPublicClient;
    } else {
      if (!chain) throw new Error("Chain required when creating publicClient");
      publicClient = createPublicClient3({ chain, transport: http3(rpcUrl) });
    }
    if (!chain) throw new Error("Chain required when creating walletClient");
    walletClient = createWalletClient3({
      account,
      chain,
      transport: http3(rpcUrl)
    });
    address = account.address;
    chainId = chain.id;
  } else if (providedWalletClient) {
    walletClient = providedWalletClient;
    if (providedPublicClient) {
      publicClient = providedPublicClient;
    } else {
      if (!chain) throw new Error("Chain required when creating publicClient");
      publicClient = createPublicClient3({ chain, transport: http3(rpcUrl) });
    }
    if (!walletClient.account?.address) {
      throw new Error("WalletClient must have an account with address");
    }
    address = walletClient.account.address;
    chainId = chain ? chain.id : await walletClient.getChainId();
  } else {
    throw new Error("Either privateKey or walletClient must be provided");
  }
  const networkClients = {
    publicClient,
    walletClient,
    address,
    chainId
  };
  const transactionTracker = createTransactionTracker();
  if (onTransactionStateChange && typeof onTransactionStateChange === "function") {
    const pollStatus = () => {
      onTransactionStateChange(transactionTracker.status);
      if (!transactionTracker.isComplete) {
        setTimeout(pollStatus, 100);
      }
    };
    setTimeout(pollStatus, 10);
  }
  if (!skipPrerequisiteChecks) {
    const requirements = {
      targetChainId: chainId,
      minBalance: minBalance ? parseEther2(minBalance) : parseEther2("0.001")
    };
    const validation = await validateNetworkPrerequisites(networkClients, requirements);
    if (!validation.networkValid) {
      throw new Error(
        `Network mismatch: Expected chain ${requirements.targetChainId}, but wallet is on chain ${validation.details.currentChainId}`
      );
    }
    if (!validation.balanceValid) {
      const requiredEth = Number(requirements.minBalance) / 1e18;
      const currentEth = Number(validation.details.balance) / 1e18;
      throw new Error(
        `Insufficient balance: Required ${requiredEth} ETH, but account has ${currentEth.toFixed(6)} ETH`
      );
    }
  }
  const addComposeHashOperation = async (clients) => {
    const hash = await clients.walletClient.writeContract({
      address: appAuthAddress,
      abi: appAuthAbi,
      functionName: "addComposeHash",
      args: [asHex(composeHash)],
      account: clients.walletClient.account || clients.address,
      chain: chain || null
    });
    return hash;
  };
  const transactionResult = retryOptions ? await executeTransactionWithRetry(
    addComposeHashOperation,
    networkClients,
    [],
    {
      timeout,
      confirmations: 1,
      onSubmitted: onTransactionSubmitted,
      onConfirmed: onTransactionConfirmed,
      signal
    },
    retryOptions
  ) : await transactionTracker.execute(addComposeHashOperation, networkClients, [], {
    timeout,
    confirmations: 1,
    onSubmitted: onTransactionSubmitted,
    onConfirmed: onTransactionConfirmed,
    signal
  });
  const result = parseComposeHashResult(
    transactionResult.receipt,
    asHex(composeHash),
    appAuthAddress,
    appId
  );
  if (parameters?.schema === false) {
    return result;
  }
  const schema = parameters?.schema || AddComposeHashSchema;
  return schema.parse(result);
}
async function safeAddComposeHash(request, parameters) {
  try {
    const result = await addComposeHash(request, parameters);
    return { success: true, data: result };
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : "Unknown blockchain error";
    return {
      success: false,
      error: {
        isRequestError: true,
        message: errorMessage,
        status: 500,
        // Blockchain errors use 500
        detail: errorMessage
      }
    };
  }
}

// src/actions/cvms/watch_cvm_state.ts
import { z as z34 } from "zod";
var WatchCvmStateParamsSchema = z34.object({
  target: z34.string().describe("Target status to wait for (e.g., 'running', 'stopped')"),
  interval: z34.number().min(5).max(30).default(5).describe("Polling interval in seconds"),
  timeout: z34.number().min(10).max(600).default(300).describe("Timeout per attempt in seconds"),
  maxRetries: z34.number().min(0).default(Number.POSITIVE_INFINITY).describe("Maximum number of retry attempts (Infinity for unlimited)"),
  retryDelay: z34.number().min(0).default(5e3).describe("Delay between retries in milliseconds")
});
var WatchCvmStateRequestSchema = WatchCvmStateParamsSchema;
var WatchAbortedError = class extends Error {
  constructor() {
    super("Watch operation was aborted");
    this.name = "WatchAbortedError";
  }
};
var MaxRetriesExceededError = class extends Error {
  constructor(attempts) {
    super(`Maximum retry attempts (${attempts}) exceeded`);
    this.attempts = attempts;
    this.name = "MaxRetriesExceededError";
  }
};
function parseSSEEvent(eventType, data) {
  try {
    const parsed = JSON.parse(data);
    return { type: eventType, data: parsed };
  } catch {
    return { type: "error", data: { error: "Failed to parse SSE event" } };
  }
}
async function watchCvmState(client, request, options = {}) {
  const { cvmId } = CvmIdSchema.parse(request);
  const { target, interval, timeout, maxRetries, retryDelay } = WatchCvmStateParamsSchema.parse(request);
  const { signal, onEvent } = options;
  let attempt = 0;
  while (attempt < maxRetries) {
    if (signal?.aborted) {
      throw new WatchAbortedError();
    }
    attempt++;
    try {
      const result = await watchSingleAttempt(
        client,
        cvmId,
        target,
        interval,
        timeout,
        signal,
        onEvent
      );
      if (result) {
        return result;
      }
      if (attempt >= maxRetries) {
        throw new MaxRetriesExceededError(attempt);
      }
      await sleep(retryDelay, signal);
    } catch (error) {
      if (signal?.aborted) {
        throw new WatchAbortedError();
      }
      if (error instanceof WatchAbortedError || error instanceof MaxRetriesExceededError) {
        throw error;
      }
      if (attempt >= maxRetries) {
        throw error;
      }
      if (onEvent) {
        onEvent({
          type: "error",
          data: { error: error instanceof Error ? error.message : String(error) }
        });
      }
      await sleep(retryDelay, signal);
    }
  }
  throw new MaxRetriesExceededError(attempt);
}
async function watchSingleAttempt(client, cvmId, target, interval, timeout, signal, onEvent) {
  const params = new URLSearchParams({
    target,
    interval: String(interval),
    timeout: String(timeout)
  });
  const baseURL = client.config.baseURL || "";
  const fullUrl = `${baseURL}/cvms/${cvmId}/state?${params.toString()}`;
  const headers = {
    Accept: "text/event-stream",
    "Cache-Control": "no-cache"
  };
  if (!client.config.useCookieAuth && client.config.apiKey) {
    headers["X-API-Key"] = client.config.apiKey;
  }
  if (client.config.headers) {
    Object.entries(client.config.headers).forEach(([key, value]) => {
      if (typeof value === "string") {
        headers[key] = value;
      }
    });
  }
  const response = await client.raw.native(fullUrl, {
    method: "GET",
    headers,
    signal,
    ...client.config.useCookieAuth ? { credentials: "include" } : {}
  });
  if (!response.ok) {
    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
  }
  if (!response.body) {
    throw new Error("Response body is null");
  }
  return parseSSEStream(response.body, signal, onEvent);
}
async function parseSSEStream(stream, signal, onEvent) {
  const reader = stream.getReader();
  const decoder = new TextDecoder();
  let buffer = "";
  let finalState = null;
  let currentEvent = "";
  let currentData = "";
  const processLine = (line) => {
    if (line.startsWith("event:")) {
      currentEvent = line.slice(6).trim();
    } else if (line.startsWith("data:")) {
      currentData = line.slice(5).trim();
    } else if (line === "") {
      if (currentEvent && currentData) {
        const event = parseSSEEvent(currentEvent, currentData);
        if (event.type === "state") {
          finalState = event.data;
        }
        onEvent?.(event);
        if (event.type === "complete") {
          return "complete";
        }
        if (event.type === "timeout") {
          return "timeout";
        }
      }
      currentEvent = "";
      currentData = "";
    }
    return null;
  };
  try {
    while (true) {
      if (signal?.aborted) {
        throw new WatchAbortedError();
      }
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const result = processLine(line.trim());
        if (result === "complete") {
          return finalState;
        }
        if (result === "timeout") {
          return null;
        }
      }
    }
    return finalState;
  } catch (error) {
    if (error instanceof WatchAbortedError) {
      throw error;
    }
    throw new Error(`SSE stream error: ${error instanceof Error ? error.message : String(error)}`);
  } finally {
    reader.releaseLock();
  }
}
function sleep(ms, signal) {
  return new Promise((resolve, reject) => {
    if (signal?.aborted) {
      reject(new WatchAbortedError());
      return;
    }
    const timer = setTimeout(resolve, ms);
    if (signal) {
      signal.addEventListener("abort", () => {
        clearTimeout(timer);
        reject(new WatchAbortedError());
      });
    }
  });
}

// src/parse_dotenv.ts
var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
function parseEnv(input) {
  const obj = {};
  let lines = input.toString();
  lines = lines.replace(/\r\n?/gm, "\n");
  let match;
  while ((match = LINE.exec(lines)) != null) {
    const key = match[1];
    if (!key) continue;
    let value = match[2] || "";
    value = value.trim();
    const maybeQuote = value[0];
    value = value.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
    if (maybeQuote === '"') {
      value = value.replace(/\\n/g, "\n");
      value = value.replace(/\\r/g, "\r");
    }
    obj[key] = value;
  }
  return obj;
}
function parseEnvVars(input) {
  const parsed = parseEnv(input);
  const result = [];
  for (const [key, value] of Object.entries(parsed)) {
    result.push({ key, value });
  }
  return result;
}

// src/index.ts
import {
  encryptEnvVars as encryptEnvVars2
} from "@phala/dstack-sdk/encrypt-env-vars";
import { getComposeHash as getComposeHash2 } from "@phala/dstack-sdk/get-compose-hash";
import { verifyEnvEncryptPublicKey } from "@phala/dstack-sdk/verify-env-encrypt-public-key";
export {
  AddComposeHashSchema,
  AllFamiliesResponseSchema,
  ApiErrorSchema,
  AuthError,
  AvailableNodesSchema,
  BusinessError,
  CommitCvmComposeFileUpdateRequestSchema,
  CommitCvmComposeFileUpdateSchema,
  CommitCvmProvisionRequestSchema,
  CommitCvmProvisionSchema,
  CurrentUserSchema,
  CvmAttestationSchema,
  CvmContainersStatsSchema,
  CvmIdBaseSchema,
  CvmIdObjectSchema,
  CvmIdSchema,
  CvmInfoSchema,
  CvmLegacyDetailSchema,
  CvmNetworkSchema,
  CvmNetworkUrlsSchema,
  CvmNodeSchema,
  CvmStateSchema,
  CvmSystemInfoSchema,
  DeleteCvmRequestSchema,
  DeployAppAuthRequestSchema,
  DeployAppAuthSchema,
  FamilyGroupSchema,
  FamilyInstanceTypesResponseSchema,
  GetAppEnvEncryptPubKeyRequestSchema,
  GetAppEnvEncryptPubKeySchema,
  GetAvailableOSImagesRequestSchema,
  GetAvailableOSImagesResponseSchema,
  GetCvmAttestationRequestSchema,
  GetCvmComposeFileRequestSchema,
  GetCvmContainersStatsRequestSchema,
  GetCvmDockerComposeRequestSchema,
  GetCvmInfoRequestSchema,
  GetCvmListRequestSchema,
  GetCvmListSchema,
  GetCvmNetworkRequestSchema,
  GetCvmStateRequestSchema,
  GetCvmStatsRequestSchema,
  GetKmsInfoRequestSchema,
  GetKmsListRequestSchema,
  GetKmsListSchema,
  InstanceTypeSchema,
  KmsInfoSchema,
  ListFamilyInstanceTypesRequestSchema,
  ListWorkspacesSchema,
  ManagedUserSchema,
  MaxRetriesExceededError,
  NetworkError,
  NextAppIdsRequestSchema,
  NextAppIdsSchema,
  OSImageVariantSchema,
  PaginationMetadataSchema,
  PhalaCloudError,
  ProvisionCvmComposeFileUpdateRequestSchema,
  ProvisionCvmComposeFileUpdateResultSchema,
  ProvisionCvmRequestSchema,
  ProvisionCvmSchema,
  RequestError,
  ResourceError,
  RestartCvmRequestSchema,
  SUPPORTED_API_VERSIONS,
  SUPPORTED_CHAINS,
  ServerError,
  ShutdownCvmRequestSchema,
  StartCvmRequestSchema,
  StopCvmRequestSchema,
  TransactionError,
  UnknownError,
  UpdateCvmEnvsRequestSchema,
  UpdateCvmEnvsResultSchema,
  UpdateCvmResourcesRequestSchema,
  UpdateCvmVisibilityRequestSchema,
  UpdateOsImageRequestSchema,
  VMSchema,
  ValidationError,
  VmInfoSchema,
  WalletError,
  WatchAbortedError,
  WatchCvmStateRequestSchema,
  WorkspaceResponseSchema,
  addComposeHash,
  addNetwork,
  asHex,
  autoCreateClients,
  checkBalance,
  checkNetworkStatus,
  commitCvmComposeFileUpdate,
  commitCvmProvision,
  createClient as createBaseClient,
  createClient2 as createClient,
  createClientsFromBrowser,
  createClientsFromPrivateKey,
  createNetworkClients,
  createTransactionTracker,
  defineAction,
  defineSimpleAction,
  deleteCvm,
  deployAppAuth,
  dumpAppCompose,
  encryptEnvVars2 as encryptEnvVars,
  estimateTransactionGas,
  executeBatchTransactions,
  executeTransaction,
  executeTransactionWithRetry,
  extractNetworkClients,
  formatErrorMessage,
  formatStructuredError,
  formatValidationErrors,
  getAppEnvEncryptPubKey,
  getAvailableNodes,
  getAvailableOsImages,
  getComposeHash2 as getComposeHash,
  getCurrentUser,
  getCvmAttestation,
  getCvmComposeFile,
  getCvmContainersStats,
  getCvmDockerCompose,
  getCvmInfo,
  getCvmList,
  getCvmNetwork,
  getCvmState,
  getCvmStats,
  getErrorMessage,
  getKmsInfo,
  getKmsList,
  getValidationFields,
  getWorkspace,
  listAllInstanceTypeFamilies,
  listFamilyInstanceTypes,
  listWorkspaces,
  nextAppIds,
  parseApiError,
  parseEnv,
  parseEnvVars,
  preprocessAppCompose,
  provisionCvm,
  provisionCvmComposeFileUpdate,
  refineCvmId,
  restartCvm,
  safeAddComposeHash,
  safeCommitCvmComposeFileUpdate,
  safeCommitCvmProvision,
  safeDeleteCvm,
  safeDeployAppAuth,
  safeGetAppEnvEncryptPubKey,
  safeGetAvailableNodes,
  safeGetAvailableOsImages,
  safeGetCurrentUser,
  safeGetCvmAttestation,
  safeGetCvmComposeFile,
  safeGetCvmContainersStats,
  safeGetCvmDockerCompose,
  safeGetCvmInfo,
  safeGetCvmList,
  safeGetCvmNetwork,
  safeGetCvmState,
  safeGetCvmStats,
  safeGetKmsInfo,
  safeGetKmsList,
  safeGetWorkspace,
  safeListAllInstanceTypeFamilies,
  safeListFamilyInstanceTypes,
  safeListWorkspaces,
  safeNextAppIds,
  safeProvisionCvm,
  safeProvisionCvmComposeFileUpdate,
  safeRestartCvm,
  safeShutdownCvm,
  safeStartCvm,
  safeStopCvm,
  safeUpdateCvmEnvs,
  safeUpdateCvmResources,
  safeUpdateCvmVisibility,
  safeUpdateOsImage,
  safeValidateActionParameters,
  shutdownCvm,
  sortObject,
  startCvm,
  stopCvm,
  switchToNetwork,
  updateCvmEnvs,
  updateCvmResources,
  updateCvmVisibility,
  updateOsImage,
  validateActionParameters,
  validateNetworkPrerequisites,
  verifyEnvEncryptPublicKey,
  waitForTransactionReceipt,
  watchCvmState,
  withComposeMethods
};
