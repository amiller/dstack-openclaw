"use strict";
// SPDX-FileCopyrightText: Â© 2024-2025 Phala Network <dstack@phala.network>
//
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TappdClient = exports.DstackClient = exports.verifyEnvEncryptPublicKey = exports.getComposeHash = void 0;
exports.to_hex = to_hex;
const fs_1 = __importDefault(require("fs"));
const crypto_1 = __importDefault(require("crypto"));
const send_rpc_request_1 = require("./send-rpc-request");
var get_compose_hash_1 = require("./get-compose-hash");
Object.defineProperty(exports, "getComposeHash", { enumerable: true, get: function () { return get_compose_hash_1.getComposeHash; } });
var verify_env_encrypt_public_key_1 = require("./verify-env-encrypt-public-key");
Object.defineProperty(exports, "verifyEnvEncryptPublicKey", { enumerable: true, get: function () { return verify_env_encrypt_public_key_1.verifyEnvEncryptPublicKey; } });
function to_hex(data) {
    if (typeof data === 'string') {
        return Buffer.from(data).toString('hex');
    }
    if (data instanceof Uint8Array) {
        return Buffer.from(data).toString('hex');
    }
    return data.toString('hex');
}
function x509key_to_uint8array(pem, max_length) {
    const content = pem.replace(/-----BEGIN PRIVATE KEY-----/, '')
        .replace(/-----END PRIVATE KEY-----/, '')
        .replace(/\n/g, '');
    const binaryDer = atob(content);
    if (!max_length) {
        max_length = binaryDer.length;
    }
    const result = new Uint8Array(max_length);
    for (let i = 0; i < max_length; i++) {
        result[i] = binaryDer.charCodeAt(i);
    }
    return result;
}
function replay_rtmr(history) {
    const INIT_MR = "000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
    if (history.length === 0) {
        return INIT_MR;
    }
    let mr = Buffer.from(INIT_MR, 'hex');
    for (const content of history) {
        // Convert hex string to buffer
        let contentBuffer = Buffer.from(content, 'hex');
        // Pad content with zeros if shorter than 48 bytes
        if (contentBuffer.length < 48) {
            const padding = Buffer.alloc(48 - contentBuffer.length, 0);
            contentBuffer = Buffer.concat([contentBuffer, padding]);
        }
        mr = Buffer.from(crypto_1.default.createHash('sha384')
            .update(Buffer.concat([mr, contentBuffer]))
            .digest());
    }
    return mr.toString('hex');
}
function reply_rtmrs(event_log) {
    const rtmrs = [];
    for (let idx = 0; idx < 4; idx++) {
        const history = event_log
            .filter(event => event.imr === idx)
            .map(event => event.digest);
        rtmrs[idx] = replay_rtmr(history);
    }
    return rtmrs;
}
class DstackClient {
    constructor(endpoint = undefined) {
        if (endpoint === undefined) {
            if (process.env.DSTACK_SIMULATOR_ENDPOINT) {
                console.warn(`Using simulator endpoint: ${process.env.DSTACK_SIMULATOR_ENDPOINT}`);
                endpoint = process.env.DSTACK_SIMULATOR_ENDPOINT;
            }
            else {
                endpoint = '/var/run/dstack.sock';
            }
        }
        if (endpoint.startsWith('/') && !fs_1.default.existsSync(endpoint)) {
            throw new Error(`Unix socket file ${endpoint} does not exist`);
        }
        this.endpoint = endpoint;
    }
    async getKey(path, purpose = '') {
        const payload = JSON.stringify({
            path: path,
            purpose: purpose
        });
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/GetKey', payload);
        return Object.freeze({
            key: new Uint8Array(Buffer.from(result.key, 'hex')),
            signature_chain: result.signature_chain.map(sig => new Uint8Array(Buffer.from(sig, 'hex'))),
            __name__: 'GetKeyResponse',
        });
    }
    async getTlsKey(options = {}) {
        const { subject = '', altNames = [], usageRaTls = false, usageServerAuth = true, usageClientAuth = false, } = options;
        let raw = {
            subject,
            usage_ra_tls: usageRaTls,
            usage_server_auth: usageServerAuth,
            usage_client_auth: usageClientAuth,
        };
        if (altNames && altNames.length) {
            raw['alt_names'] = altNames;
        }
        const payload = JSON.stringify(raw);
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/GetTlsKey', payload);
        const asUint8Array = (length) => x509key_to_uint8array(result.key, length);
        return Object.freeze({
            ...result,
            asUint8Array,
            __name__: 'GetTlsKeyResponse',
        });
    }
    async getQuote(report_data) {
        let hex = to_hex(report_data);
        if (hex.length > 128) {
            throw new Error(`Report data is too large, it should be less than 64 bytes.`);
        }
        const payload = JSON.stringify({ report_data: hex });
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/GetQuote', payload);
        if ('error' in result) {
            const err = result['error'];
            throw new Error(err);
        }
        Object.defineProperty(result, 'replayRtmrs', {
            get: () => () => reply_rtmrs(JSON.parse(result.event_log)),
            enumerable: true,
            configurable: false,
        });
        return Object.freeze(result);
    }
    async info() {
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/Info', '{}');
        return Object.freeze({
            ...result,
            tcb_info: JSON.parse(result.tcb_info),
        });
    }
    async isReachable() {
        try {
            // Use info endpoint to test connectivity with 500ms timeout
            await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/prpc/Tappd.Info', '{}', 500);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    /**
     * Emit an event. This extends the event to RTMR3 on TDX platform.
     *
     * Requires dstack OS 0.5.0 or later.
     *
     * @param event The event name
     * @param payload The event data as string or Buffer or Uint8Array
     */
    async emitEvent(event, payload) {
        if (!event) {
            throw new Error('Event name cannot be empty');
        }
        const hexPayload = to_hex(payload);
        await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/EmitEvent', JSON.stringify({
            event: event,
            payload: hexPayload
        }));
    }
    //
    // Legacy methods for backward compatibility with a warning to notify users about migrating to new methods.
    // These methods don't mean fully compatible as past, but we keep them here until next major version.
    //
    /**
     * @deprecated Use getKey instead.
     * @param path The path to the key.
     * @param subject The subject of the key.
     * @param altNames The alternative names of the key.
     * @returns The key.
     */
    async deriveKey(path, subject, altNames) {
        throw new Error('deriveKey is deprecated, please use getKey instead.');
    }
    /**
     * @deprecated Use getQuote instead.
     * @param report_data The report data.
     * @param hash_algorithm The hash algorithm.
     * @returns The quote.
     */
    async tdxQuote(report_data, hash_algorithm) {
        console.warn('tdxQuote is deprecated, please use getQuote instead');
        if (hash_algorithm !== "raw") {
            throw new Error('tdxQuote only supports raw hash algorithm.');
        }
        return this.getQuote(report_data);
    }
}
exports.DstackClient = DstackClient;
class TappdClient extends DstackClient {
    constructor(endpoint = undefined) {
        if (endpoint === undefined) {
            if (process.env.TAPPD_SIMULATOR_ENDPOINT) {
                console.warn(`Using tappd endpoint: ${process.env.TAPPD_SIMULATOR_ENDPOINT}`);
                endpoint = process.env.TAPPD_SIMULATOR_ENDPOINT;
            }
            else {
                endpoint = '/var/run/tappd.sock';
            }
        }
        console.warn('TappdClient is deprecated, please use DstackClient instead');
        super(endpoint);
    }
    /**
     * @deprecated Use getKey instead.
     * @param path The path to the key.
     * @param subject The subject of the key.
     * @param altNames The alternative names of the key.
     * @returns The key.
     */
    async deriveKey(path, subject, alt_names) {
        console.warn('deriveKey is deprecated, please use getKey instead');
        let raw = { path: path || '', subject: subject || path || '' };
        if (alt_names && alt_names.length) {
            raw['alt_names'] = alt_names;
        }
        const payload = JSON.stringify(raw);
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/prpc/Tappd.DeriveKey', payload);
        const asUint8Array = (length) => x509key_to_uint8array(result.key, length);
        return Object.freeze({
            ...result,
            asUint8Array,
            __name__: 'GetTlsKeyResponse',
        });
    }
    /**
     * @deprecated Use getQuote instead.
     * @param report_data The report data.
     * @param hash_algorithm The hash algorithm.
     * @returns The quote.
     */
    async tdxQuote(report_data, hash_algorithm) {
        console.warn('tdxQuote is deprecated, please use getQuote instead');
        let hex = to_hex(report_data);
        if (hash_algorithm === 'raw') {
            if (hex.length > 128) {
                throw new Error(`Report data is too large, it should less then 64 bytes when hash_algorithm is raw.`);
            }
            if (hex.length < 128) {
                hex = hex.padStart(128, '0');
            }
        }
        const payload = JSON.stringify({ report_data: hex, hash_algorithm });
        const result = await (0, send_rpc_request_1.send_rpc_request)(this.endpoint, '/prpc/Tappd.TdxQuote', payload);
        if ('error' in result) {
            const err = result['error'];
            throw new Error(err);
        }
        Object.defineProperty(result, 'replayRtmrs', {
            get: () => () => reply_rtmrs(JSON.parse(result.event_log)),
            enumerable: true,
            configurable: false,
        });
        return Object.freeze(result);
    }
}
exports.TappdClient = TappdClient;
//# sourceMappingURL=index.js.map