import { z } from 'zod';
import { CvmLegacyDetail } from '@phala/cloud';
export { CvmLegacyDetail as CvmInfoResponse } from '@phala/cloud';

declare const dockerConfigSchema: z.ZodObject<{
    password: z.ZodString;
    registry: z.ZodNullable<z.ZodString>;
    username: z.ZodString;
}, "strip", z.ZodTypeAny, {
    username?: string;
    password?: string;
    registry?: string;
}, {
    username?: string;
    password?: string;
    registry?: string;
}>;
declare const composeFileSchema: z.ZodObject<{
    docker_compose_file: z.ZodString;
    docker_config: z.ZodNullable<z.ZodOptional<z.ZodObject<{
        password: z.ZodString;
        registry: z.ZodNullable<z.ZodString>;
        username: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        username?: string;
        password?: string;
        registry?: string;
    }, {
        username?: string;
        password?: string;
        registry?: string;
    }>>>;
    features: z.ZodArray<z.ZodString, "many">;
    kms_enabled: z.ZodBoolean;
    manifest_version: z.ZodNumber;
    name: z.ZodString;
    public_logs: z.ZodBoolean;
    public_sysinfo: z.ZodBoolean;
    runner: z.ZodOptional<z.ZodString>;
    salt: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    tproxy_enabled: z.ZodBoolean;
    version: z.ZodOptional<z.ZodString>;
}, "passthrough", z.ZodTypeAny, z.objectOutputType<{
    docker_compose_file: z.ZodString;
    docker_config: z.ZodNullable<z.ZodOptional<z.ZodObject<{
        password: z.ZodString;
        registry: z.ZodNullable<z.ZodString>;
        username: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        username?: string;
        password?: string;
        registry?: string;
    }, {
        username?: string;
        password?: string;
        registry?: string;
    }>>>;
    features: z.ZodArray<z.ZodString, "many">;
    kms_enabled: z.ZodBoolean;
    manifest_version: z.ZodNumber;
    name: z.ZodString;
    public_logs: z.ZodBoolean;
    public_sysinfo: z.ZodBoolean;
    runner: z.ZodOptional<z.ZodString>;
    salt: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    tproxy_enabled: z.ZodBoolean;
    version: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">, z.objectInputType<{
    docker_compose_file: z.ZodString;
    docker_config: z.ZodNullable<z.ZodOptional<z.ZodObject<{
        password: z.ZodString;
        registry: z.ZodNullable<z.ZodString>;
        username: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        username?: string;
        password?: string;
        registry?: string;
    }, {
        username?: string;
        password?: string;
        registry?: string;
    }>>>;
    features: z.ZodArray<z.ZodString, "many">;
    kms_enabled: z.ZodBoolean;
    manifest_version: z.ZodNumber;
    name: z.ZodString;
    public_logs: z.ZodBoolean;
    public_sysinfo: z.ZodBoolean;
    runner: z.ZodOptional<z.ZodString>;
    salt: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    tproxy_enabled: z.ZodBoolean;
    version: z.ZodOptional<z.ZodString>;
}, z.ZodTypeAny, "passthrough">>;
declare const postCvmResponseSchema: z.ZodObject<{
    id: z.ZodNumber;
    name: z.ZodString;
    status: z.ZodString;
    teepod_id: z.ZodNullable<z.ZodNumber>;
    teepod: z.ZodNullable<z.ZodObject<{
        id: z.ZodNumber;
        name: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        name?: string;
        id?: number;
    }, {
        name?: string;
        id?: number;
    }>>;
    user_id: z.ZodNullable<z.ZodNumber>;
    app_id: z.ZodString;
    vm_uuid: z.ZodNullable<z.ZodString>;
    instance_id: z.ZodNullable<z.ZodString>;
    app_url: z.ZodNullable<z.ZodString>;
    base_image: z.ZodNullable<z.ZodString>;
    vcpu: z.ZodNumber;
    memory: z.ZodNumber;
    disk_size: z.ZodNumber;
    manifest_version: z.ZodNullable<z.ZodNumber>;
    version: z.ZodNullable<z.ZodString>;
    runner: z.ZodNullable<z.ZodString>;
    docker_compose_file: z.ZodNullable<z.ZodString>;
    features: z.ZodNullable<z.ZodArray<z.ZodString, "many">>;
    created_at: z.ZodString;
    encrypted_env_pubkey: z.ZodNullable<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    status?: string;
    name?: string;
    vcpu?: number;
    memory?: number;
    id?: number;
    app_id?: string;
    instance_id?: string;
    version?: string;
    runner?: string;
    docker_compose_file?: string;
    features?: string[];
    manifest_version?: number;
    teepod_id?: number;
    teepod?: {
        name?: string;
        id?: number;
    };
    user_id?: number;
    vm_uuid?: string;
    app_url?: string;
    base_image?: string;
    disk_size?: number;
    created_at?: string;
    encrypted_env_pubkey?: string;
}, {
    status?: string;
    name?: string;
    vcpu?: number;
    memory?: number;
    id?: number;
    app_id?: string;
    instance_id?: string;
    version?: string;
    runner?: string;
    docker_compose_file?: string;
    features?: string[];
    manifest_version?: number;
    teepod_id?: number;
    teepod?: {
        name?: string;
        id?: number;
    };
    user_id?: number;
    vm_uuid?: string;
    app_url?: string;
    base_image?: string;
    disk_size?: number;
    created_at?: string;
    encrypted_env_pubkey?: string;
}>;
declare const encryptedEnvItemSchema: z.ZodObject<{
    key: z.ZodString;
    value: z.ZodString;
}, "strip", z.ZodTypeAny, {
    value?: string;
    key?: string;
}, {
    value?: string;
    key?: string;
}>;
declare const getCvmNetworkResponseSchema: z.ZodObject<{
    is_online: z.ZodBoolean;
    is_public: z.ZodBoolean;
    error: z.ZodNullable<z.ZodString>;
    internal_ip: z.ZodString;
    latest_handshake: z.ZodString;
    public_urls: z.ZodArray<z.ZodObject<{
        app: z.ZodString;
        instance: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        app?: string;
        instance?: string;
    }, {
        app?: string;
        instance?: string;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    error?: string;
    is_online?: boolean;
    is_public?: boolean;
    internal_ip?: string;
    latest_handshake?: string;
    public_urls?: {
        app?: string;
        instance?: string;
    }[];
}, {
    error?: string;
    is_online?: boolean;
    is_public?: boolean;
    internal_ip?: string;
    latest_handshake?: string;
    public_urls?: {
        app?: string;
        instance?: string;
    }[];
}>;
type DockerConfig = z.infer<typeof dockerConfigSchema>;
type ComposeFile = z.infer<typeof composeFileSchema>;
type PostCvmResponse = z.infer<typeof postCvmResponseSchema>;
type EncryptedEnvItem = z.infer<typeof encryptedEnvItemSchema>;
type CvmAttestationResponse = z.infer<typeof cvmAttestationResponseSchema>;
type GetCvmNetworkResponse = z.infer<typeof getCvmNetworkResponseSchema>;
/**
 * Certificate naming information
 */
interface CertificateNameInfo {
    common_name: string | null;
    organization: string | null;
    country: string | null;
    state?: string | null;
    locality?: string | null;
}
/**
 * Certificate data structure
 */
interface CertificateInfo {
    subject: CertificateNameInfo;
    issuer: CertificateNameInfo;
    serial_number: string;
    not_before: string;
    not_after: string;
    version: string;
    fingerprint: string;
    signature_algorithm: string;
    sans: string | null;
    is_ca: boolean;
    position_in_chain: number;
    quote: string | null;
}
/**
 * Event log entry
 */
interface TCBEventLogEntry {
    imr: number;
    event_type: number;
    digest: string;
    event: string;
    event_payload: string;
}
/**
 * Trusted Computing Base (TCB) information
 */
interface TCBInfo {
    mrtd: string;
    rootfs_hash: string;
    rtmr0: string;
    rtmr1: string;
    rtmr2: string;
    rtmr3: string;
    event_log: TCBEventLogEntry[];
}
declare const replicateCvmResponseSchema: z.ZodObject<{
    id: z.ZodNumber;
    name: z.ZodString;
    status: z.ZodString;
    teepod_id: z.ZodNumber;
    teepod: z.ZodObject<{
        id: z.ZodNumber;
        name: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        name?: string;
        id?: number;
    }, {
        name?: string;
        id?: number;
    }>;
    user_id: z.ZodNullable<z.ZodNumber>;
    app_id: z.ZodString;
    vm_uuid: z.ZodNullable<z.ZodString>;
    instance_id: z.ZodNullable<z.ZodString>;
    app_url: z.ZodNullable<z.ZodString>;
    base_image: z.ZodNullable<z.ZodString>;
    vcpu: z.ZodNumber;
    memory: z.ZodNumber;
    disk_size: z.ZodNumber;
    manifest_version: z.ZodNullable<z.ZodNumber>;
    version: z.ZodNullable<z.ZodString>;
    runner: z.ZodNullable<z.ZodString>;
    docker_compose_file: z.ZodNullable<z.ZodString>;
    features: z.ZodNullable<z.ZodArray<z.ZodString, "many">>;
    created_at: z.ZodString;
    encrypted_env_pubkey: z.ZodNullable<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    status?: string;
    name?: string;
    vcpu?: number;
    memory?: number;
    id?: number;
    app_id?: string;
    instance_id?: string;
    version?: string;
    runner?: string;
    docker_compose_file?: string;
    features?: string[];
    manifest_version?: number;
    teepod_id?: number;
    teepod?: {
        name?: string;
        id?: number;
    };
    user_id?: number;
    vm_uuid?: string;
    app_url?: string;
    base_image?: string;
    disk_size?: number;
    created_at?: string;
    encrypted_env_pubkey?: string;
}, {
    status?: string;
    name?: string;
    vcpu?: number;
    memory?: number;
    id?: number;
    app_id?: string;
    instance_id?: string;
    version?: string;
    runner?: string;
    docker_compose_file?: string;
    features?: string[];
    manifest_version?: number;
    teepod_id?: number;
    teepod?: {
        name?: string;
        id?: number;
    };
    user_id?: number;
    vm_uuid?: string;
    app_url?: string;
    base_image?: string;
    disk_size?: number;
    created_at?: string;
    encrypted_env_pubkey?: string;
}>;
type ReplicateCvmResponse = z.infer<typeof replicateCvmResponseSchema>;
declare const cvmAttestationResponseSchema: z.ZodObject<{
    is_online: z.ZodBoolean;
    is_public: z.ZodBoolean;
    error: z.ZodNullable<z.ZodString>;
    app_certificates: z.ZodNullable<z.ZodArray<z.ZodObject<{
        subject: z.ZodObject<{
            common_name: z.ZodNullable<z.ZodString>;
            organization: z.ZodNullable<z.ZodString>;
            country: z.ZodNullable<z.ZodString>;
            state: z.ZodOptional<z.ZodNullable<z.ZodString>>;
            locality: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        }, "strip", z.ZodTypeAny, {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        }, {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        }>;
        issuer: z.ZodObject<{
            common_name: z.ZodNullable<z.ZodString>;
            organization: z.ZodNullable<z.ZodString>;
            country: z.ZodNullable<z.ZodString>;
        }, "strip", z.ZodTypeAny, {
            common_name?: string;
            organization?: string;
            country?: string;
        }, {
            common_name?: string;
            organization?: string;
            country?: string;
        }>;
        serial_number: z.ZodString;
        not_before: z.ZodString;
        not_after: z.ZodString;
        version: z.ZodString;
        fingerprint: z.ZodString;
        signature_algorithm: z.ZodString;
        sans: z.ZodNullable<z.ZodString>;
        is_ca: z.ZodBoolean;
        position_in_chain: z.ZodNumber;
        quote: z.ZodNullable<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        version?: string;
        subject?: {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        };
        issuer?: {
            common_name?: string;
            organization?: string;
            country?: string;
        };
        serial_number?: string;
        not_before?: string;
        not_after?: string;
        fingerprint?: string;
        signature_algorithm?: string;
        sans?: string;
        is_ca?: boolean;
        position_in_chain?: number;
        quote?: string;
    }, {
        version?: string;
        subject?: {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        };
        issuer?: {
            common_name?: string;
            organization?: string;
            country?: string;
        };
        serial_number?: string;
        not_before?: string;
        not_after?: string;
        fingerprint?: string;
        signature_algorithm?: string;
        sans?: string;
        is_ca?: boolean;
        position_in_chain?: number;
        quote?: string;
    }>, "many">>;
    tcb_info: z.ZodNullable<z.ZodObject<{
        mrtd: z.ZodString;
        rootfs_hash: z.ZodString;
        rtmr0: z.ZodString;
        rtmr1: z.ZodString;
        rtmr2: z.ZodString;
        rtmr3: z.ZodString;
        event_log: z.ZodArray<z.ZodObject<{
            imr: z.ZodNumber;
            event_type: z.ZodNumber;
            digest: z.ZodString;
            event: z.ZodString;
            event_payload: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }, {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        mrtd?: string;
        rootfs_hash?: string;
        rtmr0?: string;
        rtmr1?: string;
        rtmr2?: string;
        rtmr3?: string;
        event_log?: {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }[];
    }, {
        mrtd?: string;
        rootfs_hash?: string;
        rtmr0?: string;
        rtmr1?: string;
        rtmr2?: string;
        rtmr3?: string;
        event_log?: {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }[];
    }>>;
    compose_file: z.ZodNullable<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    error?: string;
    compose_file?: string;
    is_online?: boolean;
    is_public?: boolean;
    app_certificates?: {
        version?: string;
        subject?: {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        };
        issuer?: {
            common_name?: string;
            organization?: string;
            country?: string;
        };
        serial_number?: string;
        not_before?: string;
        not_after?: string;
        fingerprint?: string;
        signature_algorithm?: string;
        sans?: string;
        is_ca?: boolean;
        position_in_chain?: number;
        quote?: string;
    }[];
    tcb_info?: {
        mrtd?: string;
        rootfs_hash?: string;
        rtmr0?: string;
        rtmr1?: string;
        rtmr2?: string;
        rtmr3?: string;
        event_log?: {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }[];
    };
}, {
    error?: string;
    compose_file?: string;
    is_online?: boolean;
    is_public?: boolean;
    app_certificates?: {
        version?: string;
        subject?: {
            common_name?: string;
            organization?: string;
            country?: string;
            state?: string;
            locality?: string;
        };
        issuer?: {
            common_name?: string;
            organization?: string;
            country?: string;
        };
        serial_number?: string;
        not_before?: string;
        not_after?: string;
        fingerprint?: string;
        signature_algorithm?: string;
        sans?: string;
        is_ca?: boolean;
        position_in_chain?: number;
        quote?: string;
    }[];
    tcb_info?: {
        mrtd?: string;
        rootfs_hash?: string;
        rtmr0?: string;
        rtmr1?: string;
        rtmr2?: string;
        rtmr3?: string;
        event_log?: {
            imr?: number;
            event_type?: number;
            digest?: string;
            event?: string;
            event_payload?: string;
        }[];
    };
}>;
declare const imageSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    version: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
    is_dev: z.ZodOptional<z.ZodBoolean>;
    os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    rootfs_hash: z.ZodOptional<z.ZodString>;
    shared_ro: z.ZodOptional<z.ZodBoolean>;
    cmdline: z.ZodOptional<z.ZodString>;
    kernel: z.ZodOptional<z.ZodString>;
    initrd: z.ZodOptional<z.ZodString>;
    hda: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    rootfs: z.ZodOptional<z.ZodString>;
    bios: z.ZodOptional<z.ZodString>;
}, "strip", z.ZodTypeAny, {
    name?: string;
    description?: string;
    version?: number[];
    rootfs_hash?: string;
    is_dev?: boolean;
    os_image_hash?: string;
    shared_ro?: boolean;
    cmdline?: string;
    kernel?: string;
    initrd?: string;
    hda?: string;
    rootfs?: string;
    bios?: string;
}, {
    name?: string;
    description?: string;
    version?: number[];
    rootfs_hash?: string;
    is_dev?: boolean;
    os_image_hash?: string;
    shared_ro?: boolean;
    cmdline?: string;
    kernel?: string;
    initrd?: string;
    hda?: string;
    rootfs?: string;
    bios?: string;
}>;
declare const teepodSchema: z.ZodObject<{
    teepod_id: z.ZodNullable<z.ZodNumber>;
    id: z.ZodOptional<z.ZodNumber>;
    name: z.ZodString;
    listed: z.ZodOptional<z.ZodBoolean>;
    resource_score: z.ZodOptional<z.ZodNumber>;
    remaining_vcpu: z.ZodOptional<z.ZodNumber>;
    remaining_memory: z.ZodOptional<z.ZodNumber>;
    remaining_cvm_slots: z.ZodOptional<z.ZodNumber>;
    images: z.ZodOptional<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        version: z.ZodOptional<z.ZodArray<z.ZodNumber, "many">>;
        is_dev: z.ZodOptional<z.ZodBoolean>;
        os_image_hash: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        rootfs_hash: z.ZodOptional<z.ZodString>;
        shared_ro: z.ZodOptional<z.ZodBoolean>;
        cmdline: z.ZodOptional<z.ZodString>;
        kernel: z.ZodOptional<z.ZodString>;
        initrd: z.ZodOptional<z.ZodString>;
        hda: z.ZodOptional<z.ZodNullable<z.ZodString>>;
        rootfs: z.ZodOptional<z.ZodString>;
        bios: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        name?: string;
        description?: string;
        version?: number[];
        rootfs_hash?: string;
        is_dev?: boolean;
        os_image_hash?: string;
        shared_ro?: boolean;
        cmdline?: string;
        kernel?: string;
        initrd?: string;
        hda?: string;
        rootfs?: string;
        bios?: string;
    }, {
        name?: string;
        description?: string;
        version?: number[];
        rootfs_hash?: string;
        is_dev?: boolean;
        os_image_hash?: string;
        shared_ro?: boolean;
        cmdline?: string;
        kernel?: string;
        initrd?: string;
        hda?: string;
        rootfs?: string;
        bios?: string;
    }>, "many">>;
    region_identifier: z.ZodOptional<z.ZodString>;
    dedicated_for_team_id: z.ZodOptional<z.ZodNullable<z.ZodNumber>>;
    support_onchain_kms: z.ZodOptional<z.ZodBoolean>;
    fmspc: z.ZodOptional<z.ZodNullable<z.ZodString>>;
    device_id: z.ZodOptional<z.ZodNullable<z.ZodString>>;
}, "strip", z.ZodTypeAny, {
    name?: string;
    listed?: boolean;
    id?: number;
    teepod_id?: number;
    resource_score?: number;
    remaining_vcpu?: number;
    remaining_memory?: number;
    remaining_cvm_slots?: number;
    images?: {
        name?: string;
        description?: string;
        version?: number[];
        rootfs_hash?: string;
        is_dev?: boolean;
        os_image_hash?: string;
        shared_ro?: boolean;
        cmdline?: string;
        kernel?: string;
        initrd?: string;
        hda?: string;
        rootfs?: string;
        bios?: string;
    }[];
    region_identifier?: string;
    dedicated_for_team_id?: number;
    support_onchain_kms?: boolean;
    fmspc?: string;
    device_id?: string;
}, {
    name?: string;
    listed?: boolean;
    id?: number;
    teepod_id?: number;
    resource_score?: number;
    remaining_vcpu?: number;
    remaining_memory?: number;
    remaining_cvm_slots?: number;
    images?: {
        name?: string;
        description?: string;
        version?: number[];
        rootfs_hash?: string;
        is_dev?: boolean;
        os_image_hash?: string;
        shared_ro?: boolean;
        cmdline?: string;
        kernel?: string;
        initrd?: string;
        hda?: string;
        rootfs?: string;
        bios?: string;
    }[];
    region_identifier?: string;
    dedicated_for_team_id?: number;
    support_onchain_kms?: boolean;
    fmspc?: string;
    device_id?: string;
}>;
type TEEPod = z.infer<typeof teepodSchema>;
type Image = z.infer<typeof imageSchema>;
interface TeepodResponse {
    nodes: TEEPod[];
    kms_list?: KmsListItem[];
}
interface KmsListItem {
    id?: string;
    slug?: string | null;
    url: string;
    version: string;
    chain_id?: number | null;
    kms_contract_address?: string | null;
    gateway_app_id?: string | null;
}
interface PubkeyResponse {
    app_env_encrypt_pubkey: string;
    app_id_salt: string;
}

interface UpgradeResponse {
    detail?: string;
    [key: string]: unknown;
}
interface UserInfoResponse {
    username: string;
    [key: string]: unknown;
}
interface CvmListResponse {
    items: unknown[];
    [key: string]: unknown;
}
interface AvailableNodesResponse {
    nodes: TEEPod[];
    kms_list?: KmsListItem[];
}
interface CvmComposeConfigResponse {
    env_pubkey: string;
    [key: string]: unknown;
}

/**
 * Get CVM by App ID using SDK
 * @param appId App ID (with or without app_ prefix)
 * @returns CVM details
 */
declare function getCvmByAppId(appId: string): Promise<CvmLegacyDetail>;
/**
 * Get CVM compose configuration
 */
declare function getCvmComposeConfig(cvmId: string): Promise<CvmComposeConfigResponse>;
/**
 * Get CVM network information
 * @param appId App ID (with or without app_ prefix)
 * @returns Network information
 */
declare function getCvmNetwork(appId: string): Promise<GetCvmNetworkResponse>;
/**
 * Start a CVM
 * @param appId App ID (with or without app_ prefix)
 * @returns Success status
 */
declare function startCvm(appId: string): Promise<PostCvmResponse>;
/**
 * Stop a CVM
 * @param appId App ID (with or without app_ prefix)
 * @returns Success status
 */
declare function stopCvm(appId: string): Promise<PostCvmResponse>;
/**
 * Restart a CVM
 * @param appId App ID (with or without app_ prefix)
 * @returns Success status
 */
declare function restartCvm(appId: string): Promise<PostCvmResponse>;
/**
 * Delete a CVM
 * @param appId App ID (with or without app_ prefix)
 * @returns Success status
 */
declare function deleteCvm(appId: string): Promise<boolean>;
/**
 * Presents a list of CVMs to the user and allows them to select one
 * @returns The selected CVM app ID or undefined if no CVMs exist
 */
declare function selectCvm(): Promise<string | undefined>;
/**
 * Get attestation information for a CVM
 * @param appId App ID (with or without app_ prefix)
 * @returns Attestation information
 */
declare function getCvmAttestation(appId: string): Promise<CvmAttestationResponse>;
/**
 * Resize payload type
 */
interface ResizeCvmPayload {
    vcpu?: number;
    memory?: number;
    disk_size?: number;
    allow_restart?: number;
}
/**
 * Replicate a CVM
 * @param appId App ID (with or without app_ prefix)
 */
declare function replicateCvm(appId: string, payload: {
    teepod_id?: number;
    encrypted_env?: string;
}): Promise<ReplicateCvmResponse>;
/**
 * Resize a CVM's resources
 * @param appId App ID (with or without app_ prefix)
 * @param vcpu Number of virtual CPUs (optional)
 * @param memory Memory size in MB (optional)
 * @param diskSize Disk size in GB (optional)
 * @param allowRestart Whether to allow restart (1) or not (0) for the resize operation (optional)
 * @returns Success status
 */
declare function resizeCvm(appId: string, vcpu?: number, memory?: number, diskSize?: number, allowRestart?: number): Promise<boolean>;
/**
 * VM configuration type
 */
interface VMConfig {
    [key: string]: unknown;
}
/**
 * Get public key from CVM (Legacy)
 * @deprecated This is a legacy function for create command
 * @param vmConfig VM configuration
 * @returns Public key
 */
declare function getPubkeyFromCvm(vmConfig: VMConfig): Promise<PubkeyResponse>;
/**
 * Create a new CVM (Legacy)
 * @deprecated This is a legacy function, consider using SDK's provisionCvm
 * @param vmConfig VM configuration
 * @returns Created CVM details
 */
declare function createCvm(vmConfig: VMConfig): Promise<PostCvmResponse>;
/**
 * Upgrade a CVM (Legacy)
 * @deprecated This is a legacy function, consider using SDK's provisionCvmComposeFileUpdate
 * @param appId App ID (with or without app_ prefix)
 * @param vmConfig VM configuration
 * @returns Upgrade response
 */
declare function upgradeCvm(appId: string, vmConfig: VMConfig): Promise<UpgradeResponse>;
/**
 * Get all TEEPods with their images (Legacy)
 * @deprecated This is a legacy function for create command, use SDK's safeGetAvailableNodes instead
 * @param v03x_only Only get v0.3.x compatible nodes
 * @returns List of TEEPods with embedded images
 */
declare function getTeepods(v03x_only?: boolean): Promise<TeepodResponse>;
interface SerialLogsOptions {
    tail?: number;
    timestamps?: boolean;
}
interface ContainerLogsOptions extends SerialLogsOptions {
    container?: string;
}
/** Fetch serial logs from a CVM */
declare function fetchSerialLogs(appId: string, options?: SerialLogsOptions): Promise<string>;
/**
 * Fetch container logs from a CVM
 * Note: Fetches from a single container. Use --container to specify which one,
 * otherwise fetches from the first container with a log endpoint.
 */
declare function fetchContainerLogs(appId: string, options?: ContainerLogsOptions): Promise<string>;
/** Stream serial logs from a CVM */
declare function streamSerialLogs(appId: string, onData: (data: string) => void, options?: SerialLogsOptions, signal?: AbortSignal): Promise<void>;
/**
 * Stream container logs from a CVM
 * Note: Streams from a single container. Use --container to specify which one,
 * otherwise streams from the first container with a log endpoint.
 */
declare function streamContainerLogs(appId: string, onData: (data: string) => void, options?: ContainerLogsOptions, signal?: AbortSignal): Promise<void>;

export { type AvailableNodesResponse, type CertificateInfo, type CertificateNameInfo, type ComposeFile, type ContainerLogsOptions, type CvmAttestationResponse, type CvmComposeConfigResponse, type CvmListResponse, type DockerConfig, type EncryptedEnvItem, type GetCvmNetworkResponse, type Image, type KmsListItem, type PostCvmResponse, type PubkeyResponse, type ReplicateCvmResponse, type ResizeCvmPayload, type SerialLogsOptions, type TCBEventLogEntry, type TCBInfo, type TEEPod, type TeepodResponse, type UpgradeResponse, type UserInfoResponse, type VMConfig, composeFileSchema, createCvm, cvmAttestationResponseSchema, deleteCvm, dockerConfigSchema, encryptedEnvItemSchema, fetchContainerLogs, fetchSerialLogs, getCvmAttestation, getCvmByAppId, getCvmComposeConfig, getCvmNetwork, getCvmNetworkResponseSchema, getPubkeyFromCvm, getTeepods, imageSchema, postCvmResponseSchema, replicateCvm, replicateCvmResponseSchema, resizeCvm, restartCvm, selectCvm, startCvm, stopCvm, streamContainerLogs, streamSerialLogs, teepodSchema, upgradeCvm };
